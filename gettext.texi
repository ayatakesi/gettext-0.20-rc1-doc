\input texinfo          @c -*-texinfo-*-
@c ===========================================================================
@c
@c This file was generated with po4a. Translate the source file.
@c
@c ===========================================================================
@c %**start of header
@setfilename gettext.info
@c The @ifset makeinfo ... @end ifset conditional evaluates to true in makeinfo
@c for info and html output, but to false in texi2html.
@ifnottex
@ifclear texi2html
@set makeinfo
@end ifclear
@end ifnottex
@c The @documentencoding is needed for makeinfo; texi2html 1.52
@c doesn't recognize it.
@ifset makeinfo
@documentencoding UTF-8
@end ifset
@settitle GNU @code{gettext} utilities
@finalout
@c Indices:
@c   am = autoconf macro  @amindex
@c   cp = concept         @cindex
@c   ef = emacs function  @efindex
@c   em = emacs mode      @emindex
@c   ev = emacs variable  @evindex
@c   fn = function        @findex
@c   kw = keyword         @kwindex
@c   op = option          @opindex
@c   pg = program         @pindex
@c   vr = variable        @vindex
@c Unused predefined indices:
@c   tp = type            @tindex
@c   ky = keystroke       @kindex
@defcodeindex am
@defcodeindex ef
@defindex em
@defcodeindex ev
@defcodeindex kw
@defcodeindex op
@syncodeindex ef em
@syncodeindex ev em
@syncodeindex fn cp
@syncodeindex kw cp
@ifclear texi2html
@firstparagraphindent insert
@end ifclear
@c %**end of header

@include version.texi

@ifinfo
@dircategory GNU Gettext Utilities
@direntry
* gettext: (gettext).        GNU gettext utilities.
* autopoint: (gettext)autopoint Invocation.  Copy gettext infrastructure.
* envsubst: (gettext)envsubst Invocation.  Expand environment variables.
* gettextize: (gettext)gettextize Invocation.  Prepare a package for 
                                                 gettext.
* msgattrib: (gettext)msgattrib Invocation.  Select part of a PO file.
* msgcat: (gettext)msgcat Invocation.  Combine several PO files.
* msgcmp: (gettext)msgcmp Invocation.  Compare a PO file and template.
* msgcomm: (gettext)msgcomm Invocation.  Match two PO files.
* msgconv: (gettext)msgconv Invocation.  Convert PO file to encoding.
* msgen: (gettext)msgen Invocation.  Create an English PO file.
* msgexec: (gettext)msgexec Invocation.  Process a PO file.
* msgfilter: (gettext)msgfilter Invocation.  Pipe a PO file through a 
                                               filter.
* msgfmt: (gettext)msgfmt Invocation.  Make MO files out of PO files.
* msggrep: (gettext)msggrep Invocation.  Select part of a PO file.
* msginit: (gettext)msginit Invocation.  Create a fresh PO file.
* msgmerge: (gettext)msgmerge Invocation.  Update a PO file from template.
* msgunfmt: (gettext)msgunfmt Invocation.  Uncompile MO file into PO file.
* msguniq: (gettext)msguniq Invocation.  Unify duplicates for PO file.
* ngettext: (gettext)ngettext Invocation.  Translate a message with plural.
* xgettext: (gettext)xgettext Invocation.  Extract strings into a PO file.
* ISO639: (gettext)Language Codes.  ISO 639 language codes.
* ISO3166: (gettext)Country Codes.  ISO 3166 country codes.
@end direntry
@end ifinfo

@ifinfo
このファイルはGNU @code{gettext}ユーティリティーのドキュメントを提供します。またフリーの翻訳プロジェクト(Translation
Project)にたいする参照の役割も果たします。

@copying
@w{Copyright (C) 2013-2019 Ayanokoji Takesi <ayanokoji.takesi@@gmail.com>}@*
@w{Copyright (C) 1997-2001 Rue. SATOH(佐藤竜一) / Koichi KIMURA(木村浩一)}@*
@w{Copyright (C) 1995-1998, 2001-2019 Free Software Foundation, Inc.}

このマニュアルは、フリーのドキュメント(free documentation)です。このマニュアルは、GNU FDLとGNU
GPLの両方でライセンスされています。これは、あなたがこのマニュアルをこれら2つのライセンスのどちらか一方を選択して、再配布できることを意味します。

このマニュアルは、GNU FDLにより保護されています。このドキュメントを、Free Documentation License(FDL)の
バージョン1.2、または(オプションで)Free Software
Foundation(FSF)により公表された、より新しいバージョンの元で、コピー、変更または変更したものの配布にたいする許可が与えられます。変更不可能なセクション、表紙のテキスト、裏表紙のテキストはありません。このライセンスののコピーは、@ref{GNU
FDL}に含まれています。

このマニュアルは、GNU GPLにより保護されています。このマニュアルを、GNU General Public
License(GPL)のバージョン2、または(オプションで)Free Software Foundation
(FSF)により公表された、より新しいバージョンの条件下で、再配布、および／または再配布することができます。このライセンスのコピーは、@ref{GNU
GPL}に含まれています。
@end copying
@end ifinfo

@titlepage
@title GNU gettext tools, version @value{VERSION}
@subtitle Native Language Support Library and Tools
@subtitle Edition @value{EDITION}, @value{UPDATED}
@author  日本語訳: Ayanokoji Takesi(綾小路剛志)
@author 日本語訳: Rue. SATOH(佐藤竜一) / Koichi KIMURA(木村浩一)
@author Ulrich Drepper
@author Jim Meyering
@author Fran@,{c}ois Pinard
@author Bruno Haible

@ifnothtml
@page
@vskip 0pt plus 1filll
@c @insertcopying
@w{Copyright (C) 2013-2019 Ayanokoji Takesi <ayanokoji.takesi@@gmail.com>}@*
@w{Copyright (C) 1997-2001 Rue. SATOH(佐藤竜一) / Koichi KIMURA(木村浩一)}@*
@w{Copyright (C) 1995-1998, 2001-2019 Free Software Foundation, Inc.}

このマニュアルは、フリーのドキュメント(free documentation)です。このマニュアルは、GNU FDLとGNU
GPLの両方でライセンスされています。これは、あなたがこのマニュアルをこれら2つのライセンスのどちらか一方を選択して、再配布できることを意味します。

このマニュアルは、GNU FDLにより保護されています。このドキュメントを、Free Documentation License(FDL)の
バージョン1.2、または(オプションで)Free Software
Foundation(FSF)により公表された、より新しいバージョンの元で、コピー、変更または変更したものの配布にたいする許可が与えられます。変更不可能なセクション、表紙のテキスト、裏表紙のテキストはありません。このライセンスののコピーは、@ref{GNU
FDL}に含まれています。

このマニュアルは、GNU GPLにより保護されています。このマニュアルを、GNU General Public
License(GPL)のバージョン2、または(オプションで)Free Software Foundation
(FSF)により公表された、より新しいバージョンの条件下で、再配布、および／または再配布することができます。このライセンスのコピーは、@ref{GNU
GPL}に含まれています。
@end ifnothtml
@end titlepage

@c Table of Contents
@contents

@ifnottex
@node Top
@top GNU @code{gettext} utilities

This manual documents the GNU gettext tools and the GNU libintl library,
version @value{VERSION}.

@menu
* Introduction::             Introduction
* Users::                    The User's View
* PO Files::                 The Format of PO Files
* Sources::                  Preparing Program Sources
* Template::                 Making the PO Template File
* Creating::                 Creating a New PO File
* Updating::                 Updating Existing PO Files
* Editing::                  Editing PO Files
* Manipulating::             Manipulating PO Files
* Binaries::                 Producing Binary MO Files
* Programmers::              The Programmer's View
* Translators::              The Translator's View
* Maintainers::              The Maintainer's View
* Installers::               The Installer's and Distributor's View
* Programming Languages::    Other Programming Languages
* Data Formats::             Other Data Formats
* Conclusion::               Concluding Remarks

* Language Codes::           ISO 639 language codes
* Country Codes::            ISO 3166 country codes
* Licenses::                 Licenses

* Program Index::            Index of Programs
* Option Index::             Index of Command-Line Options
* Variable Index::           Index of Environment Variables
* PO Mode Index::            Index of Emacs PO Mode Commands
* Autoconf Macro Index::     Index of Autoconf Macros
* Index::                    General Index

@detailmenu
 --- The Detailed Node Listing ---



Introduction



* Why::                      The Purpose of GNU @code{gettext}
* Concepts::                 I18n, L10n, and Such
* Aspects::                  Aspects in Native Language Support
* Files::                    Files Conveying Translations
* Overview::                 Overview of GNU @code{gettext}

The User's View



* System Installation::      Questions During Operating System Installation
* Setting the GUI Locale::   How to Specify the Locale Used by GUI Programs
* Setting the POSIX Locale::  How to Specify the Locale According to POSIX
* Installing Localizations::  How to Install Additional Translations

Setting the Locale through Environment Variables



* Locale Names::             How a Locale Specification Looks Like
* Locale Environment Variables::  Which Environment Variable Specfies What
* The LANGUAGE variable::    How to Specify a Priority List of Languages

Preparing Program Sources



* Importing::                Importing the @code{gettext} declaration
* Triggering::               Triggering @code{gettext} Operations
* Preparing Strings::        Preparing Translatable Strings
* Mark Keywords::            How Marks Appear in Sources
* Marking::                  Marking Translatable Strings
* c-format Flag::            Telling something about the following string
* Special cases::            Special Cases of Translatable Strings
* Bug Report Address::       Letting Users Report Translation Bugs
* Names::                    Marking Proper Names for Translation
* Libraries::                Preparing Library Sources

Making the PO Template File



* xgettext Invocation::      Invoking the @code{xgettext} Program

Creating a New PO File



* msginit Invocation::       Invoking the @code{msginit} Program
* Header Entry::             Filling in the Header Entry

Updating Existing PO Files



* msgmerge Invocation::      Invoking the @code{msgmerge} Program

Editing PO Files



* KBabel::                   KDE's PO File Editor
* Gtranslator::              GNOME's PO File Editor
* PO Mode::                  Emacs's PO File Editor
* Compendium::               Using Translation Compendia

Emacs's PO File Editor



* Installation::             Completing GNU @code{gettext} Installation
* Main PO Commands::         Main Commands
* Entry Positioning::        Entry Positioning
* Normalizing::              Normalizing Strings in Entries
* Translated Entries::       Translated Entries
* Fuzzy Entries::            Fuzzy Entries
* Untranslated Entries::     Untranslated Entries
* Obsolete Entries::         Obsolete Entries
* Modifying Translations::   Modifying Translations
* Modifying Comments::       Modifying Comments
* Subedit::                  Mode for Editing Translations
* C Sources Context::        C Sources Context
* Auxiliary::                Consulting Auxiliary PO Files

Using Translation Compendia



* Creating Compendia::       Merging translations for later use
* Using Compendia::          Using older translations if they fit

Manipulating PO Files



* msgcat Invocation::        Invoking the @code{msgcat} Program
* msgconv Invocation::       Invoking the @code{msgconv} Program
* msggrep Invocation::       Invoking the @code{msggrep} Program
* msgfilter Invocation::     Invoking the @code{msgfilter} Program
* msguniq Invocation::       Invoking the @code{msguniq} Program
* msgcomm Invocation::       Invoking the @code{msgcomm} Program
* msgcmp Invocation::        Invoking the @code{msgcmp} Program
* msgattrib Invocation::     Invoking the @code{msgattrib} Program
* msgen Invocation::         Invoking the @code{msgen} Program
* msgexec Invocation::       Invoking the @code{msgexec} Program
* Colorizing::               Highlighting parts of PO files
* Other tools::              Other tools for manipulating PO files
* libgettextpo::             Writing your own programs that process PO files

Highlighting parts of PO files



* The --color option::       Triggering colorized output
* The TERM variable::        The environment variable @code{TERM}
* The --style option::       The @code{--style} option
* Style rules::              Style rules for PO files
* Customizing less::         Customizing @code{less} for viewing PO files

Producing Binary MO Files



* msgfmt Invocation::        Invoking the @code{msgfmt} Program
* msgunfmt Invocation::      Invoking the @code{msgunfmt} Program
* MO Files::                 The Format of GNU MO Files

The Programmer's View



* catgets::                  About @code{catgets}
* gettext::                  About @code{gettext}
* Comparison::               Comparing the two interfaces
* Using libintl.a::          Using libintl.a in own programs
* gettext grok::             Being a @code{gettext} grok
* Temp Programmers::         Temporary Notes for the Programmers Chapter

About @code{catgets}



* Interface to catgets::     The interface
* Problems with catgets::    Problems with the @code{catgets} interface?!

About @code{gettext}



* Interface to gettext::     The interface
* Ambiguities::              Solving ambiguities
* Locating Catalogs::        Locating message catalog files
* Charset conversion::       How to request conversion to Unicode
* Contexts::                 Solving ambiguities in GUI programs
* Plural forms::             Additional functions for handling plurals
* Optimized gettext::        Optimization of the *gettext functions

Temporary Notes for the Programmers Chapter



* Temp Implementations::     Temporary - Two Possible Implementations
* Temp catgets::             Temporary - About @code{catgets}
* Temp WSI::                 Temporary - Why a single implementation
* Temp Notes::               Temporary - Notes

The Translator's View



* Trans Intro 0::            Introduction 0
* Trans Intro 1::            Introduction 1
* Discussions::              Discussions
* Organization::             Organization
* Information Flow::         Information Flow
* Translating plural forms::  How to fill in @code{msgstr[0]}, 
                                @code{msgstr[1]}
* Prioritizing messages::    How to find which messages to translate first

Organization



* Central Coordination::     Central Coordination
* National Teams::           National Teams
* Mailing Lists::            Mailing Lists

National Teams



* Sub-Cultures::             Sub-Cultures
* Organizational Ideas::     Organizational Ideas

The Maintainer's View



* Flat and Non-Flat::        Flat or Non-Flat Directory Structures
* Prerequisites::            Prerequisite Works
* gettextize Invocation::    Invoking the @code{gettextize} Program
* Adjusting Files::          Files You Must Create or Alter
* autoconf macros::          Autoconf macros for use in @file{configure.ac}
* Version Control Issues::   
* Release Management::       Creating a Distribution Tarball

Files You Must Create or Alter



* po/POTFILES.in::           @file{POTFILES.in} in @file{po/}
* po/LINGUAS::               @file{LINGUAS} in @file{po/}
* po/Makevars::              @file{Makevars} in @file{po/}
* po/Rules-*::               Extending @file{Makefile} in @file{po/}
* configure.ac::             @file{configure.ac} at top level
* config.guess::             @file{config.guess}, @file{config.sub} at top 
                               level
* mkinstalldirs::            @file{mkinstalldirs} at top level
* aclocal::                  @file{aclocal.m4} at top level
* config.h.in::              @file{config.h.in} at top level
* Makefile::                 @file{Makefile.in} at top level
* src/Makefile::             @file{Makefile.in} in @file{src/}
* lib/gettext.h::            @file{gettext.h} in @file{lib/}

Autoconf macros for use in @file{configure.ac}



* AM_GNU_GETTEXT::           AM_GNU_GETTEXT in @file{gettext.m4}
* AM_GNU_GETTEXT_VERSION::   AM_GNU_GETTEXT_VERSION in @file{gettext.m4}
* AM_GNU_GETTEXT_NEED::      AM_GNU_GETTEXT_NEED in @file{gettext.m4}
* AM_PO_SUBDIRS::            AM_PO_SUBDIRS in @file{po.m4}
* AM_XGETTEXT_OPTION::       AM_XGETTEXT_OPTION in @file{po.m4}
* AM_ICONV::                 AM_ICONV in @file{iconv.m4}

Integrating with Version Control Systems



* Distributed Development::  Avoiding version mismatch in distributed 
                               development
* Files under Version Control::  Files to put under version control
* Translations under Version Control::  Put PO Files under Version Control
* autopoint Invocation::     Invoking the @code{autopoint} Program

Other Programming Languages



* Language Implementors::    The Language Implementor's View
* Programmers for other Languages::  The Programmer's View
* Translators for other Languages::  The Translator's View
* Maintainers for other Languages::  The Maintainer's View
* List of Programming Languages::  Individual Programming Languages

The Translator's View



* c-format::                 C Format Strings
* objc-format::              Objective C Format Strings
* sh-format::                Shell Format Strings
* python-format::            Python Format Strings
* lisp-format::              Lisp Format Strings
* elisp-format::             Emacs Lisp Format Strings
* librep-format::            librep Format Strings
* scheme-format::            Scheme Format Strings
* smalltalk-format::         Smalltalk Format Strings
* java-format::              Java Format Strings
* csharp-format::            C# Format Strings
* awk-format::               awk Format Strings
* object-pascal-format::     Object Pascal Format Strings
* ycp-format::               YCP Format Strings
* tcl-format::               Tcl Format Strings
* perl-format::              Perl Format Strings
* php-format::               PHP Format Strings
* gcc-internal-format::      GCC internal Format Strings
* gfc-internal-format::      GFC internal Format Strings
* qt-format::                Qt Format Strings
* qt-plural-format::         Qt Plural Format Strings
* kde-format::               KDE Format Strings
* boost-format::             Boost Format Strings
* lua-format::               Lua Format Strings
* javascript-format::        JavaScript Format Strings

Individual Programming Languages



* C::                        C, C++, Objective C
* sh::                       sh - Shell Script
* bash::                     bash - Bourne-Again Shell Script
* Python::                   Python
* Common Lisp::              GNU clisp - Common Lisp
* clisp C::                  GNU clisp C sources
* Emacs Lisp::               Emacs Lisp
* librep::                   librep
* Scheme::                   GNU guile - Scheme
* Smalltalk::                GNU Smalltalk
* Java::                     Java
* C#::                       C#
* gawk::                     GNU awk
* Pascal::                   Pascal - Free Pascal Compiler
* wxWidgets::                wxWidgets library
* YCP::                      YCP - YaST2 scripting language
* Tcl::                      Tcl - Tk's scripting language
* Perl::                     Perl
* PHP::                      PHP Hypertext Preprocessor
* Pike::                     Pike
* GCC-source::               GNU Compiler Collection sources
* Lua::                      Lua
* JavaScript::               JavaScript
* Vala::                     Vala

sh - Shell Script



* Preparing Shell Scripts::  Preparing Shell Scripts for 
                               Internationalization
* gettext.sh::               Contents of @code{gettext.sh}
* gettext Invocation::       Invoking the @code{gettext} program
* ngettext Invocation::      Invoking the @code{ngettext} program
* envsubst Invocation::      Invoking the @code{envsubst} program
* eval_gettext Invocation::  Invoking the @code{eval_gettext} function
* eval_ngettext Invocation::  Invoking the @code{eval_ngettext} function
* eval_pgettext Invocation::  Invoking the @code{eval_pgettext} function
* eval_npgettext Invocation::  Invoking the @code{eval_npgettext} function

Perl



* General Problems::         General Problems Parsing Perl Code
* Default Keywords::         Which Keywords Will xgettext Look For?
* Special Keywords::         How to Extract Hash Keys
* Quote-like Expressions::   What are Strings And Quote-like Expressions?
* Interpolation I::          Invalid String Interpolation
* Interpolation II::         Valid String Interpolation
* Parentheses::              When To Use Parentheses
* Long Lines::               How To Grok with Long Lines
* Perl Pitfalls::            Bugs, Pitfalls, and Things That Do Not Work

Other Data Formats



* Internationalizable Data::  Internationalizable Data Formats
* Localized Data::           Localized Data Formats

Internationalizable Data Formats



* POT::                      POT - Portable Object Template
* RST::                      Resource String Table
* Glade::                    Glade - GNOME user interface description
* GSettings::                GSettings - GNOME user configuration schema
* AppData::                  AppData - freedesktop.org application 
                               description
* Preparing ITS Rules::      Preparing Rules for XML Internationalization

Localized Data Formats



* Editable Message Catalogs::  Editable Message Catalogs
* Compiled Message Catalogs::  Compiled Message Catalogs
* Desktop Entry::            Desktop Entry files
* XML::                      XML files

Editable Message Catalogs



* PO::                       PO - Portable Object
* Java .properties::         Java .properties
* GNUstep .strings::         NeXTstep/GNUstep .strings

Compiled Message Catalogs



* MO::                       MO - Machine Object
* Java ResourceBundle::      Java ResourceBundle
* C# Satellite Assembly::    C# Satellite Assembly
* C# Resource::              C# Resource
* Tcl message catalog::      Tcl message catalog
* Qt message catalog::       Qt message catalog

Concluding Remarks



* History::                  History of GNU @code{gettext}
* The original ABOUT-NLS::   Historical introduction
* References::               Related Readings

Language Codes



* Usual Language Codes::     Two-letter ISO 639 language codes
* Rare Language Codes::      Three-letter ISO 639 language codes

Licenses



* GNU GPL::                  GNU General Public License
* GNU LGPL::                 GNU Lesser General Public License
* GNU FDL::                  GNU Free Documentation License

@end detailmenu
@end menu

@end ifnottex

@node Introduction
@chapter イントロダクション

このチャプターでは、GNU
@code{gettext}が作られた目的と、フリーの翻訳プロジェクトについて説明します。それから、ネイティブ言語サポート(NLS: Native
Language
Support)にまつわる広義の概念をいくつか説明します。また国や文化の差異を他の側面から考慮した際に、翻訳したメッセージをプログラムに適用することが、どのような位置づけになるかを説明します。さらに翻訳に使用されるファイルを説明し、最初の翻訳において様々なツールがそれらのファイルをどのように生成、相互作用するのか、そして通常のメンテナンスサイクルにおいてどのように処理されるかについて説明します。

@cindex sex
@cindex he, she, and they
@cindex she, he, and they
このマニュアルでは、プログラマーやメンテナーを指すときには@emph{彼}という言葉を使用します。そして翻訳者を指すときは@emph{彼女}、翻訳されたプログラムをインストールする人やエンドユーザーのことを指すときは@emph{彼ら}という言葉を使用します。これの目的はドキュメントを明解にするのが唯一の目的であり、決して各々の役割が男性、もしくは女性に適しているという意味では@emph{まったく}ありません。あなたが想像するように、GNU
@code{gettext}は性別、人種、宗教、国籍に関わらず、コンピュータを使用する人にとって有用なものなのです!

@cindex bug report address
提案や訂正は下記にメールしてください:

@example
@group
@r{Internet address:}
    bug-gnu-gettext@@gnu.org
@end group
@end example

@noindent
メールのメッセージに、マニュアルのバージョン番号と更新日付を記入してください。

@menu
* Why::                      The Purpose of GNU @code{gettext}
* Concepts::                 I18n, L10n, and Such
* Aspects::                  Aspects in Native Language Support
* Files::                    Files Conveying Translations
* Overview::                 Overview of GNU @code{gettext}
@end menu

@node Why
@section GNU @code{gettext}の目的

プログラムは通常、英語でドキュメントされており、実行時にユーザーと相互作用する場合にも英語が使用されます。これはGNUソフトウェアに限らず、多くのフリーソフトウェアにも当てはまる話です。開発者やメンテナー、すべての国々のユーザー同士でコミュニケーションする場合、共通の言語を使用するほうが便利です。一方、ほとんどの人は英語より自分の母国語を好み、日々の仕事にも可能な限り母国語を使用しています。単純に言うと、ほとんどの人は英語より母国語がコンピューターのスクリーンに表示されるのを@emph{愛する}のです。

@cindex Translation Project
しかし多くの人にとって、これは時間をかけて考える価値がないと片付けてしまう夢かもしれません。彼らは結局、この夢を実現できる自信がないのです。しかし希望を失わずに、組織を作った人たちもいます。この翻訳プロジェクトは、これらの希望を作業可能な形に形式化して、私たちのすべてが真の多言語機能を兼ね揃えたプログラムと呼べるものを手にするチャンスなのです。

GNU
@code{gettext}は、他の多くのステップを構築する資産であり、翻訳プロジェクトにとって重要なステップです。このパッケージは、プログラマー、翻訳者、そしてユーザーにたいして、統合されたツールとドキュメントを提供します。特に
GNU
@code{gettext}ユーティリティーは、他のパッケージに多言語化されたメッセージを生成するためのフレームワークを提供するツール群です。このツールには以下のものが含まれます:

@itemize @bullet
@item
メッセージカタログをサポートするために、プログラムをどのように記述すべきかの規則。

@item
メッセージカタログのディレクトリーやファイル名の命名方式。

@item
翻訳されたメッセージの取得をサポートする実行時ライブラリー。

@item
翻訳可能なメッセージや、既に翻訳されたメッセージを取り扱うための、スタンドアローンプログラム群。

@item
翻訳可能なメッセージが含まれたファイルの解析、生成をサポートするライブラリー。

@item
これらのセットを準備して最新の状態に保つための、Emacs@footnote{このマニュアルでEmacsという言葉を使用するときは、FSF
Emacsとも呼ばれるGNU EmacsとXEmacs、そしてLucid Emacsを指します。}用のスペシャルモード。
@end itemize

GNU
@code{gettext}は、プログラムのソースを国際化する際の影響を最小化し、その影響を可能な限り小さく保つようにデザインされています。プログラムソースを見たときに、その影響が軽微、または少なくとも軽微に見えることにより、国際化が成功する可能性が高くなります。

翻訳プロジェクトは、翻訳プロジェクトの構造や手法を記述する手段としても、GNU
@code{gettext}ディストリビューションを使用しています。これは、この文書がGNU
@code{gettext}の技術面に限定して適切に記述された文書であることを超えるものであることを意味します。そうすることにより、翻訳者は翻訳作業を適切に行うために知る必要のあるすべてのことを、可能な限り単一の場所で見つけることができます。この補足的な文書により、プログラマーさらに好奇心のあるユーザーは、GNU
@code{gettext}が翻訳プロジェクト以外の場所とどのように関連しているかを理解し、@emph{大きな絵}を垣間見ることができます。

@node Concepts
@section i18n、l10n、などなど

@cindex i18n
@cindex l10n
プログラムによるネイティブ言語サポートを議論する際に、2つの長い単語が出現します。これらの単語には正確な意味づけがあり、このドキュメントでも使用する単語なので、ここで説明しておきましょう。使用される2つの長い単語とは、@emph{インターナショナリゼーション(internationalization)}と@emph{ローカリゼーション(localization)}です。これらの単語を何度も何度も書くうちに、多くの人たちが@dfn{i18n}や@dfn{l10n}と記述するようになりました。この表現は単語の最初と最後の文字と、それらの文字の間にある文字数によって、それぞれの単語を略記したものです。しかしこのマニュアルではわかりやすくするために、略記を用いずに正式な単語を使用することにします。

@cindex internationalization
@dfn{インターナショナリゼーション(国際化)}とは、プログラムやパッケージに含まれるプログラムのセットが多言語を認識しサポートする操作のことを指します。インターナショナリゼーションとは、英語の文字列でしかプログラムがを呼び出せないとか、英語以外の特定の言語の持つ習慣に縛られるといったことなく、同じ操作を一般的な方法で結びつけさせるための汎化のプロセスです。プログラムの開発者は、彼のプログラムをインターナショナライズするために様々なテクニックを使うことでしょう。それらのいくつかは標準化されています。そのうちの1つが
GNU @code{gettext}なのです。@ref{Programmers}を参照してください。

@cindex localization
@dfn{ローカリゼーション(地域化)}とは、それを行うことによりすでにインターナショナライズされた一連のプログラムが必要とするすべての情報を受けとることができ、任意のネイティブ言語や文化的な習慣に従った方法による入出力に適応させることができるような操作のことを意味します。ローカリゼーションとは、一般的なメソッドを実装済みのインターナショナライズされたプログラムを特定の方法で使用する、特化のプロセスです。プログラミング環境はプログラマーにたいして、実行時に設定できるいくつかの機能を提供します。翻訳対象の単位として同じネイティブ言語同士をまとめた、任意の国がもつ特定の文化的な習慣の形式的な説明を、その言語や国の@dfn{locale}と呼びます。ローカライズされたプログラムを使用するユーザーは、プログラムを実行する前にプログラムがどのlocaleを使用するべきかを、特定の環境変数に設定します。

実際にはlocaleメッセージのサポートとは、特定のlocaleを形成する文化的なデータの単一のコンポーネントのことです。インターナショナライズされたソフトウェアを開発するプログラマーを支援するために、特定のlocale
に保存されたデータにアクセスできるルーチンと関数を提供するライブラリーがあります。誰かが特定のlocaleを参照する場合には、特定のlocaleに保存されているデータを参照することになります。同様に、プログラマーが
``locale ルーチンへのアクセス'' を参照するということは、すべてのlocale情報にアクセスできる完全なルーチンの一式を参照するのと同じです。

@cindex NLS
@cindex Native Language Support
@cindex Natural Language Support
ネイティブ言語サポート(@dfn{Native Language
Support}、または単にNLS)という表現は、インターナショナリゼーションとローカリゼーションの両方により、プログラムが多言語と相互作用できる動作や機能の全体を指すときに使用します。一言で言うと、インターナショナリゼーションとはローカリゼーションを可能にする操作とも言えます。

大まかに言うと、多言語によるメッセージを処理する場合、インターナショナリゼーションはプログラマーによって処理され、ローカリゼーションは翻訳者によって処理されるとも言えます。

@node Aspects
@section ネイティブ言語サポートの側面

@cindex translation aspects
完全な多言語ディストリビューションを配付するためには、出力メッセージの翻訳以外に多くの事柄があります。

@itemize @bullet
@item
現在の GNU
@code{gettext}が提供するのは、Cプログラムが出力するメッセージを翻訳するための完全なツールセットです。しかしperlスクリプトとシェルスクリプトも同様に翻訳される必要があります。現在これらを翻訳するための方法があったとしても、本来あるべき形での統合はされていません。 

@item
@code{autoconf}や@code{bison}のような一部のプログラムは、他のプログラム(またはスクリプト)を生成することができます。たとえプログラムを生成するプログラムがインターナショナライズされていても、生成されたプログラムは独自にインターナショナリゼーションする必要がありますが、これらの間接的に行われるインターナショナリゼーションは生成プログラムで自動化できるはずです。しかし実際は生成するプログラムと生成されるプログラムは、それぞれ独自にインターナショナライズされるのが極めて一般的です。

@item
数は多くありませんが、プログラム自体に含まれた文字列とは別に、翻訳が必要となるテキストのテーブルを含むプログラムもあります。例えば@w{RFC
1345}は、@code{recode}プログラムが実行時に文字を再構築するための、文字に対応する説明的な英語名を提供します。これらの説明的な名前はRFCから機械的に取り出されるため、RFC自体を事前に翻訳する必要があります。

@item
大抵のプログラムにはオプションを指定することができますが、多くの場合は英語を読める人にたいして説明的なものが使用されています。このようプログラムのオプションについても、翻訳されたバージョンを提供することを考慮する必要があります。

@item
多くのプログラムは、本質的には翻訳可能な何かを、読み込み、解釈、コンパイルしたり、そのようなキーワードや識別子のテキストを含む入力ファイルによって何かを行ったり、応答を返したりします。例えば@code{gcc}に識別子の文字を区別できるようにさせたり、@samp{rm
-i}が@samp{y}や@samp{n}ではない、翻訳された応答をユーザーから受け取れるようにしたいと思うかもしれません。最終的にプログラムのほとんどの出力が他言語によるものだったとしても、入力の構文やオプションに指定できる値などを、ローカライズ可能かそうでないかを決定したいと思うかもしれません。

@item
パッケージに付随するマニュアル、及びディストリビューションのドキュメントファイルも同様に、翻訳される可能性があります。マニュアルの翻訳と、それ以降のアップデートは、一般的にはそれ自体が主要な作業です。

@end itemize

すでに述べたように、翻訳とはlocaleの1つの側面に過ぎません。インターナショナリゼーションの他の側面にはシステムのサービスがあり、これは GNU
@code{libc}により処理されます。国々の文化的な慣習を定義するための多くの属性があります。これらの属性には、国々のネイティブ言語に即した日付や、時刻書式と数値表記、通貨記号などが含まれます。これらの地域的な@dfn{ルール}は、その国のlocaleと呼ばれます。localeとは、その国のネイティブな属性をサポートするために必要となる知識を表します。

@cindex locale categories
国ごとの差異にしたがってlocaleを記述しなければならない、主要な領域がいくつかあります。以下のリストは、localeに関連したその他のタスクの適切なコンテキストにおいて、多言語メッセージを配置する手助けになるでしょう。詳細については
GNU @code{libc}のマニュアルを参照してください。

@table @emph

@item 文字とコードセット
@cindex codeset
@cindex encoding
@cindex character encoding
@cindex locale category, LC_CTYPE

米国や世界中の、英語を話す地域で最も一般的に使用されるコードセットは、ASCIIコードセットです。しかしこのコードセットには、様々なlocaleで必要とされる文字が含まれていません。8ビット
@w{ISO
8859-1}コードセットは主要なヨーロッパの言語で処理する必要がある特殊文字をほとんど持っているにもかかわらず、主要なヨーロッパの通貨を処理することができない等、多くの場合は@w{ISO
8859-1}を選択するだけでは十分ではないのです。したがってそれぞれのlocaleは、使用するコードセットの選択と、そしてそのコードセットに対処するための適切な文字列処理ルーチンが必要になります。

@item 通貨
@cindex currency symbols
@cindex locale category, LC_MONETARY

通貨記号は国ごとに異なり、それぞれの通貨記号の使用する位置も異なります。それぞれのlocaleにたいするネイティブモードで、ソフトウェアはそれを意識させずに通貨の数字を表示できる必要があります。

@item 日付
@cindex date format
@cindex locale category, LC_TIME

日付の書式はlocaleごとに異なります。例えば1994年のクリスマスは、米国では12/25/94と記述し、オーストラリアでは25/12/94、それ以外の国では@w{ISO
8601}の日付書式を使用する、といった具合です。

1日の中で使用される時刻も、@var{hh}:@var{mm}、@var{hh}.@var{mm}、などのように記述されます。あるlocaleでは時刻はAM/PMではなく、24時間制で指定する必要があります。しかも夏時間の補正は国ごとに大きく異なります。

@item 数値
@cindex number format
@cindex locale category, LC_NUMERIC

数値の表記はlocaleごとに異なります。以下はそれぞれのlocaleに対応する、正しい数値表記の例です:

@example
12,345.67       English
12.345,67       German
 12345,67       French
1,2345.67       Asia
@end example

メートル法とポンドヤード法のように異なる単位系を使用したり、それらの変種で数値表記する方法を採用しているプログラムもあります。

@item メッセージ
@cindex messages
@cindex locale category, LC_MESSAGES

localeによる言語サポートにおいて、最も明確な領域です。GNU
@code{gettext}は、localeでのメッセージのサポートという領域において、ソフトウェアがユーザーとコミュニケーションするときに使用する言語を、開発者とユーザーが簡単に変更する手段を提供します。

@end table

@cindex locale categories
これらの文化的な慣習の領域は、@emph{localeカテゴリー(locale
categories)}と呼ばれます。この用語は、@emph{localeの側面(locale
aspects)}や@emph{locale機能のカテゴリー(locale feature
categories)}といった用語よりも劣っているのが残念です。なぜならそれぞれの``localeカテゴリー''は、ローカリゼーションが要求される、ある領域やタスクについて記述するからです。そのような領域や特定の文化にたいして、文化的な慣習を説明する具体的なデータも@emph{localeカテゴリー}と呼ばれます。この意味では、localeとは、コードセットを定義するlocaleカテゴリー、数値の書式を定義するlocaleカテゴリー、翻訳されたメッセージを定義するlocaleカテゴリー、などのように、いくつかのlocaleカテゴリーから構成されているといえます。

@cindex Linux
メッセージ処理以外のlocaleコンポーネントは、標準ISO CとPOSIX:2001標準(SUSV3
specificationとも呼ばれる)です。GNU
@code{libc}はこれを完全に実装しており、その他の現代的なシステムも、欠けているコンポーネントにたいする、必要最小限のより実用的なサポートを提供しています。

@node Files
@section 翻訳を伝達するファイル

@cindex files, @file{.po} and @file{.mo}
@file{.po}ファイルのPOはPortable Objectの頭文字であり、@file{.mo}ファイルのMOはMachine
Objectの頭文字です。このパラダイムはPOファイルのフォーマットと同様に、Uniforumで開発されたNLS標準にもとづき、SunのSolarisシステムで実装されたものです。

POファイルは人間が読んだり編集することを意図しており、あるパッケージの特定のターゲット言語のための、翻訳可能なオリジナル文字列の集まりです。1つの言語にたいして、1つのPOファイルが割り当てられます。パッケージが複数の言語をサポートする場合、サポートする言語ごとにPOファイルを持ち、パッケージごとにパッケージがサポートする言語ごとのPOファイルを持っています。これらのPOファイルは@code{xgettext}プログラムによって作成され、アップデートや更新はmsgmergeプログラムによって行われます。@code{xgettext}プログラムはCファイルからマークされたメッセージを抽出し、空の翻訳文字列で初期化されたPOファイルを作成します。@code{msgmerge}プログラムは、リリースの間に変更されたソースファイルにたいして、不要なエントリーのコメント化や新しい文字列の初期化、および参照するソース行を更新したりします。この種のファイルは配布物中にの@file{.pot}という拡張子のファイルとして含まれ、書式はPOファイルと同じです。

MOファイルは、プログラムが読み込むことを意図した、バイナリーのフォーマットのファイルです。ネイティブ言語サポートの一部として、MOファイルを作成したり処理することのできる既存のシステムもいくつかありますが、MOファイルのフォーマットがシステムごとに異なっているため可搬性がありません。また、これらのシステムが提供する既存のツールは、GNU
@code{gettext}のすべての機能をサポートしていません。そのためGNU
@code{gettext}は、MOファイルに独自のフォーマットを使用しています。拡張子@file{.gmo}が実際のMOファイルで、これらのファイルはGNUのフォーマットを使用しています。

@node Overview
@section GNU @code{gettext}の概要

@cindex overview of @code{gettext}
@cindex big picture
@cindex tutorial of @code{gettext} usage
以下は、GNU
@code{gettext}で処理されるファイル群の関連と、それらを処理するツールをまとめたダイアグラムです。以降の詳細な説明は、このダイアグラムを見ながら読み進めてください。これらのファイルやツールの相互作用への明確な理解は、プログラマー、翻訳者、メンテナーにとって確実に役に立つものです。

@ifhtml
@example
@group
Original C Sources ───> Preparation ───> Marked C Sources ───╮
                                                             │
              ╭─────────<─── GNU gettext Library             │
╭─── make <───┤                                              │
│             ╰─────────<────────────────────┬───────────────╯
│                                            │
│   ╭─────<─── PACKAGE.pot <─── xgettext <───╯   ╭───<─── PO Compendium
│   │                                            │              ↑
│   │                                            ╰───╮          │
│   ╰───╮                                            ├───> PO editor ───╮
│       ├────> msgmerge ──────> LANG.po ────>────────╯                  │
│   ╭───╯                                                               │
│   │                                                                   │
│   ╰─────────────<───────────────╮                                     │
│                                 ├─── New LANG.po <────────────────────╯
│   ╭─── LANG.gmo <─── msgfmt <───╯
│   │
│   ╰───> install ───> /.../LANG/PACKAGE.mo ───╮
│                                              ├───> "Hello world!"
╰───────> install ───> /.../bin/PROGRAM ───────╯
@end group
@end example
@end ifhtml
@ifnothtml
@example
@group
Original C Sources ---> Preparation ---> Marked C Sources ---.
                                                             |
              .---------<--- GNU gettext Library             |
.--- make <---+                                              |
|             `---------<--------------------+---------------'
|                                            |
|   .-----<--- PACKAGE.pot <--- xgettext <---'   .---<--- PO Compendium
|   |                                            |              ^
|   |                                            `---.          |
|   `---.                                            +---> PO editor ---.
|       +----> msgmerge ------> LANG.po ---->--------'                  |
|   .---'                                                               |
|   |                                                                   |
|   `-------------<---------------.                                     |
|                                 +--- New LANG.po <--------------------'
|   .--- LANG.gmo <--- msgfmt <---'
|   |
|   `---> install ---> /.../LANG/PACKAGE.mo ---.
|                                              +---> "Hello world!"
`-------> install ---> /.../bin/PROGRAM -------'
@end group
@end example
@end ifnothtml

@cindex marking translatable strings
プログラマーが自分のパッケージにGNU
@code{gettext}を導入するときに最初に行うことは、Cソース中のどの文字列が翻訳可能で、どの文字列が翻訳不可かを識別することです。この退屈な作業は、emacsのPO
modeを使用することにより多少は快適になりますが、Cソースを編集するのに、あなた自身が慣れ親しんだものを使用することもできます。その他に必要となる標準的な変更としては、翻訳用のライブラリーを正しく初期化することなどです。これらに関する詳細は@ref{Sources}を参照してください。

新しく記述するソフトウェアについては、ソフトウェアを記述するときにそのような文字列をマークできますし、そうするべきでしょう。このような文字列にたいする@code{gettext}のアプローチ方法としては、手始めに各ファイルの先頭または中心的なヘッダーファイルに、以下の行を追加するという、非常に簡単なものです:

@example
@group
#define _(String) (String)
#define N_(String) String
#define textdomain(Domain)
#define bindtextdomain(Package, Directory)
@end group
@end example

@noindent
これで、インターナショナリゼーションのためのソースの準備ができました。後で実際に@code{gettext}を使う準備ができたら、これらを以下の定義で置き換えてください:

@cindex include file @file{libintl.h}
@example
@group
#include <libintl.h>
#define _(String) gettext (String)
#define gettext_noop(String) String
#define N_(String) gettext_noop (String)
@end group
@end example

@cindex link with @file{libintl}
@cindex Linux
@noindent
@file{libintl.a}と@file{libintl.so}にリンクする必要もあります。GNUシステムでは、@code{gettext}ライブラリーの関数はGNU
libcにすでに含まれているので、@code{libintl}にリンクする必要がないことに注意してください。

@cindex template PO file
@cindex files, @file{.pot}
一度Cソースが変更されると、翻訳可能なすべての文字列を検索、抽出してPO
templateファイルに出力するのに、@code{xgettext}が使用されます。この@file{@var{package}.pot}ファイルには、オリジナルのプログラムのすべての文字列が含まれています。これらの文字列は、その文字列がCソース中で使用されている場所へのポインターを持っており、すべての翻訳文字列は空文字列に初期化されています。@file{.pot}の@code{t}という文字は、このファイルがテンプレート(Template)のPOファイルであり、まだ特定の言語用ではないことを示します。どのように@code{xgettext}プログラムが呼び出されるかについては、@ref{xgettext
Invocation}を参照してください。もしあなたが@emph{本当}に怠け者の場合、少し手間をかけてディストリビューション全体をセットアップするのに興味があるかもしれません(@ref{Maintainers}を参照してください)。この方法では、@code{xgettext}コマンドをタイプするのを省略して@code{make}とタイプするだけで、自動的に適切なものを生成することができます。

最初はまだ@file{@var{lang}.po}がないので、@code{msgmerge}のステップはとばして、単に@file{@var{package}.pot}が@file{@var{lang}.po}としてコピーされます。ここで@var{lang}は対象となる言語です。詳細については、@ref{Creating}を参照してください。

次はメッセージの最初の翻訳です。翻訳それ自身が全体として今だ人手に頼らねばならないものであり、その複雑さはこのマニュアルの取り扱う範囲を超えるものです。翻訳チームに連絡したり、チームの一員になって、同じネイティブ言語を作業対象とする他の人たちとあなたの翻訳を共有する方法等、いくつかのヒントについては、このマニュアルの他のチャプターで触れています(@ref{Translators}を参照してください)。

POファイル@file{@var{lang}.po}に翻訳したメッセージを追加するときに、POファイル編集用のエディター(@ref{Editing}を参照してください)を使用していない場合は、POファイルのフォーマットに合わせて作業したり、文字列を引用符で括る規則など(@ref{PO
Files}を参照してください)について自分で気を遣わなければなりません。これは不可能な作業ではなく、実際に1995年頃には多くの人がPOファイルを取り扱っていた方法です。一方、POファイルエディターは、POファイルエディター自身の使い方を覚える必要はありますが、あなたにかわってエディターがPOファイルに関する詳細を取り扱ってくれます。

既に何らかの翻訳がCompendium
POファイルに保存されている場合、翻訳者はPOモードを使って翻訳されていないエントリーをCompendiumから初期化したり、翻訳を選択してCompendiumに保存したり更新することができます(@ref{Compendium}を参照してください)。Compendiumファイルは、翻訳チームのメンバー間で共有するように意図されたものです。

プログラムやプログラムのパッケージは、ユーザーがバグ報告や改良のための提案をして、メンテナーが様々な方法でプログラムを変更して対応するという、動的な性質を持ちます。パッケージがすでにインターナショナライズされているという事実により、メンテナーがパッケージに文字列を追加したり、すでに翻訳された文字列を変更することをためらうようにさせるべきではありません。彼らは、彼ら自身がスムーズに作業できるようにベストを尽くすだけです。メンテナーはすでに負荷の掛かった双肩に、翻訳に関する心配事を背負いこまなないようにしてください。そして翻訳者はプログラミングの心配事からは自由でいるようにしてください。

メンテナーが心配すべきなのは、文字列が翻訳されるべきときに翻訳可能であるように文字列をマークすることであり、文字列がいつ翻訳されるかについては、適切な時がくれば翻訳されるものだと割り切るべきです。@code{xgettext}は、時間をかけて進化してきた@file{@var{package}.pot}を再び構築し、その結果、翻訳を含んだ@file{@var{lang}.po}は徐々に古くなっていきます。

@cindex evolution of packages
翻訳者(そしてメンテナー)にとって重要なのは、パッケージの翻訳はパッケージが誕生した時に1度行えばよいというものではなく、パッケージの生涯において繰り替えされる継続的なプロセスだと理解することです。あるパッケージにたいして最初の翻訳を行った後、時々手入れをすることが必要です。なぜなら翻訳が必要な新しい未翻訳の文字列が出現することにより、翻訳された文字列があちこちで古くなっていくからです。

@code{msgmerge}プログラムは、すでに存在する@file{@var{lang}.po}ファイルを、@code{xgettext}で最新の C
ソースから抽出された、より新しい@file{@var{package}.pot}テンプレートファイルと比較して更新するという目的を持っています。更新の処理はプログラムの変更により変更された、Cソース中の文字列の位置にたいする参照を調整します。同様に、@code{msgmerge}はすでに翻訳されているがプログラムのソースに存在しなくなった、古い翻訳のコメントアウトも行います(@ref{Obsolete
Entries}を参照してください)。そして最後に新しい文字列を未翻訳の文字列として、結果であるPOファイルに挿入します(@ref{Untranslated
Entries}を参照してください)。msgmergeが実際に何を行うかについては、@ref{msgmerge
Invocation}を参照してください。

目的に至る経路と手段が何であれ、翻訳のためのすべての文字列を提供する更新された@file{@var{lang}.po}がゴールなのです。

POファイルが変動し流動する一時的なものであるという性質は、翻訳というゲームでの不可欠な部分であり、よく理解して受け入れる必要があります。翻訳プロジェクトに参加する人はこの性質に苦労し、他の翻訳プロジェクトのメンバーに苦労をかけることもあるのです!
特にメンテナーは、たとえ最近は更新されていないディストリビューションでも、翻訳チームに早く仕事を終えるようにプレッシャーを与えず、リラックスして利用可能でオフィシャルなすべてのPOファイルをディストリビューションに含めましょう。プレッシャーを与えるのはむしろ、特定の言語を話すコミュニティーのユーザーなので、メンテナー自身も安心して翻訳ファイルの妥当性を考慮するべきです。一方翻訳者は、パッケージがオフィシャルのディストリビューションに向けた事前テストを行っているときに、自分が担当するPOファイルを合理的に更新する事を試みる必要があります。

1度POファイルが完成して信頼できる物になると、POファイルは@code{msgfmt}プログラムによって、パッケージのプログラムが実行時に必要な時はいつでも効率的に翻訳を取得できるよう、マシン向けのフォーマットに変換されます(@ref{MO
Files}を参照してください)。@code{msgfmt}プログラムのすべての実行モードについては、@ref{msgfmt
Invocation}を参照してください。

最後に、変更およびマークされたCソースがコンパイルされて、GNU
@code{gettext}ライブラリーとリンクされます。これは通常、プロジェクトのための適切な@file{Makefile}と共に、@code{make}コマンドを実行することにより行われ、結果としてユーザーが見つけることのできる場所に実行可能ファイルがインストールされます。MOファイル自身も適切にインストールされる必要があります。これで適切な環境変数(@ref{Setting
the POSIX Locale}を参照してください)をセットすると、プログラムを実行すればいつでも自分で自動的にローカライズするようになります。

このマニュアルの残りの部分では、上述の様々なステップを掘り下げて説明することを目的とします。

@node Users
@chapter ユーザーの視点

最近では、ユーザーがコンピューターにログインしたときには通常、プログラムがネイティブ言語でメッセージを表示するのを目にすることができます --
少なくともフリーソフトウェアやGNUプロジェクトに関わる人が少ないHindiやFilipinoなどの言語ではない、FrenchやGermanなどの言語による活発なフリーソフトウェアコミュニティーのユーザーは目にすることができるでしょう。

これはどのような仕組みで動くのでしょう? ユーザーはどのようにして、プログラムで使用する言語にたいして影響を与えることができるのでしょうか?
このチャプターではこれらの疑問にお答えします。

@menu
* System Installation::      Questions During Operating System Installation
* Setting the GUI Locale::   How to Specify the Locale Used by GUI Programs
* Setting the POSIX Locale::  How to Specify the Locale According to POSIX
* Installing Localizations::  How to Install Additional Translations
@end menu

@node System Installation
@section オペレーティングシステムのインストール

デフォルトで使用する言語は、すでにオペレーティングシステムのインストールの時点で決定されている場合があります。オペレーティングシステムがインストールされるときは通常、インストーラーがインストール中に使用する言語とは別に、インストールされるシステムで使用する言語を尋ねます。言語を1度しか尋ねないOSインストーラーもあります。

これにより、すべてのユーザーにたいする、システム全体でのデフォルト言語が決定されます。追加の言語としてデフォルト言語以外のローカリゼーションを指定できるインストーラーもあります。たとえばKDE(K
Desktop
Environment)のローカリゼーションやOpenOffice.orgは、言語ごとにインストールできるパッケージが個別にバンドルされています。

これはマシンの使用目的を考える、よい機会です。個人的に使用するマシンの場合、追加のローカリゼーションはおそらく必要ありません。国際的なつながりをもつ組織や企業で使用するマシンの場合、ゲストユーザーのことも考えられます。海外から1週間程度の予定でゲストを迎える場合、彼のお好みのlocaleは何でしょうか?
そのコストがディスクスペースを少し余分に消費するだけならば、あらかじめ追加のローカリゼーションをインストールする価値があるかもしれません。

システム全体のデフォルト言語は、新しいアカウントを作成するときのlocale設定で使用されます。しかしユーザーは同じマシンの他のユーザーとは異なる、自分自身のlocale設定を持つことができます。次のセクションで説明するようにユーザーは通常、最初のログイン後に自分のlocaleを指定することができます。

@node Setting the GUI Locale
@section GUIプログラムを使用したlocaleのセッティング

すぐに利用可能なプログラムは、``デスクトップ環境''とも呼ばれるユーザーのデスクトップで、それにはウィンドウマネージャーやウェブブラウザー、それにテキストエディターなどが含まれます。一般的なデスクトップとしてはKDE、GNOME、Xfceなどがあります。

デスクトップ環境のGUIプログラムで使用されるlocaleは、``control center''、``language
settings''、``country settings''などと呼ばれる設定画面で指定できます。

デスクトップ環境に属さない個別のGUIプログラムは、設定パネルや環境変数を通じて、自身のlocaleを持つことができます。

環境変数を通じてlocaleを指定できるプログラムには、デスクトップのlocaleとは異なるlocaleを指定できるものもあります。これはプログラムをメニューやファイルシステムから起動するかわりに、コマンドラインから環境変数を指定した後にプログラムを起動するということです。環境変数の設定については、次のセクション(@ref{Setting
the POSIX
Locale})で説明します。ただしKDEのあるバージョンでは、localeを@code{LANG}や@code{LC_ALL}ではなく@code{KDE_LANG}で設定します。

@node Setting the POSIX Locale
@section 環境変数を通じたlocaleのセッティング

もっとも単純なケースは、あなたの言語がこのパッケージにしたがってインストールされている場合で、環境変数@code{LANG}に適切な@samp{@var{ll}_@var{CC}}の組み合わせを指定するだけです。たとえばあなたがGermanyに住んでいてGermanを話すとしましょう。この場合はシェルプロンプトで単に、@w{@samp{setenv
LANG de_DE}}(@code{csh}の場合)、@w{@samp{export
LANG=de_DE}}(@code{sh}の場合)、@w{@samp{export
LANG=de_DE}}(@code{bash}の場合)と実行します。1度これを@file{.login}や@file{.profile}に記述しておけば、毎回適用することができます。

@menu
* Locale Names::             How a Locale Specification Looks Like
* Locale Environment Variables::  Which Environment Variable Specfies What
* The LANGUAGE variable::    How to Specify a Priority List of Languages
@end menu

@node Locale Names
@subsection locale名

localeの名前は通常、@samp{@var{ll}_@var{CC}}という形式で表されます。ここで@samp{@var{ll}}は@w{ISO
639}による2文字の言語コード、@samp{@var{CC}}は@w{ISO
3166}による国コードを記述します。たとえば国がGermany、言語がGermanの場合、@var{ll}は@code{de}、@var{CC}は@code{DE}となります。言語コードと国コードについては、付表@ref{Language
Codes}と付表@ref{Country Codes}を参照してください。

国コードも指定するのは冗長だと思うかもしれません。しかし、実際にいくつかの言語は国ごとに方言をもつものがあります。たとえば、@samp{de_AT}はAustria、@samp{pt_BR}はBrazilで使用されます。国コードはこの様な方言を区別するのに役立つのです。

多くのlocale名は@samp{@var{ll}_@var{CC}.@var{encoding}}という拡張形式で文字のエンコーディングを指定できます。これは多くのユーザーが2000年から2005年にかけてUTF-8に移行したためです。たとえば現在のglibcシステムのGerman
localeは@samp{de_DE.UTF-8}です。@samp{de_DE}という古いlocale名は、2000年時点で使用されていたISO-8859-1(ユーロ通貨記号を持たない)が格納された文字列を参照するのに現在も使用されます。

@samp{@var{ll}_@var{CC}}のかわりに、@samp{@var{ll}_@var{CC}@@@var{variant}}を使うlocale名もあります。@samp{@@@var{variant}}により、言語(@var{ll})と国(@var{CC})では提供できないような特性を示すことができます。これにより特定の通貨単位を示すことができます。たとえばglibcシステムでは@samp{de_DE@@euro}は、2002年以前の通貨記号で使用されていた@samp{de_DE}ではなく、ユーロ通貨を使用するlocaleを示します。また、言語の方言や筆記に使用される方法(たとえば@samp{sr_RS@@latin}は、@samp{sr_RS}によりSerbianをCyrillicで筆記するのに、Latin筆記を使用することを示す)、正書法(orthography
rule)を使用するか、などを示すことができます。

その他のシステムでは、単に@samp{@var{ll}}と指定したりする等、このスキームの様々なバリエーションが使用されています。あなたの言語でサポートされているlocaleの一覧は、@samp{locale
-a | grep '^@var{ll}'}を実行して取得することができます。

@c Don't mention that this locale also has the name "POSIX". When we talk about
@c the "POSIX locale", we mean the "locale as specified in the POSIX way", and
@c mentioning a locale called "POSIX" would bring total confusion.
@samp{C}と呼ばれる特別なlocaleもあります。これはすべてのlocaleを無効にするときに使用します。このlocaleでは、すべてのプログラムがPOSIX標準で指定された英語のメッセージと、指定されていない不特定の文字(たいていはUS-ASCIIですが、オペレーティングシステムによってはISO-8859-1やUTF-8のときもあります)を使用します。

@node Locale Environment Variables
@subsection localeの環境変数
@cindex setting up @code{gettext} at run time
@cindex selecting message language
@cindex language selection

localeは複数の@emph{localeカテゴリー(locale
categories)}から構成されています(@ref{Aspects}を参照してください)。プログラムがlocaleに依存する値を参照する場合は、以下の環境変数を優先度順に参照します:

@enumerate
@vindex LANGUAGE@r{, environment variable}
@item @code{LANGUAGE}
@vindex LC_ALL@r{, environment variable}
@item @code{LC_ALL}
@vindex LC_CTYPE@r{, environment variable}
@vindex LC_NUMERIC@r{, environment variable}
@vindex LC_TIME@r{, environment variable}
@vindex LC_COLLATE@r{, environment variable}
@vindex LC_MONETARY@r{, environment variable}
@vindex LC_MESSAGES@r{, environment variable}
@item @code{LC_xxx}は、xxxに対応するlocaleカテゴリーです:
@code{LC_CTYPE}, @code{LC_NUMERIC}, @code{LC_TIME}, @code{LC_COLLATE},
@code{LC_MONETARY}, @code{LC_MESSAGES}, ...
@vindex LANG@r{, environment variable}
@item @code{LANG}
@end enumerate

変数に空の値がセットされている場合は、無視されます。

@code{LANG}はlocaleを指定するときに通常使われる環境変数で、通常はユーザーもこの変数にlocaleを設定します(他の変数がシステムにより設定されていなければ、@file{/etc/profile}またはそれに類する初期化ファイルで設定します)。

@code{LC_CTYPE}、@code{LC_NUMERIC}、@code{LC_TIME}、@code{LC_COLLATE}、@code{LC_MONETARY}、@code{LC_MESSAGES}等は、対応するlocaleのカテゴリーで@code{LANG}の設定をオーバーライドするときに使用されます。たとえば、あなたがSpainに住むSwedishのユーザーで、プログラムに数値や日付についてはSpanishの規則で表示し、メッセージだけをSwedishで表示させたいと仮定します。その場合には@code{localedef}プログラムで、@samp{sv_ES}または@samp{sv_ES.UTF-8}という名前のlocaleを作成する必要があります。しかし、単に@code{LANG}変数に@code{es_ES.UTF-8}を設定し、@code{LC_MESSAGES}変数に@code{sv_SE.UTF-8}という、オペレーティングシステムに事前にインストールされている2つのlocaleを設定することで、同じ効果を得ることができます。

@code{LC_ALL}は、これらのすべてをオーバーライドするための変数です。これは通常、特定のプログラムを実行するスクリプトで使用されます。たとえばGNU
autoconfにより生成された@code{LC_ALL}スクリプトは、configurationのテストがlocaleに依存した方法で行われないように、@code{LC_ALL}を使用します。

残念ながらいくつかのシステムでは、@file{/etc/profile}等の初期化ファイルで@code{LC_ALL}が設定されています。したがって@code{LANG}を設定する場合、ユーザーはまずこの設定を解除し、必要なら他の@code{LC_xxx}も解除しなければなりません。

@code{LANGUAGE}変数については、つぎのセクションで説明します。

@node The LANGUAGE variable
@subsection 言語の優先リストを指定する

すべてのプログラムが、すべての言語に翻訳されている訳ではありません。翻訳されたメッセージが存在しない場合、デフォルトでは英語のメッセージが表示されます。あなたが他の言語を理解できる場合は、言語の優先順位のリストを設定することができます。これは@code{LANGUAGE}と呼ばれる環境変数で行います。GNU
@code{gettext}はメッセージを処理するために、@code{LC_ALL}や@code{LANG}に加え、@code{LANGUAGE}による設定を提供します。しかし他のシステムライブラリーで必要となるため、@code{LANG}(または@code{LC_ALL})によるプライマリー言語の設定は、依然として必要です。たとえば、あるSwedishのユーザーは、Swedishの翻訳が存在しないとき、EnglishよりもGermanに翻訳されたものが読みたいとします。そのような場合は、@code{LANG}の値は@samp{sv_SE}のまま、@code{LANGUAGE}の値を@samp{sv:de}に設定します。

Norwegianのユーザーのためのアドバイス:
Norwegian言語(bokm@ringaccent{a}l)は最近(2003年)、@samp{no}から@samp{nb}に変更されました。移行期間中、いくつかのこの言語のメッセージカタログは、@samp{nb}と、古い@samp{no}にインストールされるので、Norwegianユーザーは新旧どちらの翻訳も使用できるように、@code{LANGUAGE}を@samp{nb:no}に設定することをお勧めします。

他の環境変数とは異なり、@code{LANGUAGE}環境変数では、@samp{@var{ll}_@var{CC}}を@samp{@var{ll}}と省略することにより、その言語で主に使用される方言であることを示します。この事情により、たとえば@samp{de}は@samp{de_DE}(Germanyで話されるGermany)、@samp{pt}は@samp{pt_PT}(Portugalで話されるPortuguese)と同義です。

注意:
@code{LANGUAGE}変数は、localeが@samp{C}に設定されている場合は無視されます。つまり、最初にローカリゼーションを利用可能にする時に、@code{LANGUAGE}変数で言語の優先順位リストを使用する前に、まず@code{LANG}(または@code{LC_ALL})
を@samp{C}以外に設定する必要があります。

@node Installing Localizations
@section 特定のプログラムにたいして翻訳をインストールする
@cindex Translation Matrix
@cindex available translations

GNU
@code{gettext}を使用するすべてのパッケージが、各言語にたいして同様のサポートを提供している訳ではなく、翻訳は時間をかけて個々に追加されます。パッケージをインストールした後は通常、オペレーティングシステムか個々のパッケージに同梱された翻訳を使用することになります。しかし新しいローカリゼーションを直接インストールすることもできます。これを行うには、ローカリゼーションの各ファイルがファイルシステム上でどのように保存されているかを理解する必要があります。

@cindex @file{ABOUT-NLS} file
翻訳プロジェクトに参加しているプログラムは、@url{https://translationproject.org/team/index.html}で見つけることができます。

KDEプロジェクトのプログラムを探す場合の出発点: @url{https://i18n.kde.org/}

GNOMEプロジェクトのプログラムを探す場合の出発点:  @url{https://wiki.gnome.org/TranslationProject}

他のプログラムに関しては、プログラムのソースコードパッケージに@file{@var{ll}.po}のようなファイルが含まれているかどうかでチェックすることができます(@file{po/}というディレクトリーに保存されているときもあります)。各@file{@var{ll}.po}には、@var{ll}で略記された言語の翻訳されたメッセージが含まれています。

@node PO Files
@chapter POファイルのフォーマット
@cindex PO files' format
@cindex file format, @file{.po}

GNU
@code{gettext}ツールセットは、プログラマーや翻訳者が翻訳のためのファイルを生成、更新、使用する手助けをし、それらのPOファイルは主としてテキスト形式で編集可能なファイルです。このチャプターでは、POファイルのフォーマットについて説明します。

POファイルは多くのエントリーから成り立っており、それぞれのエントリーには翻訳される前の原文の文字列と、それに対応する翻訳された文字列との関連が保持されています。あるPOファイルに含まれるすべてのエントリーは通常、ひとつのプロジェクトに関連し、翻訳されたすべての文字列もひとつの言語を対象に翻訳されたものです。一般的なPOファイルの@dfn{エントリー}は、以下のような構造を持ちます:

@example
@var{white-space}
#  @var{translator-comments}
#. @var{extracted-comments}
#: @var{reference}@dots{}
#, @var{flag}@dots{}
#| msgid @var{previous-untranslated-string}
msgid @var{untranslated-string}
msgstr @var{translated-string}
@end example

翻訳者は、POファイルの一般的な構造を十分に理解する必要があります。emacsのPOモードを使用すれば、フォーマットの詳細に関する最小限の知識を理解するだけで、あとはPOモードが彼女にかわって面倒を見てくれます。

以下は簡単なエントリの例です：

@example
#: lib/error.c:116
msgid "Unknown system error"
msgstr "Error desconegut del sistema"
@end example

@cindex comments, translator
@cindex comments, automatic
@cindex comments, extracted
エントリーは任意の個数の空白文字から開始することができます。GNU
@code{gettext}ツールで生成された場合、エントリーとエントリーの間には通常、1つの空行があります。@code{#}の文字で始まる行はすべてコメント行として扱われます。コメントには2種類のコメントがあります。1つ目は@var{translator
comments(翻訳者コメント)}で、@code{#}の直後にいくつかの空白文字があり、これらのコメントは翻訳者により保守、保守されます。2つ目のコメントは@var{automatic
comments(自動コメント)}で、これらのコメントはGNU
@code{gettext}ツールにより自動的に挿入、保守されるもので、@code{#}の直後に空白文字以外の文字があります。@code{#.}で始まるコメントはプログラマーによる翻訳者に向けたコメントを含んでいます。これらのコメントは@code{xgettext}プログラムによりプログラムのソースから抽出(extract)されるため、@var{extracted
comments(抽出コメント)}と呼ばれます。@code{#:}で始まるコメントには、プログラムのソースコードへの参照(references)が含まれます。@code{#,}で始まるコメントにはフラグ(flags)が含まれています。これらのフラグについては以下で説明します。@code{#|}で始まるコメントには、以前のバージョンの翻訳済みメッセージに対応する翻訳前の文字列(previous
untranslated string)が含まれています。

すべてのコメントは、オプションです。

@kwindex msgid
@kwindex msgstr
空白文字とコメントの後には、2つの文字列を表すための文字列があります。最初の文字列は翻訳前の文字列で、これらの文字列のオリジナルはプログラムのソース中に出現する文字列です。その次の文字列は、この翻訳前の文字列に対応する翻訳後の文字列です。オリジナルの文字列は@code{msgid}というキーワードで識別され、翻訳は@code{msgstr}というキーワードで識別されます。これらの翻訳前と翻訳後の2つの文字列は、POファイル中で@code{"}区切りや@code{\}エスケープにより、様々な方法で引用されていますが、文字列の引用などについてはPOモードが彼女にかわり面倒をすべて見てくれるので、翻訳者はそれらの正確な引用形式に注意を払う必要がなくなります。

msgidの文字列も自動生成されたコメントと同様、GNU
@code{gettext}の他のツールにより生成、管理されるので、POモードは翻訳者がそれらを変更するような操作を提供しません。それらの文字列にたいして彼女にできることは、単にそれを削除することだけで、しかもエントリー全体を削除できるだけです。一方、@code{msgstr}の文字列については、実際に翻訳者が編集するための翻訳者コメントなので、POモードは彼女の必要に応じて、完全な制御を提供します。

@code{#,}で始まるコメントは、一般的なコメントとは違いプログラムにより完全に無視されるものではないという点で、特別なコメントです。カンマで区切られた@var{flag}のリストは、ユーザーのためにより良い診断メッセージを提供するために、@code{msgfmt}プログラムにより使用されます。現時点では2つの形式のflagが定義されています:

@table @code
@item fuzzy
@kwindex fuzzy@r{ flag}
このフラグは@code{msgmerge}プログラムにより生成されるか、翻訳者自身により挿入され、@code{msgstr}の文字列が、(もはや)正しい翻訳ではないことを示します。翻訳をさらに修正する必要があるか、そのまま適用できるかは、翻訳者だけが判断できます。翻訳を完成したら、彼女は@code{fuzzy}属性を取り除きます。@code{msgmerge}は、あいまい検索(fuzzy
search)により@code{msgid}と@code{msgstr}エントリーを結びつけた場合のみ、このフラグを挿入します。@ref{Fuzzy
Entries}を参照してください。

@item c-format
@kwindex c-format@r{ flag}
@itemx no-c-format
@kwindex no-c-format@r{ flag}
これらは人間によって追加されるフラグではなく、@code{xgettext}プログラムだけが挿入するフラグです。ここで提案しているようなPOファイルを自動生成するシステムでは、ユーザーが変更を行っても、@code{xgettext}プログラムが新しいテンプレートファイルを生成するたびに、変更は上書きされてしまいます。

@code{c-format}フラグは、翻訳前の文字列と翻訳された文字列が、C形式の文字列であることを示します。@code{no-c-format}フラグは逆に、文字列が一見して(@samp{%}ディレクティブによる)C形式の文字列に見えても、C形式ではないことを示します。

文字列に@code{c-format}フラグが設定されていると、@code{msgfmt}プログラムは、翻訳にたいして妥当性チェックのテストを追加で行います。@ref{msgfmt
Invocation}、および@ref{c-format Flag}と@ref{c-format}を参照してください。

@item objc-format
@kwindex objc-format@r{ flag}
@itemx no-objc-format
@kwindex no-objc-format@r{ flag}
Objective Cの場合も同様です。@ref{objc-format}を参照してください。

@item sh-format
@kwindex sh-format@r{ flag}
@itemx no-sh-format
@kwindex no-sh-format@r{ flag}
shellの場合も同様です。@ref{sh-format}を参照してください。

@item python-format
@kwindex python-format@r{ flag}
@itemx no-python-format
@kwindex no-python-format@r{ flag}
Pythonの場合も同様です。@ref{python-format}を参照してください。

@item python-brace-format
@kwindex python-brace-format@r{ flag}
@itemx no-python-brace-format
@kwindex no-python-brace-format@r{ flag}
Python braceの場合も同様です。@ref{python-format}を参照してください。

@item lisp-format
@kwindex lisp-format@r{ flag}
@itemx no-lisp-format
@kwindex no-lisp-format@r{ flag}
Lispの場合も同様です。@ref{lisp-format}を参照してください。

@item elisp-format
@kwindex elisp-format@r{ flag}
@itemx no-elisp-format
@kwindex no-elisp-format@r{ flag}
Emacs Lispの場合も同様です。@ref{elisp-format}を参照してください。

@item librep-format
@kwindex librep-format@r{ flag}
@itemx no-librep-format
@kwindex no-librep-format@r{ flag}
librepの場合も同様です。@ref{librep-format}を参照してください。

@item scheme-format
@kwindex scheme-format@r{ flag}
@itemx no-scheme-format
@kwindex no-scheme-format@r{ flag}
Schemeの場合も同様です。@ref{scheme-format}を参照してください。

@item smalltalk-format
@kwindex smalltalk-format@r{ flag}
@itemx no-smalltalk-format
@kwindex no-smalltalk-format@r{ flag}
Smalltalkの場合も同様です。@ref{smalltalk-format}を参照してください。

@item java-format
@kwindex java-format@r{ flag}
@itemx no-java-format
@kwindex no-java-format@r{ flag}
Javaの場合も同様です。@ref{java-format}を参照してください。

@item csharp-format
@kwindex csharp-format@r{ flag}
@itemx no-csharp-format
@kwindex no-csharp-format@r{ flag}
C#の場合も同様です。@ref{csharp-format}を参照してください。

@item awk-format
@kwindex awk-format@r{ flag}
@itemx no-awk-format
@kwindex no-awk-format@r{ flag}
awkの場合も同様です。@ref{awk-format}を参照してください。

@item object-pascal-format
@kwindex object-pascal-format@r{ flag}
@itemx no-object-pascal-format
@kwindex no-object-pascal-format@r{ flag}
Object Pascalの場合も同様です。@ref{object-pascal-format}を参照してください。

@item ycp-format
@kwindex ycp-format@r{ flag}
@itemx no-ycp-format
@kwindex no-ycp-format@r{ flag}
YCPの場合も同様です。@ref{ycp-format}を参照してください。

@item tcl-format
@kwindex tcl-format@r{ flag}
@itemx no-tcl-format
@kwindex no-tcl-format@r{ flag}
Tclの場合も同様です。@ref{tcl-format}を参照してください。

@item perl-format
@kwindex perl-format@r{ flag}
@itemx no-perl-format
@kwindex no-perl-format@r{ flag}
Perlの場合も同様です。@ref{perl-format}を参照してください。

@item perl-brace-format
@kwindex perl-brace-format@r{ flag}
@itemx no-perl-brace-format
@kwindex no-perl-brace-format@r{ flag}
Perl braceの場合も同様です。@ref{perl-format}を参照してください。

@item php-format
@kwindex php-format@r{ flag}
@itemx no-php-format
@kwindex no-php-format@r{ flag}
PHPの場合も同様です。@ref{php-format}を参照してください。

@item gcc-internal-format
@kwindex gcc-internal-format@r{ flag}
@itemx no-gcc-internal-format
@kwindex no-gcc-internal-format@r{ flag}
GCCソースの場合も同様です。@ref{gcc-internal-format}を参照してください。

@item gfc-internal-format
@kwindex gfc-internal-format@r{ flag}
@itemx no-gfc-internal-format
@kwindex no-gfc-internal-format@r{ flag}
GNU Fortranコンパイラーのソースの場合も同様です。@ref{gfc-internal-format}を参照してください。

@item qt-format
@kwindex qt-format@r{ flag}
@itemx no-qt-format
@kwindex no-qt-format@r{ flag}
Qtの場合も同様です。@ref{qt-format}を参照してください。

@item qt-plural-format
@kwindex qt-plural-format@r{ flag}
@itemx no-qt-plural-format
@kwindex no-qt-plural-format@r{ flag}
Qt plural形式の場合も同様です。@ref{qt-plural-format}を参照してください。

@item kde-format
@kwindex kde-format@r{ flag}
@itemx no-kde-format
@kwindex no-kde-format@r{ flag}
KDEの場合も同様です。@ref{kde-format}を参照してください。

@item boost-format
@kwindex boost-format@r{ flag}
@itemx no-boost-format
@kwindex no-boost-format@r{ flag}
Boostの場合も同様です。@ref{boost-format}を参照してください。

@item lua-format
@kwindex lua-format@r{ flag}
@itemx no-lua-format
@kwindex no-lua-format@r{ flag}
Luaの場合も同様です。@ref{lua-format}を参照してください。

@item javascript-format
@kwindex javascript-format@r{ flag}
@itemx no-javascript-format
@kwindex no-javascript-format@r{ flag}
JavaScriptの場合も同様です。@ref{javascript-format}を参照してください。

@end table

@kwindex msgctxt
@cindex context, in PO files
以下のように、context specifier(コンテキスト指定子)をともなうエントリーも使用することができます:

@example
@var{white-space}
#  @var{translator-comments}
#. @var{extracted-comments}
#: @var{reference}@dots{}
#, @var{flag}@dots{}
#| msgctxt @var{previous-context}
#| msgid @var{previous-untranslated-string}
msgctxt @var{context}
msgid @var{untranslated-string}
msgstr @var{translated-string}
@end example

コンテキスト(context)は、同じ@var{untranslated-string}のあいまいさをなくすために提供されます。これによりPOファイルの中で、異なる@var{context}で、同じ@var{untranslated-string}を複数もつことが可能になります。@var{context}に空の文字列を指定するのと、@code{msgctxt}の行を指定しないのは、同じではないことに注意してください。

@kwindex msgid_plural
@cindex plural forms, in PO files
他にも、複数形式(plural form)を含む翻訳のために使用されるエントリーがあります。

@example
@var{white-space}
#  @var{translator-comments}
#. @var{extracted-comments}
#: @var{reference}@dots{}
#, @var{flag}@dots{}
#| msgid @var{previous-untranslated-string-singular}
#| msgid_plural @var{previous-untranslated-string-plural}
msgid @var{untranslated-string-singular}
msgid_plural @var{untranslated-string-plural}
msgstr[0] @var{translated-string-case-0}
...
msgstr[N] @var{translated-string-case-n}
@end example

以下はエントリーの例です:

@example
#: src/msgcmp.c:338 src/po-lex.c:699
#, c-format
msgid "found %d fatal error"
msgid_plural "found %d fatal errors"
msgstr[0] "s'ha trobat %d error fatal"
msgstr[1] "s'han trobat %d errors fatals"
@end example

@code{msgid}の前に、前述した@code{msgctxt}コンテキストを指定することもできます。

ここで追加のフラグを使用できます:

@table @code
@item range:
@kwindex range:@r{ flag}
このフラグは正の数値範囲をともない、@code{range:
@var{minimum-value}..@var{maximum-value}}という書式で使用します。この範囲には、メッセージが受けとることができる数値を指定します。たとえばある言語では、事前に値が0から10だとわかっていれば、よりよい翻訳を生成できます。
@end table

@var{previous-untranslated-string}は、@code{msgmerge}がメッセージをfuzzyとしてマークするとき同時にオプションとして挿入されます。これは開発者が、@var{untranslated-string}にたいしてどのような変更を行ったかを、翻訳者が知る助けになります。

これは、POファイルの最後のエントリーに続けて、何らかの行(通常は空白文字やコメント)があるときに発生します。これらの行は、どのエントリーの一部でもなく、POファイルがツールにより処理されるときに捨てられるか、POファイルエディターの動作を妨げるときもあります。

このチャプターの残りの部分は、POファイルの正確な書式にたいしてよいアイデアを持つ人は興味があるかもしれませんが、POファイルエディターを使用する場合はスキップして構いません。しかし、POファイルを手で変更したい場合は、注意して読む必要があります。

空の@var{untranslated-string}は、メタ情報が含まれたヘッダーエントリー(@ref{Header
Entry}を参照してください)のために予約されています。このヘッダーエントリーはファイルの最初のエントリーにすべきです。空の@var{untranslated-string}は、この目的のために予約されているので、他の場所で使用することはできません。

@var{untranslated-string}と@var{translated-string}はCの文法に従い、それには文字列の括り方やバックスラッシュによるエスケープシーケンスも含まれます。複数行のメッセージを記述するときは、エスケープされた改行文字を使用せずに、改行する行末の最後の文字で引用符を閉じて、POファイルの次の行で再び引用を開始します: 

@example
msgid ""
"Here is an example of how one might continue a very long string\n"
"for the common case the string represents multi-line output.\n"
@end example

@noindent
この例の最初の行には、@samp{for}の@code{f}という文字の上に@samp{Here}の@code{H}を揃えるために、空の文字列が使用されています。また、キーワード@code{msgid}の後ろには3つの文字列があり、それらの文字列は連結して使用されます。空の文字列と連結することにより文字列全体は変更されませんが、@code{msgid}の行に連結される文字列を、複数行の表示を維持しつつ左揃え表示して、配置を明確にさせるための方法です。空の文字列は省略できますがその場合、@code{msgid}の後ろに記述する最初の行は@samp{Here}で開始しなければなりません@footnote{これは
GNU
@code{gettext}の制限ではなく、Solarisの@code{msgfmt}との互換性による制限です。}。それぞれの文字列の括りの終端を改行(@samp{\n})の直後にしている理由は、そうしても支障がないからというだけで、@emph{任意の}文字の後で括りを終端して構いません。

@cindex POファイルでの改行
文字列の括りの@emph{内側}にある、行末を示す@samp{\n}は文字列の一部で、文字列の括りの外側の改行はPOファイル自身の行末を示し、文字列に影響を与えない点に注意してください。

@cindex comments in PO files
文字列の外側では、空白文字とコメントを自由に使うことができます。行頭の@samp{#}から、その行の行末までがコメントとなります。翻訳者が記入するコメントは@samp{#}の後ろに空白文字をいくつか記述する必要があります。@samp{#}の後ろに空白文字がない場合、それは特定のGNUツールで生成・管理されるコメントとみなされ、POファイルが@code{msgmerge}で処理されるとき、予期せず削除される可能性があります。

@node Sources
@chapter プログラムソースの準備
@cindex preparing programs for translation

@c FIXME: Rewrite (the whole chapter).

プログラマーのために、Cのソースコードの変更を3つにカテゴリーに分けます。1番目は、ローカリゼーション関数にメッセージ翻訳を必要とするすべてのモジュールを教えることです。2番目は、プログラムの初期化(通常はmain関数の内部)で、GNU
@code{gettext}の操作を的確にトリガーすることです。3番目に、翻訳が必要なプログラム内のすべての文字列定数を識別・調整・マークする必要があります。

@menu
* Importing::                Importing the @code{gettext} declaration
* Triggering::               Triggering @code{gettext} Operations
* Preparing Strings::        Preparing Translatable Strings
* Mark Keywords::            How Marks Appear in Sources
* Marking::                  Marking Translatable Strings
* c-format Flag::            Telling something about the following string
* Special cases::            Special Cases of Translatable Strings
* Bug Report Address::       Letting Users Report Translation Bugs
* Names::                    Marking Proper Names for Translation
* Libraries::                Preparing Library Sources
@end menu

@node Importing
@section @code{gettext}宣言のインポート

GNU
@code{gettext}が必要とするすべてのファイルが利用可能で、@file{Makefile}ファイルも調整済み(@ref{Maintainers}を参照してください)だとすると、翻訳対象の文字列を含むCモジュールには以下の行を含める必要があります:

@cindex include file @file{libintl.h}
@example
#include <libintl.h>
@end example

翻訳可能なCの書式指定文字列(他のCモジュールで文字列が定義されている場合も含まれます)を引数として呼び出される、@code{printf()}/@code{fprintf()}/...を含むCモジュールにも以下の行を含める必要があります:

@example
#include <libintl.h>
@end example

@node Triggering
@section @code{gettext}処理のトリガー

@cindex initialization
すべてのプログラムで、以下で示すようなlocaleデータの初期化の類が必要となります:

@example
@group
int
main (int argc, char *argv[])
@{
  @dots{}
  setlocale (LC_ALL, "");
  bindtextdomain (PACKAGE, LOCALEDIR);
  textdomain (PACKAGE);
  @dots{}
@}
@end group
@end example

@var{PACKAGE}と@var{LOCALEDIR}は、@file{config.h}かMakefileで提供される必要があります。詳細については、@code{gettext}やGNU
@code{hello}のソースを眺めてみるとよいでしょう。

@cindex locale category, LC_ALL
@cindex locale category, LC_CTYPE
この場合、@code{LC_ALL}の使用は適切ではないでしょう。LC_ALL@code{LC_ALL}にはすべてのlocaleカテゴリー、特に@code{LC_CTYPE}が含まれます。この後者のカテゴリーは、プログラムのために@file{ctype.h}で定義されている、@code{isalnum}関数などで処理する文字列クラスを決定することに責任をもっており、入力される文字列の言語によってはうまく動作しません。たとえばソースコードで@,{c}(c-cedilla文字)が使用されている場合、このプログラムはFranceでは問題ありませんがU.S.では動作しません。

@code{LC_ALL}というlocaleカテゴリーに他のlocaleが使用された場合、@code{scanf}関数による数字の解析に問題が生じるシステムもあります。標準では、このような場合は@code{"C"}というlocaleとして知られる追加の書式が認識されるでしょう。しかし@code{"C"}というlocaleの書式では、数値を受け付けないシステムもあるようです。状況によっては数値の表示が@code{"C"}というlocaleなのか、それともlocalのフォーマットかにより認識できないこともあります。これは千単位の桁区切り文字を使用するときに発生します。いくつかのlocale定義ではnational
conventionに従い、桁区切り文字として@code{'.'}を使用しますが、この文字は@code{"C"}というlocaleでは小数点として使用されます。

これらの理由により、上記のコードの@code{LC_ALL}の行は、@code{setlocale}による行に分けることが必要な場合もあります。

@example
@group
@{
  @dots{}
  setlocale (LC_CTYPE, "");
  setlocale (LC_MESSAGES, "");
  @dots{}
@}
@end group
@end example

@cindex locale category, LC_CTYPE
@cindex locale category, LC_COLLATE
@cindex locale category, LC_MONETARY
@cindex locale category, LC_NUMERIC
@cindex locale category, LC_TIME
@cindex locale category, LC_MESSAGES
@cindex locale category, LC_RESPONSES
@noindent
POSIX互換のすべてのシステムでは、@code{LC_CTYPE}、@code{LC_MESSAGES}、@code{LC_COLLATE}、@code{LC_MONETARY}、@code{LC_NUMERIC}および@code{LC_TIME}が利用できます。ISO
C準拠のみのシステムも存在し、それらのシステムには@code{LC_MESSAGES}がありませんが、これらの不足にたいする代替は GNU
gettextの@code{<libintl.h>}と、GNU gnulibの@code{<locale.h>}で定義されています。

@code{LC_CTYPE}を変更すると、@code{<ctype.h>}という標準ヘッダーファイルで定義されている関数、および@code{<string.h>}と@code{<stdlib.h>}という標準ヘッダーファイルで定義されているいくつかの関数が影響をうけることに注意してください。これが望ましくない場合(例えばコンパイラーのパーサー)、GNU
gnulibのソースディストリビューションにある@samp{c-ctype}、@samp{c-strcase}、@samp{c-strcasestr}、@samp{c-strtod}、@samp{c-strtold}モジュールの、C
localeでハードコーディングされている代替の関数を使用することができます。

環境に依存したlocaleとC
localeを切り替えて使用することもできますが、この方法は@code{setlocale}の呼び出しが高価であること、広大なプログラムのソース中でlocaleを切り替える場所を決定するのが退屈であること、localeの切り替えがスレッドセーフではないこと等の理由により、通常は行われません。

@node Preparing Strings
@section 翻訳可能な文字列の準備

@cindex marking strings, preparations
文字列が翻訳可能とマークされる前に、調整が必要なこともあります。翻訳可能な文字列の準備は、その文字列をマーク(次のセクションで説明)する前に行います。文字列を準備する際に留意すべきは以下の点です。

@itemize @bullet
@item
Englishスタイルとして正常であること。

@item
センテンス全体が含まれていること。

@item
パラグラフで分割されていること。

@item
文字列を連結するのではなく、書式文字列を使用すること。

@item
特殊なマークアップや制御文字を使用しないこと。
@end itemize

@noindent
上記のガイドラインにたいする例を、いくつか見てみましょう。

@cindex スタイル
翻訳可能な文字列は、正しいEnglishスタイルである必要があります。言語特有のスラングや省略語が使用されている場合、翻訳者がメッセージを理解できずに不適切な翻訳を作成してしまうことがあります。

@example
"%s: is parameter\n"
@end example

@noindent
このメッセージはほとんど翻訳不可能です。表示されるアイテムは@emph{a}
parameter(任意のparameter)なのでしょうか、@emph{the} parameter(特定のparameter)なのでしょうか?

@example
"No match"
@end example

@noindent
メッセージに含まれるあいまいさにより、メッセージが理解できなくなっています。プログラムはファイルに何かをセットしようとしているのでしょうか? "The
given object does not match the
template(与えられたオブジェクトがテンプレートにマッチしない)"なのでしょうか、それとも "The template does not fit
for any of the objects(そのテンプレートは任意のオブジェクトに適合しない)"なのでしょうか?

@cindex ambiguities
どちらのケースも、メッセージに単語を追加することにより、翻訳者とEnglishを話すユーザーの両方を助けることができます。

@cindex sentences
翻訳可能な文字列は、センテンス全体を含む必要があります。単独の動詞や形容詞を、すべてのメッセージに代替できるように翻訳するのは不可能な場合があります。

@example
printf ("File %s is %s protected", filename, rw ? "write" : "read");
@end example

@noindent
ほとんどの翻訳者はソースを見ないので、@code{"File %s is %s
protected"}という、それだけでは理解できない文字列しか目にしません。これを以下のように変更します。

@example
printf (rw ? "File %s is write protected" : "File %s is read protected",
        filename);
@end example

@noindent
この方法なら翻訳者はメッセージを理解するだけでなく、適切な文法の組み立て方を見つけることが出きます。たとえばFrenchの翻訳者なら"write
protected"を"protected against writing"のように翻訳するでしょう。

多くの言語では、センテンスの他の場所にある性別や数(単数形/複数形)によって、あるセンテンスの単語が変わることがあるという理由からも、センテンス全体を含めることが重要になります。Englishより強い単語間の相互関係を持つ言語もあります。たとえEnglishではうまく動作しても、多くの言語では半分に分割した2つのセンテンスを翻訳者に翻訳してもらってから、2つの翻訳を機械的に結合しても、満足な翻訳とはなりません。これが翻訳者がセンテンス全体を処理する必要がある理由です。

センテンスが1つの行に対応しない場合もあります。これは以下のように、@code{printf}ステートメントを使って2つの出力により、1つのセンテンスを出力しているような場合です。

@example
printf ("Locale charset \"%s\" is different from\n", lcharset);
printf ("input file charset \"%s\".\n", fcharset);
@end example

@noindent
翻訳者は2つのセンテンスを翻訳する必要があるでしょうが、POTファイル内には2つのセンテンスが分割された1つのセンテンスだと、彼女に教える情報はありません。2つの@code{printf}ステートメントを1つにする必要があります。そうすれば翻訳者がセンテンスを一括して処理できるので、翻訳をどの位置で改行すべきか決められるようなります。

@example
printf ("Locale charset \"%s\" is different from\n\
input file charset \"%s\".\n", lcharset, fcharset);
@end example

では以下のような隣接した2つのセンテンスの場合はどうなるでしょうか:

@example
puts ("Apollo 13 scenario: Stack overflow handling failed.");
puts ("On the next stack overflow we will crash!!!");
@end example

@noindent
上記の2つのセンテンスは、1つにまとめる必要があるでしょうか?
このような場合、2つのセンテンスが互いに関連していて、一緒にしたほうが翻訳者が理解・翻訳しやすくなるようなら、マージすることをお勧めします。一方、2つのメッセージのうち1つが定型的なもので、他の場所でも使用されるようなメッセージの場合は、マージしないほうが翻訳者にとって有益です(同じメッセージが複数の箇所に出現する場合、xgettextがそれらをまとめるので、翻訳者は1度だけそのメッセージを翻訳すればよくなります)。

@cindex パラグラフ(段落)
翻訳可能な文字列は、単一のパラグラフ(段落)に制限すべきです。1つのメッセージの長さは、10行以内にしましょう。その理由は、翻訳可能な文字列が変更されたとき、翻訳者は翻訳済み文字列全体を更新しなければならないからです。たとえ1つの単語を変更しただけでも、(現在の翻訳ツールでは)翻訳者にはそれがわからないので、彼女はメッセージ全体を校正しなければならなくなってしまいます。

@cindex help option
多くのGNUプログラムは、@samp{--help}オプションにより複数画面にまたがる出力を生成します。そのようなメッセージを、1つが5行から10行のメッセージに分割するのは、翻訳者にたいする礼儀です。ドキュメント化するオプションを、入力オプションと出力オプション、情報を出力するオプションのようにグループ分けしてもよいでしょう。グループ分けすることにより、オプションを探すすべてのユーザーを助けることができます。

@cindex string concatenation
@cindex concatenation of strings
ハードコーディングされた文字列の結合により、English文字列を生成することがあります:

@example
strcpy (s, "Replace ");
strcat (s, object1);
strcat (s, " with ");
strcat (s, object2);
strcat (s, "?");
@end example

@noindent
翻訳者にセンテンス全体を表示するためという理由だけではなく、@code{object1}と@code{object2}の順番が入れ替わるような言語もあるので、これは以下のような書式文字列を使用するように変更する必要があります:

@example
sprintf (s, "Replace %s with %s?", object1, object2);
@end example

@cindex @code{inttypes.h}
似たようなケースとして、コンパイル時の文字列結合があります。ISO C
99のインクルードファイルである@code{<inttypes.h>}には、@code{printf}で整数型@samp{int64_t}を出力するための@code{PRId64}マクロが含まれています。このマクロは通常、プラットフォームに応じて
"d"、"ld"、"lld" のような文字列定数に展開されます。以下のようなコードがあるとします。

@example
printf ("The amount is %0" PRId64 "\n", number);
@end example

@noindent
@code{gettext}ツールとライブラリーには、これら@code{<inttypes.h>}のマクロにたいする特別なサポートがあるので、上記のような場合は単に以下のように書くことができます。

@example
printf (gettext ("The amount is %0" PRId64 "\n"), number);
@end example

@noindent
この場合、POファイルには"The amount is
%0<PRId64>\n"という文字列が含まれます。翻訳者は同様に"%0<PRId64>"と翻訳すれば、実行時に@code{gettext}関数が、"d"、"ld"、"lld"
などから適切な文字列定数に変換します。

これは事前に定義された@code{<inttypes.h>}マクロにたいしてのみ機能します。あなたが@samp{MYPRId64}のような似たようなマクロを定義した場合、@code{xgettext}はそれを知ることができないので、コードを以下のように変更してください:

@example
char buf1[100];
sprintf (buf1, "%0" MYPRId64, number);
printf (gettext ("The amount is %s\n"), buf1);
@end example

これでプラットフォームに依存するコードと、インターナショナリゼーションのコードは、別のステートメントに分けられました。バッファーの長さは100バイト以内でよいことに注意してください。なぜなら利用可能なすべてのハードウェアーの整数型は128ビットに制限されており、128ビット整数を出力するには、10進、8進、16進に関わらず最大で54バイトあればよいからです。

@cindex Java, string concatenation
@cindex C#, 文字列連結
これは他のプログラム言語には適用できます。JavaとC#では文字列結合は、それらのコンパイラーのビルトイン操作なのでとても頻繁に使用されます。以下のようなCやJavaのコードがあるとします

@example
System.out.println("Replace "+object1+" with "+object2+"?");
@end example

@noindent
これを以下のような書式師弟文字列を含むステートメントに変更します:

@example
System.out.println(
    MessageFormat.format("Replace @{0@} with @{1@}?",
                         new Object[] @{ object1, object2 @}));
@end example

@noindent
C#の場合は以下のように変更します

@example
Console.WriteLine("Replace "+object1+" with "+object2+"?");
@end example

@noindent
これを以下のような書式師弟文字列を含むステートメントに変更します:

@example
Console.WriteLine(
    String.Format("Replace @{0@} with @{1@}?", object1, object2));
@end example

@cindex markup
@cindex control characters
通常使用しないようなマークアップや制御文字は、翻訳可能な文字列の中に含めるべきではありません。翻訳者はマークアップや制御文字がもつ特別な意味は理解しません。

たとえば@samp{|}の右側と左側とで何らかのGUI要素を分ける規則があるような場合、翻訳者は特別なコメントなしではその規則を理解することはできません。このような場合は、翻訳者が右側と左側の文字列を個別に翻訳できるようにするのがよいでしょう。

他の例としては、@samp{argp}で制御文字@samp{\v}(vertical
tab)を使用する場合の規則です。これは1つの文字列を2つのセクションに分ける場合に使用されます。このような文字列をそのまま翻訳可能文字列とするには問題があります。翻訳者によっては、これを単純に改行や空行に置き換えてしまうかもしれません。POファイルエディターの中には、制御文字のvertical
tabを入力するのが困難なものもあります。上記の理由により、あなたは翻訳文字列の対応する位置に、@samp{\v}文字があることを期待できません。この問題にたいする解決策は、繰り返しになりますが、翻訳者が個別に文字列を翻訳できるようにしておいて、実行時に2つの翻訳された文字列を、規則が要求する@samp{\v}で結合することです。

HTMLマークアップは十分に一般的なマークアップなので、翻訳可能文字列を使用しても大丈夫でしょう。しかしGNU
gettextツールは、翻訳された文字列がwell-formedなHTMLであるかは検証しないことに留意してください。

@node Mark Keywords
@section ソース内でマークはどのように見えるか
@cindex marking strings that require translation

Cソース中で翻訳される文字列は、すべてマークする必要があります。マーキングは翻訳可能な文字列を、関数やプリプロセッサーのマクロに、単独の引数として引き渡す方法で行われます。翻訳のために利用可できる関数またはマクロは少なく、マーキングのキーワードとしてそれらの名前が使用されます。マーキングは翻訳される文字列自体に何かを行うよりは、文字列にアタッチすることによりマーキングを行なう方法が、より多く使用されます。明らかな例としては、書式文字列によりエラーメッセージを生成する場合です。書式文字列は翻訳する必要があり、フォーマット文字列の@samp{%s}で指定した箇所に挿入される文字列も同様だとすると、たとえば@code{sprintf}の結果には、@samp{error_string_out()}のようなルーチンからなる、多くの異なるインスタンスが含まれることになり、これらをすべてリストするのは非現実的です。

マーキングには2つの目的があります。1つ目は実行時に翻訳を取得するトリガーとなることです。キーワードは引数となる文字列にたいして、可能なかぎり(そして望む限り)、動的に適切なトランスレーションを返すルーチンへと解決されます。ローカライズ可能な文字列は、変数にあてがわれていたり、関数の引数になっている場合がほとんどです。しかし翻訳可能な文字列が構造体の初期化時に使用される等の例外もあります。@ref{Special
cases}を参照してください。

2つ目の目的は、@code{xgettext}が、一連のプログラムソースをスキャンしてPOファイルのテンプレートを生成するときに、翻訳可能な文字列を適切に抽出する手助けをすることです。

翻訳可能な文字列をマークするための標準的なキーワードは@samp{gettext}で、これはGNU
@code{gettext}パッケージの名前の由来にもなっています。パッケージで少量の@samp{gettext}キーワードやマクロ、関数を@emph{そのまま}使うのは簡単です。しかし@code{gettext}インターフェースを多用するパッケージの場合、主要なキーワードには目立つ名前ではなく、より簡潔な名前を使用する方が便利です。キーワードはパッケージ内のすべての文字列の箇所に記述されますが、プログラマーは通常、彼らのプログラムのソースがインターナショナライズされるものだといつも強制的に思い出したいとは望みませんし、その必要もありません。また長いキーワードはより多くの文字数を使用するので、ソースの1行を79から80文字にインデントするための労力が余分にかかるという欠点もあります。

@cindex @code{_}, a macro to mark strings for translation
多くのパッケージはキーワードとして@samp{_}(単なるアンダーライン)を使用して、@samp{gettext ("Translatable
string")}を、@samp{_("Translatable
string")}のように記述しています。またGNU標準のコーディング規約は実際、この特定の用途のためにキーワードと開き括弧の間に、余白としてスペースを要求しています。これにより翻訳可能な文字列のためにかかる文字的なオーバーヘッドは、アンダーラインと2つの括弧というたった3文字に短縮されます。たとえGNU
@code{gettext}がこの方式を内部的に使用していたとしても、これは公式な提案ではありません。正式なキーワードはあくまでも本物の@samp{gettext}です。しかし@samp{gettext}のかわりに@samp{_}を使用したい人は、以下のように定義すると簡単になります。

@example
#include <libintl.h>
#define _(String) gettext (String)
@end example

@noindent
単に@samp{#include <libintl.h>}とするのではなく、上記のようにすれば簡単に使用できます。

マーキングのためのキーワードである@samp{gettext}と@samp{_}
は、翻訳可能文字列を単一の引数とします。他の位置に引数をするマーキング用の関数を定義することもできます。関数が呼び出されたときの引数の合計数にもとづいた位置のマーク用引数を作ることもできます(通常はC++の場合)。これは@code{xgettext}の@samp{--keyword}により実現されます。@code{xgettext}にこのような引数を渡すには@code{gettextize}が使用されます、その方法については@ref{po/Makevars}と@ref{AM_XGETTEXT_OPTION}で説明します。

長い文字列は複数行に分けられることに注意してください。コンパイル時にはISO CおよびISO
C++にもとづく文字列の自動連結が行われますが、@code{xgettext}もこの構文をサポートしています。

後でメンテナンスするのも簡単になります。もしあなたがプログラマーで、文字列を追加、変更した場合、その文字列が翻訳される必要があると考えた場合は、@samp{_()}でマークすればよいのです。たとえば@samp{"%s"}は、翻訳しない文字列だとします。しかし@samp{"%s:
%d"}は翻訳するような場合です(Frenchの場合は通常、Englishとは異なり、コロンの前にスペースを挿入する翻訳が必要になります)。

@node Marking
@section 翻訳可能文字列のマーク
@emindex marking strings for translation

POモードには、翻訳者向けというよりはプログラマー向けの一連の機能があります。それらの機能により彼は、プログラムのソース中の文字列が、翻訳可能かどうか、対話的にマークすることができます。彼が選んだ他のエディターでも、それらの文字列を探してマークするのは、プログラマーにとって簡単な作業かもしれませんが、POモードはこれらの作業をより快適にしてくれます。またPOモードは、プログラマーの素養を持つ翻訳者、または翻訳者の素養を持つプログラマーにたいして、プログラムのソース中の翻訳可能な文字列をマークするツールを与えてくれると同時に、インターナショナライズされるパッケージにたいする翻訳を生成するツールを与えてくれるのです。

@emindex @code{etags}, using for marking strings
以下で説明するPOモードのコマンドが対象とするプログラムのソースは、POファイルのコマンドを使う前に、プロジェクト用のEmacs
tagsテーブルを生成する必要があります。これは簡単です。任意のシェルウィンドウでプロジェクトのルートディレクトリに移動して、以下のようなコマンドを実行してください:

@example
etags src/*.[hc] lib/*.[hc]
@end example

@noindent
ここでは@file{src/}、および@file{lib/}ディレクトリーにあるすべての@file{.h}と@file{.c}ファイルを処理したいとします。このコマンドは指定されたすべてのファイルを検索して、プロジェクトのルートディレクトリーに@file{TAGS}という、Emacsが解釈できる要約された形式のファイルを作成します。

@emindex @file{TAGS}, and marking translatable strings
GNUコーディング規約に従うパッケージには、すべてのディレクトリーとソースコードを含んだすべてのファイルにたいして、@code{tags}、または@code{TAGS}ファイルを作成するという目標があります。

1度@file{TAGS}を準備すれば、以下のコマンドが彼のソース中の翻訳可能な文字列をマークする手助けをしてくれます。これらのコマンドはPOファイルのウィンドウから実行される必要がありますが、POファイルはまだ作成されていません。しかし新しいウィンドウで空のPOファイルを新規に作成して、そこからコマンドを実行すれば問題ありません。この空のPOファイルの内容は、プログラムのソース中の文字列を翻訳可能にマークするにつれて、徐々に増えていきます。

@table @kbd
@item ,
@efindex ,@r{, PO Mode command}
翻訳候補となりそうな文字列をプログラムのソースから検索します(@code{po-tags-search})。

@item M-,
@efindex M-,@r{, PO Mode command}
検索された最後の文字列を@samp{_()}でマークします(@code{po-mark-translatable})。

@item M-.
@efindex M-.@r{, PO Mode command}
検索された最後の文字列を、利用可能なキーワードによりマークします。プレフィックスと一緒にこのコマンドを使うことにより、キーワードを管理することができます(@code{po-select-mark-and-mark})。

@end table

@efindex po-tags-search@r{, PO Mode command}
@kbd{,}
(@code{po-tags-search})コマンドは、翻訳候補と思われるような次の文字列を検索して、プログラムのソースをEmacsの他のウィンドウで表示します(その文字列がウィンドウの上部にくるように表示されます)。文字列が長くてウィンドウに収まらないような場合は、文字列の最後の部分が表示されます。カーソルは常にPOファイルのウィンドウにあります。その文字列が他の言語に翻訳されたほうがよいと判断したら、@kbd{M-,}、または@kbd{M-.}により文字列をマークします。翻訳する必要がないと判断した場合は、単に@kbd{,}コマンドで次の文字列を検索してください。

3つ以上の文字の並びは、翻訳候補となります。1行の文字の並びが最大で2つでも、文字の数が非文字より多い場合は、翻訳候補と判断します。文字を含まない文字列、または
孤立した文字だけの文字列は無視されます。コメント文字列、およびPOモードが把握しているキーワード(以下を参照してください)ですでにマークされている文字列も無視されます。

Emacsにたいして@file{TAGS}を指定していない場合、最初にこのコマンドを使うときにミニバッファー(minibuffer)に入力を求められます。@file{TAGS}ファイルは、Emacsの標準コマンドである@w{@kbd{M-x
visit-tags-table}}を入力して、正しい@file{TAGS}ファイルを入力することにより、後から変更することができます。@ref{Tags,
, Tag Tables, emacs, The Emacs Editor}を参照してください。

@kbd{,}コマンドは毎回、前回に検索した箇所から検索を再開し、@file{TAGS}に従ってすべてのプログラムソースを処理するまで検索します。コマンド@w{(@kbd{C-u
,})}にプレフィクス引数( prefix
argument)を与えることにより、プログラムのソースの先頭から検索を再開させることができます。この場合、前回マークした翻訳可能な文字列は自動的にスキップされます。

@kbd{,}コマンドを使用することにより、Emacsの標準コマンドが使用できなくなることはありません。たとえば、標準の@code{tags-search}、および@code{tags-query-replace}コマンドは、@kbd{,}のサーチ順序とは独立して、中断されることなく使用できます。しかし、@emph{最初}の@kbd{,}コマンド(またはコマンド引数をともなう@kbd{,}コマンド)は、Emacsの標準的なtags検索を最初のtagsにリセットしてしまうよう実装されているので、この再初期化は除きます。

@efindex po-mark-translatable@r{, PO Mode command}
@efindex po-select-mark-and-mark@r{, PO Mode command}
@kbd{M-,}
(@code{po-mark-translatable})コマンドは、前回検索された文字列を、キーワード@samp{_}でマークします。@kbd{M-.}
(@code{po-select-mark-and-mark})コマンドは、ミニバッファーでキーワードの入力を求めて、文字列をマークするのにそのキーワードを使用します。どちらのコマンドも、マークした文字列に対応する新しい未翻訳のエントリーをPOファイルに作成して、そのエントリーをカレントのエントリーとします(そのエントリーをすぐに翻訳するのが簡単になります)。@kbd{M-,}や@kbd{M-.}によるプログラムソースの変更により、ソース1行の文字数が80文字を超えてしまうような場合もありますが、これにたいする再インデントなどは別の作業になります。プログラムソースのウィンドウから、Emacsの別のウィンドウに移ったりするために、POモードから@kbd{O}コマンドを使う場合もあるでしょう。@kbd{,}コマンドに次の文字列を告げるような場合、POファイルのウィンドウにカーソルを戻すには、なんらかのEmacsの標準コマンドを使う必要があります。

@kbd{M-.}には、キーワードをいちいち全部入力しなくてもよいような、スピードアップのための機能がいくつかあります。1つ目は、プロンプトで単に@kbd{@key{RET}}を押すだけで、@emph{好ましいキーワード}が表示されるというスピードアップ機能です。2つ目は、入力したいキーワードにたいして、そのキーワードの先頭部分を一意に特定できる分だけ入力すれば、コマンドが残りの部分を補完してくれるスピードアップ機能です。これはPOモードが利用可能なキーワードを@emph{知って}いて、ミスタイプによる誤ったキーワードは受け付けられないことを意味します。

キーワードの入力を求められたときに@kbd{?}を入力すると、コマンドは既知のキーワードのリストを表示し、そこから選択して入力することができます。@w{(@kbd{C-u
M-.})}によりコマンドが引数が指定された場合、単純なキーワード管理以外による、プログラムのソースとPOファイルのバッファーの更新が禁じられます。この場合、コマンドはキーワードの完全な入力を求め、そのキーワードは以降の@kbd{M-.}コマンドで使用されます。さらに、この新しいキーワードは自動的に、以降のコマンド用の@emph{お好み}のキーワードに追加されます。@w{@kbd{C-u
M-.}}にたいして既知のキーワードを答えた場合、単にお勧めのキーワードが1つ変更されるだけで、他には何もしません。

@kbd{M-.}により認識されるすべてのキーワードは、@kbd{,}コマンドによる文字列検索時に再編成されます。この時、これらのキーワードですでにマークされている文字列は自動的にスキップされます。同時に複数のPOファイルを開いている場合、それぞれが個別に既知のキーワードを保有します。現在のところPOモードにキーワードを削除するための機能はないので、(@kbd{q}を使用するなどして)ファイルを一旦閉じてから、再度開く必要があります。Emacs
のウィンドウにPOファイルを新規に開いたときは、@samp{gettext}と@samp{_}だけがキーワードで、@kbd{M-.}コマンドのお好みのキーワードは@samp{gettext}になっています。実際のところ、@samp{_}はビルトインの@kbd{M-,}コマンドに割り当てられているので、お勧めにするには便利ではありません。

@node c-format Flag
@section キーワードの前の特別なコメント

@c FIXME document c-format and no-c-format.

@cindex format strings
Cプログラム中の文字列は、しばしば@code{printf}ファミリーと呼ばれる関数呼び出しで使用されます。これらで使用される書式指定文字列に関して特筆すべきは、@kbd{%}で始まる書式指定子が含まれていることです。以下のようなコードがあるとしましょう。

@example
printf (gettext ("String `%s' has %d characters\n"), s, strlen (s));
@end example

@noindent
上記の文字列にたいして、以下のようなGermanの翻訳が考えられます:

@example
"%d Zeichen lang ist die Zeichenkette `%s'"
@end example

Germanを話せないCプログラマーでも、まずい点があることに気がつくでしょう。文字列中の書式指定子の順序が変更されていますが、@code{printf}の引数の順序は変更されません。一番問題なのは、文字列のアドレスが期待されている箇所に、文字列の長さが渡していることです。

翻訳に起因する実行時のエラーを防ぐために、@code{msgfmt}は翻訳前の文字列と、翻訳後の文字列に含まれる引数のタイプと数を、静的にチェックすることができます。このチェックを満足しないような場合、@code{msgfmt}に@samp{-c}が指定されていると、@code{msgfmt}はエラーを発生させてMOファイルを生成しません。したがって、一貫性を保って@samp{msgfmt
-c}を使用することにより、エラーを事前に検出して、実行時の問題を防ぐことができます。

@noindent
Germanの翻訳で上述の単語順が正しい場合は、以下のように記述する必要があります

@example
"%2$d Zeichen lang ist die Zeichenkette `%1$s'"
@end example

@noindent
@code{msgfmt}ルーチンは、この特別な表記法を認識できます。

プログラムのすべての文字列が書式文字列というわけではないので、@file{.po}ファイルの中のすべての文字列を@code{msgfmt}がテストする必要はありません。また文字列の中に書式指定子と似た文字列が含まれるが、その文字列が@code{printf}で使われる文字列ではないような場合は、問題が発生します。

そのため@code{xgettext}は、それらの書式文字列と思われるメッセージに特別なタグを付与します。このタグ付けは絶対的なルールではなく、発見的なルールです。@file{.po}ファイルの中のそれらのエントリーには、@code{#,}によるコメント行で、@code{c-format}というフラグによりマークされます(@ref{PO
Files}を参照してください)。

@kwindex c-format@r{, and @code{xgettext}}
@kwindex no-c-format@r{, and @code{xgettext}}
注意深い読者は、まだ問題があると気づくでしょう。発見されたものが間違っている場合です。これは真実であり、そのために@code{xgettext}は、プログラマーが意志決定すべき特別な種類のコメントを認識することができるのです。@code{gettext}キーワードと同じ行、またはそれに続く行に@code{xgettext:c-format}という単語を含むコメントを発見すると、@code{xgettext}はどのような場合であれ、文字列を@code{c-format}フラグでマークします。この種のコメントは、@code{xgettext}が文字列を書式文字列と認識しない場合(テストしてみて実際に認識されない場合)に使う必要があります。@code{gettext}キーワードと同じ行にコメントがある場合、翻訳される前にコメントを挿入しなければならないことに注意してください。

このような状況は頻繁に発生します。@code{printf}関数にわたされる文字列に書式指定子が含まれない場合もあります。そのようなケースでは通常、@code{fputs}を使用するのでしょうが、それでもこのような状況はあり得ます。このような場合、@code{xgettext}はそれを書式文字列として認識しませんが、翻訳に書式指定子として認識されるような文字列が含まれていると何が起こるでしょうか?
@code{printf}関数はパラメーターにアクセスしようとしますが、翻訳前の文字列には何も引数がわたされないため、パラメーターは存在しません。

もちろん他の原因により、@code{xgettext}が間違って書式文字列ではない文字列を、書式文字列と認識することがあります。このような場合、@code{msgfmt}は多くの警告を出力し、@file{.po}ファイルへの変換は失敗します。このように間違って書式文字列と認識されるのを防ぐには、上記と同様に@code{xgettext:no-c-format}という文字列を含むコメントを使用します。

文字列が@code{c-format}と間違ってマークされている場合、ユーザーは何が原因なのか調べることができます。@code{--debug}オプション使用して、どのように問題を解決するかについては、@ref{xgettext
Invocation}を参照してください。

@node Special cases
@section 翻訳可能文字列の特別なケース

@cindex marking string initializers
注意深い読者なら、常に翻訳可能な文字列を@code{gettext}(または同様のもの)でマークすることはできないことに気づくでしょう。たとえば以下のようなケースです:

@example
@group
@{
  static const char *messages[] = @{
    "some very meaningful message",
    "and another one"
  @};
  const char *string;
  @dots{}
  string
    = index > 1 ? "a default message" : messages[index];

  fputs (string);
  @dots{}
@}
@end group
@end example

文字列@code{"a default
message"}にたいするマーク付けは問題ありませんが、配列@code{messages}を初期化する文字列はマークできません。どうすればよいのでしょうか?
このような場合は2つのタスクを達成する必要があります。最初に@code{xgettext}プログラムが文字列を見つけ出せるように文字列をマークします(@ref{xgettext
Invocation}を参照してください)。次に実行時に文字列を出力する前に、文字列を翻訳するのです。

最初のタスクは、no-opという新しいキーワードを作ることにより達成できます。2番目のタスクは、配列の文字列にたいするすべてのアクセスポイントをマークします。考えられる解決策の1つは、以下のようなものです:

@example
@group
#define gettext_noop(String) String

@{
  static const char *messages[] = @{
    gettext_noop ("some very meaningful message"),
    gettext_noop ("and another one")
  @};
  const char *string;
  @dots{}
  string
    = index > 1 ? gettext ("a default message") : gettext (messages[index]);

  fputs (string);
  @dots{}
@}
@end group
@end example

どのようなケースでも、@code{fputs}に記述された文字列は翻訳されると思ってください。どのようにして@code{xgettext}が、追加のキーワード@code{gettext_noop}を認識するかについては、@ref{xgettext
Invocation}を参照してください。

もちろん、これが唯一の解決策という訳ではありません。以下の方法のうちのいずれかを使用することもできます:

@example
@group
#define gettext_noop(String) String

@{
  static const char *messages[] = @{
    gettext_noop ("some very meaningful message"),
    gettext_noop ("and another one")
  @};
  const char *string;
  @dots{}
  string
    = index > 1 ? gettext_noop ("a default message") : messages[index];

  fputs (gettext (string));
  @dots{}
@}
@end group
@end example

しかしこの方法には欠点があります。プログラマーは文字列@code{"a default
message"}にも@code{gettext_noop}を使うよう留意する必要があります。@code{gettext}を使用することにより、予期しない結果となる場合もあります。

利点の1つは、どのようなケースでも出力が翻訳されるようにするために、制御フローを分析する必要がないことです。この分析は一般的に難しいものではありませんが、これにあてはまらないような状況では、2番目の方法を使用することもできます。

@node Bug Report Address
@section 翻訳バグの報告をユーザーに奨励する

コードにはバグが付き物ですが、翻訳も同様です。ユーザーがそれらのバグを報告できるようにする必要があります。メンテナーが同時に翻訳者であるような場合を除き、メンテナーが翻訳を変更することはないため、プログラマーやパッケージのメンテナーに翻訳のバグを報告するのは得策ではありません。したがって翻訳のバグは翻訳者に報告されなければなりません。

ここで紹介する方法で組織化することにより、メンテナーが翻訳のバグ報告をどこかへ転送したり、翻訳者や翻訳チームのアドレスのリストを維持する必要もなくなります。

すべてのプログラムには、バグを報告するためのアドレスを示す場所があります。GNUプログラムの場合、``--help''オプションにより表示される、``usage''(使用方法)とよばれる機能が該当する場所です。この場所に翻訳のバグ報告のためのアドレスを追加するよう、翻訳者に示すのです。たとえば以下のようなコードがあるとします

@example
@group
printf (_("Report bugs to <%s>.\n"), PACKAGE_BUGREPORT);
@end group
@end example

以下のように、翻訳者への指示を追加することができます：

@example
@group
/* TRANSLATORS: The placeholder indicates the bug-reporting address
   for this package.  Please add _another line_ saying
   "Report translation bugs to <...>\n" with the address for translation
   bugs (typically your translation team's web or email address).  */
printf (_("Report bugs to <%s>.\n"), PACKAGE_BUGREPORT);
@end group
@end example

これらは@samp{xgettext}により抽出され、以下のようなエントリーを含む.potファイルとなります:

@example
@group
#. TRANSLATORS: The placeholder indicates the bug-reporting address
#. for this package.  Please add _another line_ saying
#. "Report translation bugs to <...>\n" with the address for translation
#. bugs (typically your translation team's web or email address).
#: src/hello.c:178
#, c-format
msgid "Report bugs to <%s>.\n"
msgstr ""
@end group
@end example

@node Names
@section 翻訳にたいして正確な名前をマークする

人や都市、場所の名前などは翻訳用にマークする必要があるでしょうか?
Latin文字で記述する言語(English、Spanish、French、German等)しか知らない人は、``no''と言いたいでしょう。なぜなら通常は、それらの言語間で名前は変更されないからです。しかし一般的には、ある文字体系から他の文字体系に変換するときには、音声表記や音訳により名前も変換されます。たとえばRussianやGreekの名前は、Englishに変換されるときにLatinのアルファベットに変換され、EnglishやFrenchがJapaneseに変換されるときはKatakana文字に変換されます。対象となる言語を話す人たちは、一般的には翻訳前の文字で記述された元の名前を読めないので、これらの変換が必要になります。

それゆえプログラマーとしては、名前を翻訳用にマークするとともに、翻訳者にたいしてそれが元の正確な名前であることと、どのように取り扱うかについての特別なコメントを付与する必要があります。以下は簡単な例です:

@example
@group
printf (_("Written by %s.\n"),
        /* TRANSLATORS: This is a proper name.  See the gettext
           manual, section Names.  Note this is actually a non-ASCII
           name: The first name is (with Unicode escapes)
           "Fran\u00e7ois" or (with HTML entities) "Fran&ccedil;ois".
           Pronunciation is like "fraa-swa pee-nar".  */
        _("Francois Pinard"));
@end group
@end example

@noindent
GNU
gnulibは、オリジナル名にカッコ内に翻訳された名前を自動的に追加する@samp{propername}　(@url{https://www.gnu.org/software/gnulib/MODULES.html#module=propername})というモジュールを提供しています。これによりスクリプトを変更しなくてもよいような場合には、翻訳者がASCIIで記述できないような名前にたいして、適切な非ASCII文字を入力するというタスクから開放されます。この、より快適な形式は以下のようなものです:

@example
@group
printf (_("Written by %s and %s.\n"),
        proper_name ("Ulrich Drepper"),
        /* TRANSLATORS: This is a proper name.  See the gettext
           manual, section Names.  Note this is actually a non-ASCII
           name: The first name is (with Unicode escapes)
           "Fran\u00e7ois" or (with HTML entities) "Fran&ccedil;ois".
           Pronunciation is like "fraa-swa pee-nar".  */
        proper_name_utf8 ("Francois Pinard", "Fran\303\247ois Pinard"));
@end group
@end example

@noindent
元の名前を、(UnicodeエスケープやHTMLエンティティーとしてではなく)直接Unicodeで記述して、IPA(International
Phonetic Alphabet:
国際音標文字。@url{https://en.wikipedia.org/wiki/International_Phonetic_Alphabet})を参照してください)により発音を示すこともできます。

翻訳者としては、名前を翻訳するときは注意深く行う必要があります。なぜなら名前がバラバラに翻訳されたり、間違って翻訳されることは、人を不快にさせるからです。

あなたの言語がLatin文字を使用している場合、必要なのはその言語で普段使用している文字で名前を再構築することだけです。これはc-cedilla文字を含む翻訳を提供するような場合です。あなたの言語がLatin文字とは異なる文字を使用していて、人がそれを通常Latin文字として読まれるようには話していない場合、それは翻訳を意味しています。プログラマーが簡単な方法を使用している場合でも、Latin文字を読む人のために、括弧付きで元の名前を記述する必要があります。プログラマーが上述の@samp{propername}モジュールを使用している場合は、元の名前を括弧付きで記述するのはプログラムが行うので、あなたが記述する必要はありません。以下は対象言語がGreekの場合の例です:

@example
@group
#. This is a proper name.  See the gettext
#. manual, section Names.  Note this is actually a non-ASCII
#. name: The first name is (with Unicode escapes)
#. "Fran\u00e7ois" or (with HTML entities) "Fran&ccedil;ois".
#. Pronunciation is like "fraa-swa pee-nar".
msgid "Francois Pinard"
msgstr "\phi\rho\alpha\sigma\omicron\alpha \pi\iota\nu\alpha\rho"
       " (Francois Pinard)"
@end group
@end example

このように名前の翻訳は微妙な領域に属する話題なので、翻訳を提出する前にテストすることをお勧めします。

@node Libraries
@section ライブラリーソースの準備

あなたがプログラムではなくライブラリーを作成する場合、@code{gettext}の使用方法にはわずかな違いしかありません。ここでは前提として、ライブラリーが自分自身の翻訳ドメインとPOTファイルを持つとします(ライブラリーがメインプログラムの翻訳ドメインとPOTファイルを使用する場合は、前のセクションを変更なしに適用できます)。

@enumerate
@item
ライブラリーのコードでは、@code{setlocale (LC_ALL,
"")}を呼び出しません。localeのセットはメインプログラムの責任です。ライブラリーのドキュメントにはこの事実を明記して、ライブラリーを使用するプログラム開発者が認識できるようにする必要があります。

@item
ライブラリーのコードでは、@code{textdomain (PACKAGE)}を呼び出しません。text
domainのセットはメインプログラムの責任です。

@item
プログラムのための初期化は以下のようなコードでした

@smallexample
  setlocale (LC_ALL, "");
  bindtextdomain (PACKAGE, LOCALEDIR);
  textdomain (PACKAGE);
@end smallexample

@noindent
ライブラリーの場合は以下のコードだけになります

@smallexample
  bindtextdomain (PACKAGE, LOCALEDIR);
@end smallexample

@noindent
ライブラリーのAPIにまだ初期化の関数が無いなら、@code{bindtextdomain}呼び出しを含む初期化関数を作成する必要があります。しかし通常、この初期化関数をエクスポートしたりドキュメント化する必要はありません。初期化関数がまだ呼び出されていない場合は、ライブラリーのすべてのエントリーポイントとなる関数から初期化関数を呼び出すだけで十分です。これを満足するような典型的な例は、初期化関数が呼び出し済みかどうかを保持するブール値の静的な変数を使用する方法です:

@example
@group
static bool libfoo_initialized;

static void
libfoo_initialize (void)
@{
  bindtextdomain (PACKAGE, LOCALEDIR);
  libfoo_initialized = true;
@}

/* This function is part of the exported API.  */
struct foo *
create_foo (...)
@{
  /* Must ensure the initialization is performed.  */
  if (!libfoo_initialized)
    libfoo_initialize ();
  ...
@}

/* This function is part of the exported API.  The argument must be
   non-NULL and have been created through create_foo().  */
int
foo_refcount (struct foo *argument)
@{
  /* No need to invoke the initialization function here, because
     create_foo() must already have been called before.  */
  ...
@}
@end group
@end example

@item
プログラムでは通常、各ソースファイル中で、以下のように@samp{_}マクロを定義しました

@smallexample
#include <libintl.h>
#define _(String) gettext (String)
@end smallexample

@noindent
自身の翻訳ドメインを持つライブラリーの場合は、以下のようになります:

@smallexample
#include <libintl.h>
#define _(String) dgettext (PACKAGE, String)
@end smallexample

別の言い方をすると、@code{gettext}のかわりに@code{dgettext}を使用するということです。同様に、@code{ngettext}が使用される箇所には、@code{dngettext}を使用する必要があります。
@end enumerate

@node Template
@chapter POテンプレートファイルのマーク
@cindex PO template file

ソースの準備ができたら、プログラマーはPOテンプレートファイルを作成します。このセクションでは、その目的のために@code{xgettext}をどのように使用するかについて説明します。

@code{xgettext}は、@file{@var{domainname}.po}という名前のファイルを作成します。あなたはそれを@file{@var{domainname}.pot}という名前にリネームする必要があります(@code{xgettext}は、どうして直接@file{@var{domainname}.pot}を作成しないのでしょうか?
これは歴史的な理由からです。@code{xgettext}が設計されたときはPOファイルとPOテンプレートファイルの区別があいまいで、拡張子の@samp{.pot}も使用されていなかったからです)。

@c FIXME: Rewrite.

@menu
* xgettext Invocation::      Invoking the @code{xgettext} Program
@end menu

@node xgettext Invocation
@section @code{xgettext}プログラムの呼び出し

@include xgettext.texi

@node Creating
@chapter 新しいPOファイルの作成
@cindex creating a new PO file

新しい翻訳を開始する場合、翻訳者は@file{@var{package}.pot}の初期コメント(ファイルの先頭にあります)とヘッダーのエントリー(最初のエントリーで、これもファイルの先頭付近にあります)に変更を加えたものをコピーして、@file{@var{LANG}.po}を作成します。

これを行う一番簡単な方法は、@samp{msginit}を使うことです:

@example
$ cd @var{PACKAGE}-@var{VERSION}
$ cd po
$ msginit
@end example

かわりにコピーしてから手で変更する方法もあります。この場合、翻訳者は@file{@var{package}.pot}を@file{@var{LANG}.po}というファイル名でコピーしてから、ファイル内の初期コメントとヘッダーエントリーを修正します。

@menu
* msginit Invocation::       Invoking the @code{msginit} Program
* Header Entry::             Filling in the Header Entry
@end menu

@node msginit Invocation
@section @code{msginit}プログラムの呼び出し

@include msginit.texi

@node Header Entry
@section ヘッダーエントリーを入力する
@cindex header entry of a PO file

新規作成したときに初期値として入力されている、"SOME DESCRIPTIVE TITLE"、"YEAR"、および"FIRST AUTHOR
<EMAIL@@ADDRESS>、YEAR"などのコメントは、意味のある情報に書き換えるべきです。これはテキストエディターにより行うこともできますが、Emacsを使っていれば(拡張子を識別して)自動的にPOモードに切り替わります。これは@kbd{M-x
fundamental-mode}と入力して無効にすることができます。

ヘッダーのエントリーの変更も、POモードで行うことができます。Emacsで、@kbd{M-x po-mode
RET}と入力して、さらに@kbd{RET}を押すと、エントリーの編集が開始できるので、以下のフィールドに入力してください。

@table @asis
@item Project-Id-Version
パッケージの名前とバージョンです。@code{xgettext}により入力されていない場合は入力してください。

@item Report-Msgid-Bugs-To
これは@code{xgettext}によってすでに入力されています。未翻訳の文字列に関するバグを報告するための、電子メールアドレスかURLが含まれています:

@itemize -
@item センテンス全体となっていないような文字列。メンテナーのためのガイドライン
@ref{Preparing Strings}を参照してください。
@item 不明な用語を使用したり、追加のコンテキストを理解することが必要とする文字列
。
@item 日付・時刻・通貨の表記で、無効な仮定をしている文字列
。
@item plural化に関する問題。
@item 間違ったEnglishのスペル。
@item 間違った書式。
@end itemize

@item POT-Creation-Date
これは@code{xgettext}によってすでに入力されています。

@item PO-Revision-Date
これはPOファイルのためのエディターが、ファイルを保存するときに入力される項目なので、あなたは入力する必要はありません。

@item Last-Translator
名前と電子メールアドレス（ダブルクォーテーションなし）を入力してください。

@item Language-Team
言語の英語名と、あなたが所属するlanguage teamの電子メールアドレスか、ホームページのURLを入力してください。

重複して作業するの防ぐためだけではなく、言語に関する難しい問題を調整するためにも、翻訳を開始する前にtranslation
teamに連絡することをお勧めします。

@cindex translation teamを探すためのリスト
フリーな翻訳プロジェクトでは、それぞれの翻訳チームが、チーム自身のメーリングリストを持っています。チームの最新のメーリングリスト一覧は、Free
Translation Projectのホームページ(@uref{https://translationproject.org/})
の"Teams"という場所にあります。

@item Language
@c The purpose of this field is to make it possible to automatically
@c - convert PO files to translation memory,
@c - initialize a spell checker based on the PO file,
@c - perform language specific checks.
あなたの言語の言語コードを入力してください。以下の3つの形式のいずれかになります:

@itemize -
@item
@samp{@var{ll}}: @w{ISO 639}の2文字(小文字)の言語コードです。コードの一覧は@ref{Language
Codes}を参照してください。 

@item
@samp{@var{ll}_@var{CC}}: @samp{@var{ll}}は@w{ISO 639}の2文字(小文字)のlanguage
code、@samp{@var{CC}}は@w{ISO 3166}の2文字(大文字)のcountry
codeです。いくつかのlanguageは、異なるcountryで使用される方言を持っていますが、country
codeの仕様に冗長性はありません。たとえば@samp{de_AT}はAustriaで使用され、@samp{pt_BR}はBrazilで使用されます。country
codeは方言を区別するために提供されています。コードの一覧については@ref{Language Codes}と@ref{Country
Codes}を参照してください。 

@item
@samp{@var{ll}_@var{CC}@@@var{variant}}: @samp{@var{ll}}は@w{ISO
639}の2文字(小文字)のlanguage code、@samp{@var{CC}}は@w{ISO 3166}の2文字(大文字)のcountry
code、@samp{@var{variant}}はvariant designatorです。variant
designator(小文字)には、@samp{latin}や@samp{cyrillic}のようなscript
designatorを指定することもできます。 
@end itemize

@samp{@var{ll}_@var{CC}}の命名規則は、システムがGNU
libcにもとづいてlocale名を決定する方法でもありますが、重要な違いが3つあります。

@itemize @bullet
@item
POファイルのこの項目はlocale名とは異なり、@samp{@var{ll}_@var{CC}}という組み合わせは、languageの主たる方言であることを示す@samp{@var{ll}}という略記であらわされます。たとえば、このコンテキストでは@samp{de}は@samp{de_DE}(Germanyで話されるGerman)
と等しく、@samp{pt}は@samp{pt_PT}(Portugalで話されるPortuguese)と同じです。

@item
POファイルのこの項目では、@samp{.@var{encoding}}のような接尾辞は使用しません。

@item
POファイルのこの項目では、メッセージの翻訳とは関係のない、@samp{@@euro}のようなvariant designatorは使用しません。
@end itemize

そのため、あなたのlocale名が@samp{de_DE.UTF-8}の場合、POファイルのlanguage
specificationは@samp{de}だけになります。

@item Content-Type
@cindex POファイルのエンコーディング
@cindex POファイルのcharset
@samp{CHARSET}を、あなたのlocaleのlanguageで使用するcharacter
encodingかUTF-8で置き換えてください。この項目は、@code{msgmerge}と@code{msgfmt}の正しい動作のために必要です。同様にlocaleのcharacter
encodingが、あなたのものとは異なるユーザーにとっても必要です(@ref{Charset conversion}を参照してください)。

@cindex @code{locale} プログラム
localeのcharacter encodingは、シェルのコマンド@samp{locale
charmap}を実行して得ることができます。このコマンドの結果が@samp{C}や@samp{ANSI_X3.4-1968}の場合のcharacter
encodingは@samp{ASCII}(=@samp{US-ASCII})
となり、これはあなたのlocaleが正しく設定されていないことを意味します。そのような場合は、あなたの属するtranslation
teamに、どのcharset を使用すればよいのか尋ねてください。@samp{ASCII}は、Latin 以外の language
には適用できません。

@cindex encoding list
POファイルは、オペレーティングシステムの高度なインターナショナリゼーションの利便性に依存せずに可搬性を持たなければならないため、使用できるcharacter
encodingsは GNU @code{libc}と GNU
@code{libiconv}でサポートされるものに限定されています。使用できるcharacter
encodingは@code{ASCII}、@code{ISO-8859-1}、@code{ISO-8859-2}、@code{ISO-8859-3}、@code{ISO-8859-4}、@code{ISO-8859-5}、@code{ISO-8859-6}、@code{ISO-8859-7}、@code{ISO-8859-8}、@code{ISO-8859-9}、@code{ISO-8859-13}、@code{ISO-8859-14}、@code{ISO-8859-15}、@code{KOI8-R}、@code{KOI8-U}、@code{KOI8-T}、@code{CP850}、@code{CP866}、@code{CP874}、@code{CP932}、@code{CP949}、@code{CP950}、@code{CP1250}、@code{CP1251}、@code{CP1252}、@code{CP1253}、@code{CP1254}、@code{CP1255}、@code{CP1256}、@code{CP1257}、@code{GB2312}、@code{EUC-JP}、@code{EUC-KR}、@code{EUC-TW}、@code{BIG5}、@code{BIG5-HKSCS}、@code{GBK}、@code{GB18030}、@code{SHIFT_JIS}、@code{JOHAB}、@code{TIS-620}、@code{VISCII}、@code{GEORGIAN-PS}、@code{UTF-8}です。

@c This data is taken from glibc/localedata/SUPPORTED.
@cindex Linux
GNUシステムでは、対応する言語にたいして以下のエンコーディングが頻繁に使用されます。

@cindex encoding for your language
@itemize
@item @code{ISO-8859-1}: 
Afrikaans、Albanian、Basque、Breton、Catalan、Cornish、Danish、Dutch、English、Estonian、Faroese、Finnish、French、Galician、German、Greenlandic、Icelandic、Indonesian、Irish、Italian、Malay、Manx、Norwegian、Occitan、Portuguese、Spanish、Swedish、Tagalog、Uzbek、Walloon
@item @code{ISO-8859-2}: 
Bosnian、Croatian、Czech、Hungarian、Polish、Romanian、Serbian、Slovak、Slovenian
@item @code{ISO-8859-3}: Maltese
@item @code{ISO-8859-5}: Macedonian、Serbian
@item @code{ISO-8859-6}: Arabic
@item @code{ISO-8859-7}: Greek
@item @code{ISO-8859-8}: Hebrew
@item @code{ISO-8859-9}: Turkish
@item @code{ISO-8859-13}: Latvian、Lithuanian、Maori
@item @code{ISO-8859-14}: Welsh
@item @code{ISO-8859-15}: 
Basque、Catalan、Dutch、English、Finnish、French、Galician、German、Irish、Italian、Portuguese、Spanish、Swedish、Walloon
@item @code{KOI8-R}: Russian
@item @code{KOI8-U}: Ukrainian
@item @code{KOI8-T}: Tajik
@item @code{CP1251}: Bulgarian、Belarusian
@item @code{GB2312}、@code{GBK}、@code{GB18030}: 
Chineseの簡略表記
@item @code{BIG5}、@code{BIG5-HKSCS}: 
Chineseの伝統的表記
@item @code{EUC-JP}: Japanese
@item @code{EUC-KR}: Korean
@item @code{TIS-620}: Thai
@item @code{GEORGIAN-PS}: Georgian
@item @code{UTF-8}: 上記の言語を含む任意の言語
@end itemize

@cindex quote characters, use in PO files
@cindex quotation marks
あなたの言語の翻訳に、その言語の1重引用符か2重引用符が使用されており、そのlocaleのencodingが ISO-8859-*
のいずれかの場合は、POファイルはlocaleのencodingではなくUTF-8
encodingで作成するのが最善です。これはUTF-8では、ISO-8859-*が持っていない実際の引用文字(1重引用符はU+2018とU+2019、2重引用符はU+201CとU+201D)が表現可能だからです。UTF-8のlocale
のユーザーは実際の引用符文字列を見ることができますが、ISO-8859-*のlocaleでは垂直方向のアポストロフィーと垂直方向のダブルクォーテーションが(文字セットの変換により)代用で表示されます。

@cindex @code{xmodmap} program, and typing quotation marks
X11でこれらの引用文字を入力するために、xmodmapプログラムでキーボードのマッピングを使用することができます。この場合、X11
での引用文字の名前は"leftsinglequotemark"、"rightsinglequotemark"、"leftdoublequotemark"、"rightdoublequotemark"、"singlelowquotemark"、"doublelowquotemark"になります。

UTF-8 encodingは、新しいバージョンのGNU Emacsでだけサポートされていることに注意してください。たとえばEmacs 20 with
Mule-UCSやEmacs 21ではUTF-8 encodingがサポートされていますが、2001年1月時点のXEmacsではサポートされていません。

文字のエンコーディング名は、大文字または小文字で記述することができますが、通常は大文字が好まれます。

@item Content-Transfer-Encoding
@code{8bit}にセットしてください。

@item Plural-Forms
このフィールドはオプションで、POファイルにplural
formがあるときだけ必要です。これは@samp{msgid_plural}というキーワードを検索すればわかります。plural
formのフィールドの書式については@ref{Plural forms}と@ref{Translating plural
forms}を参照してください。
@end table

@node Updating
@chapter 既存のPOファイルの更新

@menu
* msgmerge Invocation::      Invoking the @code{msgmerge} Program
@end menu

@node msgmerge Invocation
@section @code{msgmerge}プログラムの呼び出し

@include msgmerge.texi

@node Editing
@chapter POファイルの編集
@cindex Editing PO Files

@menu
* KBabel::                   KDE's PO File Editor
* Gtranslator::              GNOME's PO File Editor
* PO Mode::                  Emacs's PO File Editor
* Compendium::               Using Translation Compendia
@end menu

@node KBabel
@section KDEのPOファイルエディター
@cindex KDE PO file editor

@node Gtranslator
@section GNOMEのPOファイルエディター
@cindex GNOME PO file editor

@node PO Mode
@section EmacsのPOファイルエディター
@cindex Emacs PO Mode

@c FIXME: Rewrite.

幸運にもあなたがEmacsのユーザーならば、POファイルの編集・変更のための快適な環境を提供するために特別に作成されたPOモードがあります。POファイルを編集するときPOモードを使えば、追加のPOファイルやcompendium
POファイルを閲覧したり、POファイルの元となるCプログラムのソースへの参照を追跡するのが簡単になります。またプログラム中の文字列にたいして対話的に翻訳可能のマークをつけたり、POファイルを検証してエラーのある行を再配置するための特別な機能があります。

POモードを使うにはまず、主要なPOモードのコマンド(@ref{Main PO
Commands}を参照してください)以外に、エントリー間の移動(@ref{Entry
Positioning}を参照してください)や、翻訳されていないエントリーの処理方法(@ref{Untranslated
Entries}を参照してください)を理解する必要があります。

@menu
* Installation::             Completing GNU @code{gettext} Installation
* Main PO Commands::         Main Commands
* Entry Positioning::        Entry Positioning
* Normalizing::              Normalizing Strings in Entries
* Translated Entries::       Translated Entries
* Fuzzy Entries::            Fuzzy Entries
* Untranslated Entries::     Untranslated Entries
* Obsolete Entries::         Obsolete Entries
* Modifying Translations::   Modifying Translations
* Modifying Comments::       Modifying Comments
* Subedit::                  Mode for Editing Translations
* C Sources Context::        C Sources Context
* Auxiliary::                Consulting Auxiliary PO Files
@end menu

@node Installation
@subsection GNU @code{gettext}のインストールを完了する

@cindex installing @code{gettext}
@cindex @code{gettext} installation
1度GNU @code{gettext}ディストリビューションを入手して解凍し、configure、コンパイルしてしまえば、@samp{make
install}コマンドで@code{xgettext}、@code{msgfmt}、@code{gettext}、@code{msgmerge}などのプログラムや、それらが利用できるメッセージのカタログを所定の場所に配置することができます。快適なインストールの締めくくりとして、EmacsのユーザーのためにPOモードを利用できるようにしましょう。

@emindex @file{.emacs} customizations
@emindex installing PO mode
POモードをインストールしているうちに、あなたは@file{.emacs}ファイルを修正して、以下のような行を追加したいと思うことでしょう:

@example
(setq auto-mode-alist
      (cons '("\\.po\\'\\|\\.po\\." . po-mode) auto-mode-alist))
(autoload 'po-mode "po-mode" "Major mode for translators to edit PO files" t)
@end example

こうしておけば以後、@file{.po}のようなファイルや、ファイル名に@samp{.po.}という文字列が含まれるファイルを編集するとき、Emacs
が必要に応じて@file{po-mode.elc}(または@file{po-mode.el})をロードして、割り当てられたバッファーにたいするPOモードのコマンドが自動的に利用可能になります。POモードがアクティブな任意のバッファーのモードラインには、@emph{PO}という文字が表示されます。単一のEmacsセッションで、1度に複数のPOファイルをアクティブにすることができます。

Emacsのバージョン20以上を使用していて、システムに適切なインターナショナルフォントがインストールされているなら、様々なPOファイルにたいして自動的にcoding
systemを決定する方法をEmacsに指定することもできます。これはEmacsのスクリーンに翻訳を表示する時にしばしば、必要なフォントがロードされ使用されるということです(常にではありませんが)。これを実現するためには、あなたの@file{.emacs}ファイルに以下の行を追加します:

@example
(modify-coding-system-alist 'file "\\.po\\'\\|\\.po\\."
                            'po-find-file-coding-system)
(autoload 'po-find-file-coding-system "po-mode")
@end example

@noindent
これでもまだinternationalなcharacterのかわりに四角が表示されるようなら、(Shiftキーを押しながらマウスボタン1をクリックして)違うフォントセットを試してみてください。

@node Main PO Commands
@subsection 主要なPOモードのコマンド

@cindex PO mode (Emacs) commands
@emindex commands
@ref{Installation}で説明されているような行を追加してEmacsを設定した後は、POファイルを検知するとEmacsがそのウィンドウにたいしてPOモードを有効にします。これによりそのウィンドウは読み取り専用となり、po-mode-mapが設定されます。これはテキストモードから継承されたのではなく、純粋なEmacsのモードです。もし@code{po-mode-hook}に指定された関数があれば、実行されます。

あるウィンドウにたいしてPOモードが有効になると、@samp{PO}という文字が、そのウィンドウのモードラインに表示されます。モードラインにはPOファイルに含まれている各種エントリーがいくつあるかも表示されます。たとえば@samp{132t+3f+10u+2o}という文字列が表示されている場合、POモードには132個の翻訳済みのエントリー(@ref{Translated
Entries}を参照してください)と、3個のfuzzyエントリー(@ref{Fuzzy
Entries}を参照してください)、それに10個の未翻訳のエントリー(@ref{Untranslated
Entries}を参照してください)と、2個の廃止されたエントリー(@ref{Obsolete
Entries}を参照してください)が含まれていることを翻訳者に示しています。この際、エントリーが0個のものは表示されません。この例にならうと、fuzzyエントリーが解消され、未翻訳のエントリーが翻訳され、廃止されたエントリーが削除されれば、モードラインには@samp{145t}だけが表示されることになります。

主要なPOコマンドの中には、以下のセクションのカテゴリー分けに適合しないものもあります。それらのコマンドとは、POモードやPOモードが管理するウィンドウを、特別な方法で終了する方法などです。

@table @kbd
@item _
@efindex _@r{, PO Mode command}
POファイルにたいする最後の変更を取り消します(@code{po-undo})。

@item Q
@efindex Q@r{, PO Mode command}
処理を終了してPOファイルを保存します(@code{po-quit})。

@item q
@efindex q@r{, PO Mode command}
問い合わせの後に処理を終了します(@code{po-confirm-and-quit})。

@item 0
@efindex 0@r{, PO Mode command}
一時的にPOファイルのウィンドウを離れます(@code{po-other-window})。

@item ?
@itemx h
@efindex ?@r{, PO Mode command}
@efindex h@r{, PO Mode command}
POモードのヘルプを表示します(@code{po-help})。

@item =
@efindex =@r{, PO Mode command}
POファイルに関する統計情報を取得します(@code{po-statistics})。

@item V
@efindex V@r{, PO Mode command}
POファイル全体のフォーマットを検証します(@code{po-validate})。

@end table

@efindex _@r{, PO Mode command}
@efindex po-undo@r{, PO Mode command}
@kbd{_}コマンド(@code{po-undo})は、Emacsの@emph{undo}機能と連携します。@ref{Undo, , Undoing
Changes, emacs, The Emacs
Editor}を参照してください。@kbd{_}を入力する度に、翻訳者がPOファイルにたいして行った変更が少しずつ取り消されていきます。取り消し機能を実現するために、POモードのコマンドはアトミックになっています。これは特に@kbd{@key{RET}}コマンドにたいして当てはまります。このコマンドを使用して行った1度の変更は、編集がいくつかの操作により行われたものだったとしても、1度の取り消しで元に戻ります。しかし編集中のウィンドウでは、作業をより小さい単位で取り消すことができます。

@efindex Q@r{, PO Mode command}
@efindex q@r{, PO Mode command}
@efindex po-quit@r{, PO Mode command}
@efindex po-confirm-and-quit@r{, PO Mode command}
@kbd{Q}コマンド(@code{po-quit})と、@kbd{q}コマンド(@code{po-confirm-and-quit})は、翻訳者がPOファイルにたいする作業を終了するときに使用します。後者のコマンドは前者のコマンドに比べると冗長なコマンドです。ファイルが変更されていた場合、まずディスクにファイルが保存されます。ファイルが変更されていない場合でも、コマンドはまずPOファイルに未翻訳のメッセージが残されていないかをチェックして、もしそのようなメッセージが残っていた場合、翻訳者は本当にこのPOファイルにたいする作業を終了したいのか尋ねられます。これはEmacsのPOファイルにたいするバッファーを離れるときに望ましい方法です。単にバッファーをkillする通常の@w{@kbd{C-x
k}}コマンド(@code{kill-buffer}))は、好ましい方法ではありません。

@efindex 0@r{, PO Mode command}
@efindex po-other-window@r{, PO Mode command}
@kbd{0}コマンド(@code{po-other-window})は、POモードを一時的に離れるときに使用する、よりソフトな方法です。このコマンドはカーソルをEmacsの他のウィンドウに移動して、他のウィンドウを表示します。たとえば翻訳者が、メッセージのソース文脈中での箇所を探して、ソースのバグを修正するためだけにPOモードを開いている場合などに使用します。このコマンドにより翻訳者たる彼女は、プログラマーたる@emph{彼}へと性転換を遂げ、修正したいプログラムを表示しているウィンドウにカーソルを移すことができます。後でPOファイルのウィンドウにカーソルを戻すか、このファイルをもう一度編集するかをEmacsに指定した時に、POモードが復元されます。

@efindex ?@r{, PO Mode command}
@efindex h@r{, PO Mode command}
@efindex po-help@r{, PO Mode command}
@kbd{h}コマンド(@code{po-help})は、POモードで利用可能なすべてのコマンドの要約が表示されます。翻訳者が任意の文字を入力することにより、通常のPOモードの操作に戻ることができます。@kbd{?}コマンドでも、@kbd{h}コマンドと同じ結果を得ることができます。

@efindex =@r{, PO Mode command}
@efindex po-statistics@r{, PO Mode command}
@kbd{=}コマンド(@code{po-statistics})は、POファイルのすべてのエントリーを集計し、現在のエントリーが先頭から数えて何番目かと、未翻訳のエントリー数、廃止されたエントリー数等のすべての数を表示します。

@efindex V@r{, PO Mode command}
@efindex po-validate@r{, PO Mode command}
@kbd{V}コマンド(@code{po-validate})は、@code{msgfmt}のverbose
modeにより、編集中のPOファイルをチェックします。このコマンドは最初に編集中のPOファイルをディスクに保存します。GNU
@code{gettext}の@code{msgfmt}は、POファイルの出力としてMOファイルを生成するツールで、POモードがPOファイル全体の書式や個々のエントリーの書式をチェックするのに、このプログラムの機能が使用されています。

@efindex next-error@r{, stepping through PO file validation results}
@code{msgfmt}プログラムはEmacsと非同期で実行されるので、POファイルの評価が終わっていなくても、制御はすぐに翻訳者に戻されます。標準エラー出力への出力はEmacsにより収集されて、他のウィンドウの@samp{*compilation*}バッファーに表示されます。Emacsの通常コマンドの@kbd{C-x`}(@code{next-error})や、その他の同様のコンパイル時のコマンドにより、翻訳者は素早くPOファイル中の提示された位置に移動することができます。カーソルがエラーのある行に移動すると、翻訳者がエラーを修正するためのPOモードのコマンドを選択することができます。

@node Entry Positioning
@subsection エントリーの決定

@emindex current entry of a PO file
POファイルのウィンドウの中のカーソルは、ほとんど常にエントリ一部となります。唯一の例外は、カーソルがファイルの最後のエントリーの後ろにあったり、POファイルが空だったりという、特別なケースのときだけです。カーソルのある位置のエントリーのことを、カレントエントリーと呼びます。POモードのコマンドの多くは、カレントエントリーにたいして操作を行うので、翻訳者にとってカーソルを動かすことはPOファイルを閲覧できるだけでなく、エントリーに作用するコマンドの対象エントリーを選択することでもあるのです。

@emindex moving through a PO file
POモードのコマンドには、特別な方法によりカーソルの位置を変更するものがあります。それらの特別な目的に対応する位置へカーソルを動かす方法については、ここで説明します。他の方法については、以降のセクションで説明します(@kbd{C-h
m}で完全な一覧を得ることもできます)。

@table @kbd

@item .
@efindex .@r{, PO Mode command}
カレントエントリーを再表示します(@code{po-current-entry})。

@item n
@efindex n@r{, PO Mode command}
カレントエントリーの次のエントリーを選択します(@code{po-next-entry})。

@item p
@efindex p@r{, PO Mode command}
カレントエントリーの前のエントリーを選択します(@code{po-previous-entry})。

@item <
@efindex <@r{, PO Mode command}
POファイルの最初のエントリーを選択します(@code{po-first-entry})。

@item >
@efindex >@r{, PO Mode command}
POファイルの最後のエントリーを選択します(@code{po-last-entry})。

@item m
@efindex m@r{, PO Mode command}
後で利用できるように、現在のエントリーの場所を記録します(@code{po-push-location})。

@item r
@efindex r@r{, PO Mode command}
以前に記録したエントリーの場所に戻ります(@code{po-pop-location})。

@item x
@efindex x@r{, PO Mode command}
現在のエントリーの場所と、以前に記録したエントリーの場所を交換します(@code{po-exchange-location})。

@end table

@efindex .@r{, PO Mode command}
@efindex po-current-entry@r{, PO Mode command}
Emacsのカーソル位置を変更するための、文字、行、paragraph、画面単位での移動や検索などのコマンドは、POモードでカレントエントリを選択するのに使用できます。しかしPOモードには、通常のEmacsでカーソルを移動するコマンドには無いような、カレントエントリーを表示するための標準的な方法があります。@kbd{.}コマンド(@code{po-current-entry})は、Emacsの画面が変更されたときなどPOモード以外の方法やでカレントエントリーが変更された時に、カレントエントリーを適切に再表示するという単一の目的のためのコマンドです。

翻訳者が作業をしているときに、POモードによりウィンドウ配置を厳格に強制されることが、彼女を助けるものなのか、それともイライラさせるものなのかは未だ不明です。私たちは当初、ウィンドウがどのように振る舞うべきかについて明確なアイデアを持っていました。しかしその一方で、Emacsを使うとき自分で完全にコントロールできるほうを好む人もいます。固定されたウィンドウ配置は、翻訳者が有効・無効を選択できるようにPOモードのオプションとして、実験的な機能として提供されるべきでしょう。もしこの機能を使う必要性や、記述する衝動をもつ人がだれもいないなら、私たちはこのアイデアを放棄するべきなのでしょう。これを行うには、プログラマーよりも翻訳者からの動機が必要です。私にとって、経験を積んだ翻訳者の意見は、他者がどうやって翻訳するか想像するしかないプログラマーの意見にくらべて、より価値があるからです。

@efindex n@r{, PO Mode command}
@efindex po-next-entry@r{, PO Mode command}
@efindex p@r{, PO Mode command}
@efindex po-previous-entry@r{, PO Mode command}
@kbd{n}コマンド(@code{po-next-entry})と@kbd{p}コマンド(@code{po-previous-entry})は、カーソルをカレントエントリーの前または後のエントリーに移動します。POファイルの最後のエントリーにカーソルがあるときに@kbd{n}を押したり、最初のエントリーにカーソルがあるときに@kbd{p}を押しても、移動は行われません。

@efindex <@r{, PO Mode command}
@efindex po-first-entry@r{, PO Mode command}
@efindex >@r{, PO Mode command}
@efindex po-last-entry@r{, PO Mode command}
@kbd{<}コマンド(@code{po-first-entry})と@kbd{>}コマンド(@code{po-last-entry})は、POファイルの最初のエントリー、または最後のエントリーにカーソルを移動します。POモードのほとんどのコマンドは、POファイルの最後のエントリー以降にカーソルがあるときは、@samp{After
last
entry}のようなエラーを戻します。@kbd{<}コマンドと@kbd{>}コマンドは、カーソルがPOファイルのエントリーにない場合でも動作する特性があるので、このような状況をうまく解決するのに使う人もいます。しかしこれらのコマンドも、POファイルが空の場合は失敗します。ソースから対話的に空のPOファイルにエントリーを追加していくようにPOモードを開発するプランもあります。@ref{Marking}を参照してください。

翻訳者が特定のエントリーを翻訳する前には、そのエントリーに関連する用語や言い回しを探すために、POファイルの残りの部分を参照する必要があるかもしれません。もちろん彼女はEmacsの標準的な慣例にしたがって、カレントカーソルの位置をレジスターなどに保存して、後でその場所に戻るのにそのレジスターを使ったり、場所を記憶するためのリングバッファーを使うこともできます。

@efindex m@r{, PO Mode command}
@efindex po-push-location@r{, POモードのコマンド}
@efindex r@r{, PO Mode command}
@efindex po-pop-location@r{, PO Mode command}
これらの方法にたいして、POモードは特別なスタックにカーソルの場所を保存するという、別の方法を提供します。@kbd{m}コマンド(@code{po-push-location})は、スタック上に既に保存してあるカーソル位置の情報の上に、カレントエントリーをpushします。@kbd{r}コマンド(@code{po-pop-location})は、スタックの最上部の要素をpopして、カーソルをその要素に関連付けられた位置へと移動します。これによりpopされた要素の位置情報は失われ、次の@kbd{r}コマンドでは、その要素の1つ前に保存された位置にカーソルが移動します。これはスタックに保存された位置の情報がなくなるまで同じように動作します。

翻訳者がスタックの最上位の要素に関連付けられているエントリーの位置を確認してから他の場所に移動して、後で元の場所に戻る等の理由で、エントリーの場所をスタックに保存したいとき、彼女は@kbd{r}の直後に@kbd{m}を使うべきです。

@efindex x@r{, PO Mode command}
@efindex po-exchange-location@r{, PO Mode command}
@kbd{x}コマンド(@code{po-exchange-location})は、カーソルをスタックの最上位の要素に関連付けられた位置に再配置すると同時に、移動する前のカレントエントリーの位置を最上位の要素に保存します。つまり、@kbd{x}コマンドを繰り返し使うと、それら2つのエントリーを行き来することができます。これを行うにはまず、最初のエントリーにカーソルを移動してから@kbd{m}コマンドを使用し、その後2番目のエントリーで@kbd{x}コマンドを使えば、2つのエントリー間を行き来することができます。

@node Normalizing
@subsection エントリー内の文字列の正規化
@cindex string normalization in entries

特定の文字列をPOファイルのエントリーにエンコードする場合、複数行を分割したり括ったりする方法、さらには特殊な文字をバックスラッシュでエスケープする方法までもが異なっている等、とても多くの方法があります。POモードには、特定のエンコードの文字列を@code{msgid}フィールドに挿入するために、既存のPOファイルをスキャンする機能があります。POモードにはこれらを簡単に認識するためのビルトイン機能が内部的に存在しますが、これを高速に行うのは技術的に困難です。この効率に関する問題の解決を容易にするために、わたしたちは文字列の正規表現を採択しました。

POファイル内の文字列の標準的な表現方法については現在も議論されていますが、POモードでは正規表現を実験的に採用しています。@code{xgettext}とPOモードで、同じ文字列を統一された方法で表示するのは、POモードで必要となる内部的な正規化が、GNU
@code{gettext}からの@code{xgettext}の使用をも自動的に満たすので便利なのです。明示的なPOモードの正規化は、POファイルが他の場所からインポートされたときや、慣例そのものが変更されたときに必要です。

正規表現が必要なPOファイルの文字列を正規化するために、以下のPOモードのコマンドが利用可能です:

@emindex string normalization in entries
@table @kbd
@item M-x po-normalize
@efindex po-normalize@r{, PO Mode command}
エントリーをより標準化することにより、PO ファイル全体を整理します。

@end table

特別なコマンドである@kbd{M-x
po-normalize}コマンド(キーは関連付けられていません)は、未翻訳のエントリーおよび翻訳済みのエントリー両方を、POファイル内部の標準的な引用符で括って、すべてのエントリーを修正します。このコマンドは最後のエントリーより後ろにあるゴミも削除します。このコマンドは、他の場所からインポートしたPOファイルを新たにインポートするときや、わたしたち自身がこの正規化された引用書式を改善していけるならば、有用となるでしょう。この正規化された書式はPOファイルを整理するだけでなく、ほかのPOモードのコマンドが@code{msgid}から文字列を検索する処理のスピードを大幅に改善します。

@kbd{M-x
po-normalize}は、エントリーにたいして3パスの処理を行います。最初のパスで、複数行の@code{msgid}と@code{msgstr}に、K&R
CスタイルのC文字列書式を使用しているGNU @code{gettext}
0.6以前のPOファイルを発見して変換します。この発見的な処理は、廃止されたエントリーに関連付けられておらず、バックスラッシュで終端されたコメントでは失敗します。これは後続のパスで、廃止されたコメントに続くコメントを完成させる処理に依存します。この最初のパスは、すべての古いPOファイルの調整後は行われません。2番目と3番目のパスでは、すべての@code{msgid}と@code{msgstr}の文字列を、それぞれ正規化していきます。これらのパスではXViewの@code{msgfmt}の継続行のためのバックスラッシュも除去します。

@cindex importing PO files
このように明示的に正規化を指定するコマンドは、他のソースからPOファイルをインポートするときだけではなく、現在使われている慣用句や美的観点による改善を容易にします。正規化コマンドで提案された調整を後で行うのは簡単で、最終的には他のGNU
@code{gettext}ツールも、この適合を自動化する必要があります。Emacsを持っていないが、それでもPOファイルを上手に手作りしたい人のために、以下では正規化された文字列の書式を説明します。

@cindex multi-line strings
POモードの文字列は単一行か複数行になります。文字列内に@emph{埋め込まれた}改行が存在するとき、すなわち@samp{[^\n]\n+[^\n]}というパターンにマッチする文字列は複数行になります。例えば以下のような文字列があったとします:

@example
msgstr "\n\nHello, world!\n\n\n"
@end example

この文字列の空白を改行に置き換えると、以下のような文字列になります:

@example
msgstr ""
"\n"
"\n"
"Hello,\n"
"world!\n"
"\n"
"\n"
@end example

ここでは問題点を明確にするために、カリカチュアーされた例を使用して議論していきます。通常、複数行の体裁は悪いものではありません。これを処理するための実装は多分、次のような提言にしたがったものになるでしょう。すべての改行、および空行を表す改行を空文字列の中にまとめます(@w{@var{n}
> 1}から@var{n}-1番目の改行は文字列を区切る改行です)。これにより文字列は以下のようになります:

@example
msgstr "\n\n"
"Hello,\n"
"world!\n"
"\n\n"
@end example

文字列の初期化に関しては、まだ未解決の点もあります。これらの問題については、解決されたものからこのドキュメントに記載されるでしょう。

@node Translated Entries
@subsection 翻訳済みのエントリー
@cindex translated entries

POファイル中のエントリーの@code{msgstr}が翻訳されて、fuzzy(@ref{Fuzzy
Entries}を参照してください)もマークされていない場合、そのエントリーを翻訳済みのエントリーと呼びます。以後の処理では、翻訳済みのエントリーだけがGNU
@code{msgfmt}でコンパイルされて、プログラムで利用できるようになります。他の種類のエントリーは除外され、それらにたいする翻訳は出力されません。

@emindex moving by translated entries
翻訳済みのエントリーを処理するためのコマンドがいくつかあります。

@table @kbd
@item t
@efindex t@r{, PO Mode command}
次の翻訳済みエントリーを検索します(@code{po-next-translated-entry})。

@item T
@efindex T@r{, PO Mode command}
前の翻訳済みのエントリーを検索します(@code{po-previous-translated-entry})。

@end table

@efindex t@r{, PO Mode command}
@efindex po-next-translated-entry@r{, PO Mode command}
@efindex T@r{, PO Mode command}
@efindex po-previous-translated-entry@r{, PO Mode command}
@kbd{t}コマンド(@code{po-next-translated-entry})と@kbd{T}コマンド(@code{po-previous-translated-entry})は、翻訳済みのエントリーを見つけて、前方または後方に移動するためのコマンドです。翻訳済みのエントリーが見つからなかった場合、POファイルのバッファーの先頭または終端に戻って検索します。

@evindex po-auto-fuzzy-on-edit@r{, PO Mode variable}
翻訳済みのエントリーは通常、翻訳者が翻訳を編集した結果です。@ref{Modifying
Translations}を参照してください。ただし変数@code{po-auto-fuzzy-on-edit}が@code{nil}でない場合、新しく翻訳されたエントリーは、公式な翻訳となる前に、最初はfuzzyエントリーになります。この場合、後でこのfuzzyエントリーのfuzzyを解消して、正式な翻訳済みのエントリーにする必要があります。@ref{Fuzzy
Entries}を参照してください。

@node Fuzzy Entries
@subsection fuzzyエントリー
@cindex fuzzy entries

@cindex attributes of a PO file entry
@cindex attribute, fuzzy
POファイルのエントリーは、一連の@dfn{属性}を持っています。それらは名前から得られるような性質をもち、翻訳に関するシステムコメントを明示するために使用されます。その属性1つが@code{fuzzy}で、この属性をもつエントリーがfuzzy(あいまいな)な翻訳であることを示します。この属性がつけられたエントリーのことを、fuzzyエントリーと呼びます。

通常fuzzyエントリーは、おおよそ目的にあった翻訳であるような翻訳済みエントリーにたいして、翻訳者が見直しのために使用するものです。これらのfuzzyエントリーは、古い翻訳済みのPOファイルを新しいPOテンプレートファイルに対応して更新するために、@code{msgmerge}プログラムを適用することにより生成されることもあり、それはこのツールが、新しい@code{msgid}が、古いものをわずかに修正したものであって、新しい修正されたエントリーに古い翻訳を選択できると推測したときです。元の文字列(@code{msgid}文字列)にたいするわずかな変更は、翻訳にも影響を与える場合があり、これは翻訳者による判断が必要です。あるエントリーにたいして@code{msgmerge}がfuzzyのマークを付与するのには、このような理由があるのです。

@emindex moving by fuzzy entries
翻訳者が後で再検討する必要があるエントリーを覚えておくために、彼女自身の都合でエントリーをfuzzyとすることもあります。したがって特にfuzzyエントリーを処理するためのコマンドが、いくつかあります。

@table @kbd
@item f
@efindex f@r{, PO Mode command}
@c better append "-entry" all the time. -ke-
次のfuzzyエントリーを検索します(@code{po-next-fuzzy-entry})。

@item F
@efindex F@r{, PO Mode command}
前のfuzzyエントリーを検索します(@code{po-previous-fuzzy-entry})。

@item @key{TAB}
@efindex TAB@r{, PO Mode command}
カレントエントリーのfuzzy属性を取り除きます(@code{po-unfuzzy})。

@end table

@efindex f@r{, PO Mode command}
@efindex po-next-fuzzy-entry@r{, PO Mode command}
@efindex F@r{, PO Mode command}
@efindex po-previous-fuzzy-entry@r{, PO Mode command}
@kbd{f}コマンド(@code{po-next-fuzzy-entry})と@kbd{F}コマンド(@code{po-previous-fuzzy-entry})は、前方もしくは後方のfuzzyエントリーに移動します。fuzzyエントリーが見つからなかった場合、PO
ファイルのバッファーの先頭または終端に戻って検索します。

@efindex TAB@r{, PO Mode command}
@efindex po-unfuzzy@r{, PO Mode command}
@evindex po-auto-select-on-unfuzzy@r{, PO Mode variable}
@kbd{@key{TAB}}コマンド(@code{po-unfuzzy})は、エントリーに付与されているfuzzy属性を取り除いて、通常は翻訳済みのエントリーとします。さらに、変数@code{po-auto-select-on-unfuzzy}が@code{nil}でない場合には、@kbd{@key{TAB}}コマンドにより自動的に他の対象となるエントリーに移動します。@code{po-auto-select-on-unfuzzy}の初期値は@code{nil}
です。

@code{po-auto-fuzzy-on-edit}の初期値は@code{nil}です。しかし変数@code{po-auto-fuzzy-on-edit}に@code{t}をセットすると、@kbd{@key{RET}}コマンドで編集したエントリーは、後から再チェックなどができるようにfuzzyとマークされます。この場合、通常の使用法では、翻訳者が変更したエントリーは、(すでにfuzzy
だった場合をのぞき)fuzzyエントリーに変更されることになります。彼女が翻訳に満足した場合、@kbd{@key{TAB}}を使えばfuzzy属性をクリアーするとともに、他のエントリーへと移動することができます。まだ翻訳が不十分だと思ったときは、@kbd{@key{SPC}}を使えばfuzzy属性を保持したまま他のエントリーに移動することができます。

@efindex DEL@r{, PO Mode command}
@efindex po-fade-out-entry@r{, PO Mode command}
翻訳者が作業中のエントリーを後で見直したいようなときに見つけやすいように、翻訳済みのエントリーをfuzzyとマークする場合は、@kbd{@key{DEL}}コマンド(@code{po-fade-out-entry})を使うこともできます。

翻訳者が作業を終えてPOファイルのバッファーを@kbd{q}コマンドで閉じるとき、まだfuzzyエントリーが残っている場合は、終了してもよいか確認を求められます。

@node Untranslated Entries
@subsection 未翻訳エントリー
@cindex 未翻訳エントリー

@code{xgettext}で元となるPOファイルを作成する場合には、@code{msgid}は未翻訳の文字列で初期化され、@code{msgstr}には空文字列がセットされます。このように翻訳に空文字列がセットされているエントリーのことを、@dfn{未翻訳(untranslated)}のエントリーと呼びます。プログラマーがプログラム内の文字列に変更を加えた場合、変更された文字列にたいする新しい未翻訳のエントリーとしてPOファイル中に現れることになります。

未翻訳のエントリーにたいしても、有効なエントリー間の移動に通常使用するコマンドと同様のレベルで考えることができます。未翻訳のエントリーは、最後に@w{@samp{msgstr
""}}があるので、容易に識別できます。

@emindex moving by untranslated entries
翻訳者の作業は(非常に簡単に表現するならば)、未翻訳のエントリーを探して編集・翻訳して、未翻訳のエントリーがなくなるまでそれを繰り返していくことではないでしょうか。特に未翻訳のエントリーを処理するためのコマンドが、いくつかあります。

@table @kbd
@item u
@efindex u@r{, PO Mode command}
次の未翻訳のエントリーを検索します(@code{po-next-untranslated-entry})。

@item U
@efindex U@r{, PO Mode command}
前の未翻訳のエントリーを検索します(@code{po-previous-untransted-entry})。

@item k
@efindex k@r{, PO Mode command}
カレントエントリーを未翻訳にします(@code{po-kill-msgstr})。

@end table

@efindex u@r{, PO Mode command}
@efindex po-next-untranslated-entry@r{, PO Mode command}
@efindex U@r{, PO Mode command}
@efindex po-previous-untransted-entry@r{, PO Mode command}
@kbd{u}コマンド(@code{po-next-untranslated-entry})と@kbd{U}コマンド(@code{po-previous-untransted-entry})は、前方もしくは後方の未翻訳のエントリーに移動します。未翻訳のエントリーが見つからなかった場合、POファイルのバッファーの先頭または終端に戻って検索します。

@efindex k@r{, PO Mode command}
@efindex po-kill-msgstr@r{, PO Mode command}
@kbd{k}コマンド(@code{po-kill-msgstr})は、単に翻訳された文字列を空文字列にすることによって、エントリーを未翻訳のエントリーにするコマンドです。@ref{Modifying
Translations}を参照してください。

翻訳者が作業を終えてPOファイルのバッファーを@kbd{q}コマンドで閉じるとき、まだ未翻訳のエントリーが残っている場合は、終了してもよいか確認を求められます。

@node Obsolete Entries
@subsection 陳腐化したエントリー
@cindex obsolete entries

POファイルの@dfn{陳腐化}したエントリーとは、@code{msgmerge}によりローカライズされるパッケージ内で、その翻訳がもはや必要ないのでコメントアウトされているエントリーのことです。

陳腐化したエントリーにたいしても、有効なエントリー間の移動に通常使用するコマンドと同様のレベルで考えることができます。行に@code{msgid}や@code{msgstr}が含まれているか否かに関係なく、行が@code{#}で開始されているという事実により、陳腐化したエントリーを識別できます。

再初期化するために翻訳を空文字列に置き換えて、元の未翻訳の空文字列にするコマンドがあります。これらのコマンドはEmacsのkillリングと互換性があるので、以前にkillリングに保存された文字列を翻訳として挿入することもできます。またユーザーは翻訳を対話的に編集することができます。これらすべてのコマンドは廃止されたエントリーの編集にも適用できますが、エントリーは廃止された状態のままになります。

@emindex moving by obsolete entries
陳腐化したエントリーに特化したコマンドがいくつかあります。

@table @kbd
@item o
@efindex o@r{, PO Mode command}
次の陳腐化エントリーを検索します(@code{po-next-obsolete-entry})。

@item O
@efindex O@r{, PO Mode command}
前の陳腐化したエントリーを検索します(@code{po-previous-obsolete-entry})。

@item @key{DEL}
@efindex DEL@r{, PO Mode command}
有効なエントリーにたいしては、それを陳腐化したエントリーにします。陳腐化したエントリーの場合は、エントリーを削除します(@code{po-fade-out-entry})。

@end table

@efindex o@r{, PO Mode command}
@efindex po-next-obsolete-entry@r{, PO Mode command}
@efindex O@r{, PO Mode command}
@efindex po-previous-obsolete-entry@r{, PO Mode command}
@kbd{o}コマンド(@code{po-next-obsolete-entry})と@kbd{O}コマンド(@code{po-previous-obsolete-entry})は、前方もしくは後方の陳腐化したエントリーに移動します。陳腐化したエントリーが見つからなかった場合、POファイルのバッファーの先頭または終端に戻って検索します。

PO
モードには、陳腐化したエントリーにたいして、そのエントリーを非コメント化することにより有効なエントリーにする方法は用意されていません。用意されていない理由は、元となる未翻訳の文字列と、プログラム中の文字列の対応をとることができなくなるからで、これは
msgid 駆動の哲学と反するからです。

@efindex DEL@r{, PO Mode command}
@efindex po-fade-out-entry@r{, PO Mode command}
@emindex obsolete active entry
@emindex comment out PO file entry
とはいえ有効なエントリーをコメントアウトして、陳腐化したエントリーとすることは可能です。後でGNU
@code{gettext}ユーティリティーが処理するとき、翻訳が見つからなければ未翻訳の文字列が使用されます。@kbd{@key{DEL}}コマンド(@code{po-fade-out-entry})は、カレントエントリーを消滅の方向へと押しやるコマンドです。有効なエントリー(翻訳されたエントリー)の場合には、そのエントリーをfuzzyエントリーにします。すでにfuzzyエントリーの場合には、確認後にそのエントリーをコメントアウトします。すでに廃止されたエントリーの場合には、そのエントリーをPOファイルから削除します。削除した翻訳を、他のPOファイルの、(通常は)未翻訳のエントリに再使用するのは簡単です。@ref{Modifying
Translations}を参照してください。

今後POモードを開発していく上で、あなたを寝不足とさせるような、解決すべき興味深い問題が存在します。POモードをよりよくするこのアイデアとは、新しく出現した文字列にたいする翻訳として、すべての陳腐化したエントリーの中から最適な候補を推測することです。これはアルゴリズム的に解決するには困難な問題であり、文字列の相似をより効果的に計測するための開発を行う必要があると私は考えています。現在ではこれらの作業は翻訳者がすべて決定しなければなりませんが、いつの日か陳腐化したエントリーから翻訳を検索することができる便利なツールを提供できるように努力しています。

@node Modifying Translations
@subsection 翻訳の修正
@cindex editing translations
@emindex editing translations

POモードは、通常Emacsのバッファーを変更するような方法でPOファイルを直接編集することを防ぎます。そうすることで、直接編集してファイル全体のフォーマットや文字列の引用符を誤って編集してしまう等の、容易に発生し得るエラーを防ぎます。他の種類のエラーもありますが、それらのエラーは翻訳者が@kbd{V}コマンドを使っていつでも、バッチ検証プロセスにより発見・診断することができます。その他のエラーについては、翻訳者自身の判断と、彼女が翻訳したパッケージにたいする同じ母国語ユーザーによる、言語的な判定に頼る必要があります。

翻訳を作成し、機械的な診断およびユーザーによる報告を経た後、翻訳者は以下のコマンドを使って翻訳を変更します。

@table @kbd
@item @key{RET}
@efindex RET@r{, PO Mode command}
翻訳を対話的に編集します(@code{po-edit-msgstr})。

@item @key{LFD}
@itemx C-j
@efindex LFD@r{, PO Mode command}
@efindex C-j@r{, PO Mode command}
翻訳を元の未翻訳の文字列で再初期化します(@code{po-msgid-to-msgstr})。

@item k
@efindex k@r{, PO Mode command}
翻訳をkillリングに保存してから、削除します(@code{po-kill-msgstr})。

@item w
@efindex w@r{, PO Mode command}
翻訳をkillリングに保存するだけで、削除はしません(@code{po-kill-ring-save-msgstr})。

@item y
@efindex y@r{, PO Mode command}
翻訳をkillリングのもので置き換えます(@code{po-yank-msgstr})。

@end table

@efindex RET@r{, PO Mode command}
@efindex po-edit-msgstr@r{, PO Mode command}
@kbd{@key{RET}}コマンド(@code{po-edit-msgstr})は、新しい翻訳を編集したり既存の翻訳を変更するための、新しいEmacsのウィンドウをオープンします。新しいウィンドウにはPOファイルのカレントエントリーの、翻訳のコピーが含まれています。翻訳のコピーは、すぐに編集できるように引用符を除かれていて、Emacsによる編集コマンドのすべてが使用できます。翻訳者が文字列の変更を終えたら、@w{@kbd{C-c
C-c}}により、自動的に引用符を付加した形式で結果を保存し、編集用のサブウィンドウを閉じることができます。変更を保存せずに取り消す場合には、@w{@kbd{C-c
C-k}}を使用してください。詳細は、@ref{Subedit}を参照してください。

@efindex LFD@r{, PO Mode command}
@efindex C-j@r{, PO Mode command}
@efindex po-msgid-to-msgstr@r{, PO Mode command}
@kbd{@key{LFD}}コマンド(@code{po-msgid-to-msgstr})は、翻訳を元の文字列で初期化します。このコマンドは通常、翻訳者が以前の作業を破棄して、元の文字列にたいして新しく翻訳をやり直したいときに使用します。

@evindex po-auto-edit-with-msgid@r{, PO Mode variable}
未翻訳のエントリーを編集するときに、常に@kbd{@key{LFD}}コマンドを自動的に実行させることもできます。@code{po-auto-edit-with-msgid}に@code{t}をセットすれば、翻訳に何も文字列が設定されていない場合には、元の文字列により翻訳が初期化されます。デフォルトでは@code{po-auto-edit-with-msgid}は@code{nil}です。

@emindex starting a string translation
実際のところ、空の文字列から翻訳を開始するのか、それとも元の文字列のコピーから翻訳を開始するのかは好みの問題です。元の言語と、翻訳する言語があまりに異なっている場合には、単に空の文字列から開始するのがよいでしょう。その反対に元の言語と翻訳する言語が似ている場合には、元の文字列の数字や文字を再入力する手間を省きたいときもあるでしょう。未翻訳の余分な元文字列を取り除く手間がかかるとしても、彼女は元の文字列を見ながら未翻訳の文字列を翻訳で上書きしていく方法を好むかもしれません。

@emindex cut and paste for translated strings
@efindex k@r{, PO Mode command}
@efindex po-kill-msgstr@r{, PO Mode command}
@efindex w@r{, PO Mode command}
@efindex po-kill-ring-save-msgstr@r{, PO Mode command}
これにより、空文字列になる前の内容は、killリングと呼ばれる特別な場所に置かれます。wコマンド(po-kill-ring-save-msgstr)も、翻訳をkillリングにコピーする効果に違いはありませんが、エントリーをそのままにする点が異なります。この場合、エントリーから翻訳は削除されません。どちらのコマンドも、Emacs愛好家にはよく知られている共有バッファーである、Emacsのkillリングを使用します。

翻訳者は作業する過程で、@kbd{k}や@kbd{w}を多く使うことでしょう。それにともないkillリングには翻訳が保存されていきます。killリングに保存された文字列は、後でEmacsの他のバッファーに挿入することができます。killリングは、単一のPOファイル内の異なるエントリー間だけではなく、翻訳者がPOファイルを複数開いている場合は、異なるPOファイル間で翻訳文字列を移動するのに使用されます。

POモードではないバッファーと文字列をやりとりするのを容易にするために、@kbd{k}コマンドでkillリングに置かれた翻訳文字列は、引用符が取り除かれて保存されます。すなわち、文字列を囲うための引用符は取り除かれ、複数行の文字列は結合され、バックスラッシュでエスケープされた文字は対応する実際の文字に変換されます。陳腐化したエントリーの場合、保存される前に翻訳は非コメント化されます。

@efindex y@r{, PO Mode command}
@efindex po-yank-msgstr@r{, PO Mode command}
@kbd{y}コマンド(@code{po-yank-msgstr})は、カレントエントリーの翻訳をkillリングの文字列で完全に置き換えます。Emacsの用語にしたがうと、置き換えた文字列は、PO
ファイルのバッファーへ@dfn{yank(yanked)}されたといいます。@ref{Yanking, , , emacs, The Emacs
Editor}を参照してください。最初に@kbd{y}を使用したときは、killリングに最後に追加された値が翻訳として戻されます。他のキーを押さずに、もう一度@kbd{y}をタイプすると、killリングの最後から2番目に追加された文字列が、翻訳として挿入されます。@kbd{y}を何度も繰り返すことにより、望む文字列が見つかるまで、killリングに保存された文字列を巡回することができます。

文字列がPOファイルのエントリーにyankされるときには、自動的にPOファイルの書式にしたがった形式の引用符が付与されます。さらに陳腐化したエントリーの場合には、文字列は適切にコメント化されます。プログラムが使用できるように、翻訳された個々の文字列に引用符を付与するために、翻訳者が患わされることはありません。

@kbd{k}と@kbd{w}だけが、文字列をkillリングに保存するコマンドではないことに注意してください。POモードの多くのコマンドは、翻訳された文字列(または翻訳者のコメント)を置き換えて、自動的にリングに保存します。この一般的なルールに当てはまらないコマンドは、yankコマンド自身です。

@emindex using obsolete translations to make new entries
文字列のkillとyankについては、一般的な状況の実例で説明したほうがよいでしょう。プログラマーが文字列にちょっとした変更を加えたとしましょう。その後、彼が行った変更は、変更した文字列にたいする新しい未翻訳のエントリーとしてPOファイルに出現し、元の変更されていない文字列にたいする翻訳は、陳腐化したエントリーとなります。多くの場合、翻訳者は未翻訳エントリーの@code{msgstr}に、陳腐化したエントリーの変更前の翻訳を流用することで作業を節約できるでしょう。その後、陳腐化したエントリーが必要ないなら、安全に削除することができます。

翻訳者が未翻訳のエントリーを見つけて、それが既存の翻訳と少ししか違わないのではないか、と思ったとしましょう。そのような場合は、すぐにカレントエントリーの場所を@kbd{m}でマークしてから、陳腐化したエントリーを検索して、変更される前の文字列にたいする翻訳を探すために@kbd{o}を使用します。見つかったら、DELコマンドで廃止されたエントリーを削除します。なぜなら彼女はDELコマンドが翻訳をkillすることを知っており、それはつまり翻訳がkillリングに保存されることを知っているからです。その後@kbd{r}コマンドで最初の未翻訳エントリーに戻り、保存した翻訳を@kbd{y}コマンドで@code{msgstr}に@emph{yank}します。これで翻訳者は、@kbd{@key{RET}}を使って自由に翻訳内容を調整することができます。そしてその後は再び@kbd{u}と@kbd{m}で次の未翻訳の文字列を探していくのかもしれません。

翻訳者が同じキーシーケンスを何度も使用する必要があるときには、要求したときにそのキーシーケンスを再生させるEmacsの機能について学習するほうがよいかもしれません。@ref{Keyboard
Macros, , , emacs, The Emacs Editor}を参照してください。

@node Modifying Comments
@subsection コメントの修正
@cindex editing comments in PO files
@emindex editing comments

翻訳とは、言語的な難しさをともなう作業です。翻訳においてどのような決定をしたのか、その選択に関してドキュメントを残す必要があるでしょう。これらのドキュメントは、翻訳者のコメントとしてPOファイルに保存されます。これは、翻訳者が自由に作成・削除、または変更ができるコメントで、彼女が後でPOファイルを見直すときなどに便利です。

最初の@samp{#}の後に空白がないコメント、たとえば@samp{#.}や@samp{#:}ではじまるコメントは、翻訳者のコメントではありません。これらは、@code{gettext}ツールにより作成されたコメントです。それらのシステムが追加したコメントは、翻訳者が変更するべきではないコメントなので、以下で説明するコマンドの対象外です。@ref{PO
Files}を参照してください。

以下のコマンドは翻訳を変更するコマンドと似ているので、一般的な原則は同様に適用できます。@ref{Modifying
Translations}を参照してください。

@table @kbd

@item #
@efindex #@r{, PO Mode command}
翻訳者のコメントを対話的に編集します(@code{po-edit-comment})。

@item K
@efindex K@r{, PO Mode command}
翻訳者のコメントをkillリングに保存してから、削除します(@code{po-kill-comment})。

@item W
@efindex W@r{, PO Mode command}
翻訳者のコメントをkillリングに保存するだけで、削除はしません(@code{po-kill-ring-save-comment})。

@item Y
@efindex Y@r{, PO Mode command}
翻訳者のコメントを、killリングのもので置き換えます(@code{po-yank-comment})。

@end table

これらの、翻訳文字列を変更するためのPOモードの類似コマンドは、翻訳文字列の代わりに翻訳者のコメントを処理する以外は、同じように動作します。詳細はすでに説明済みなので、以下ではこれらのコマンドを簡単に説明します。@ref{Modifying
Translations}を参照してください。

@efindex #@r{, PO Mode command}
@efindex po-edit-comment@r{, PO Mode command}
@kbd{#}コマンド(@code{po-edit-comment})は、POファイルのカレントエントリーにたいする翻訳者コメントのコピーを含む、新しいEmacsウィンドウをオープンします。エントリーにそのようなコメントがない場合、POモードは翻訳者がエントリーにコメントを追加したいと解釈し、空のスクリーンが表示されます。編集前にコメントマーク(@code{#})とそれに続くスペースは自動的に削除され、編集後に自動的に再付加されます。陳腐化したエントリーにたいする翻訳者コメントは、非コメント化とコメント化の操作が2度行われます。編集ウィンドウで@w{@kbd{C-c
C-c}}キーを押すと、コメントの編集を終了します。詳細については、@ref{Subedit}を参照してください。

@evindex po-subedit-mode-hook@r{, PO Mode variable}
@code{po-subedit-mode-hook}に関数が登録されている場合には、編集バッファーに文字列が挿入されたときに実行されます。

@efindex K@r{, PO Mode command}
@efindex po-kill-comment@r{, PO Mode command}
@efindex W@r{, PO Mode command}
@efindex po-kill-ring-save-comment@r{, PO Mode command}
@efindex Y@r{, PO Mode command}
@efindex po-yank-comment@r{, PO Mode command}
@kbd{K}コマンド(@code{po-kill-comment})は、翻訳者コメントをkillリングに保存してから削除します。@kbd{W}コマンド(@code{po-kill-ring-save-comment})は、翻訳者コメントをkillリングにコピーするだけで、カレントエントリーのコメントは変更しません。@kbd{Y}コマンド(@code{po-yank-comment})は、翻訳者コメントをkillリングの文字列で置き換えます。このコマンドを繰り返し入力すると、挿入されたコメントはkillリングに保存された他の文字列で順に置き換えられます。

killリングの文字列は、すべて同じ性質をもちます。@emph{翻訳された文字列}と@emph{翻訳者のコメント}に違いはありません。たとえば翻訳者が翻訳を終了したとき、以前の翻訳の何が悪かったのかをドキュメント化して覚えておこうと、コメントを付与したい場合を考えます。彼女は翻訳者コメントで、以前の翻訳を引用したいと思うのではないでしょうか。それを行うには、まず翻訳者コメントを、killリングに残っている以前の翻訳で初期化するでしょう。すでにkillリングに保存されている以前の翻訳を使って編集するには、@kbd{#}の前に@kbd{M-w}とタイプすれば、以前の翻訳がkillリングに保存されるので、それに説明文などを追加すればよいでしょう。

すでに何らかの翻訳者コメントがあり、そのコメント全体を置き換えるのではなく翻訳者がコメントを追加したい場合を考えてみましょう。その場合には@kbd{#}でコメントを編集する必要があります。編集ウィンドウが開いたら、Emacsの標準コマンドの@kbd{C-y}(@code{yank})と@kbd{M-y}(@code{yank-pop})で、以前の翻訳を取得できます。

@node Subedit
@subsection サブエディションの詳細
@emindex subedit minor mode

PO
subeditマイナーモードは、ここで詳細な説明をする価値のある特殊なモードです。これによりEmacsの通常の編集コマンド以外に、以下で説明するコマンドがインストールされます。

@table @kbd
@item C-c C-c
@efindex C-c C-c@r{, PO Mode command}
編集を完了します(@code{po-subedit-exit})。

@item C-c C-k
@efindex C-c C-k@r{, PO Mode command}
編集を中止します(@code{po-subedit-abort})。

@item C-c C-a
@efindex C-c C-a@r{, PO Mode command}
追加(auxiliary)のPOファイルを参照します(@code{po-subedit-cycle-auxiliary})。

@end table

@emindex exiting PO subedit
@efindex C-c C-c@r{, PO Mode command}
@efindex po-subedit-exit@r{, PO Mode command}
ウィンドウにはメッセージにたいする翻訳、もしくは翻訳者コメントが表示されます。翻訳者は自分の思うように、このウィンドウ内のコンテンツを変更します。作業が終わったら、@w{@kbd{C-c
C-c}}コマンド(@code{po-subedit-exit})を使えば、バッファーが切り替えられていたり、表示されていなくても、編集した翻訳で元の翻訳を置き換えてPOファイルに反映することができます。

@efindex C-c C-k@r{, PO Mode command}
@efindex po-subedit-abort@r{, PO Mode command}
kill翻訳者が自分の翻訳(または翻訳者コメント)に満足できなくて、@kbd{@key{RET}}コマンド(または@kbd{#}コマンド)を押す前の状態に戻したい場合には、@w{@kbd{C-c
C-k}}コマンド(@code{po-subedit-abort})を使えば、編集したものを破棄して、元の翻訳(または翻訳者コメント)に戻すことができます。他にも、普通に@w{@kbd{C-c
C-c}}で編集を終了してから、@code{U}(訳注：
UndoをするコマンドがUコマンドと記述してあるが、EmacsのUndoコマンドであるCtrl+_コマンドの間違いではないか)で元のバージョンに戻す方法があります。

@efindex C-c C-a@r{, PO Mode command}
@efindex po-subedit-cycle-auxiliary@r{, PO Mode command}
@w{@kbd{C-c
C-a}}コマンド(@code{po-subedit-cycle-auxiliary})は、カレントエントリーの翻訳を編集しているとき、すでに他の言語へ翻訳されたメッセージに目を通したいときに使用します。このコマンドは翻訳者が複数の言語に通じているときなどに便利でしょう(もちろん利用可能な追加のPOファイルがある場合ですが(@ref{Auxiliary}を参照してください)。

@code{po-subedit-mode-hook}に関数が登録されている場合には、編集バッファーに文字列が挿入されたときに実行されます。

編集中には、翻訳文字列の最後で意図せず@kbd{@key{RET}}(改行)キーを入力したり、必要な改行を誤って削除していまわないよう注意を払う必要があります。そのような文字が編集バッファーで非表示になっていると、容易に間違いを犯してしまいます。そのような間違いが起きないように、@kbd{@key{RET}}コマンドでは、編集している文字列の最後に自動的に@code{<}が付加されます。この@code{<}は実際のメッセージ文字列ではありません。@w{@kbd{C-c
C-c}}で編集ウィンドウを閉じると、POモードは自動的にそのような@kbd{<}文字を削除して、適切な空白文字に置き換えます。翻訳者が末尾の@code{<}の後ろに文字を追加すると、@code{<}は区切り文字としての性質を失って、翻訳文字列の一部となります。@code{<}を削除した場合には、編集文字列は@emph{そのまま}評価され、たとえ非表示であったとしても、末尾に改行があればそれもそのまま評価されます。翻訳した文字列が本物の@code{<}で終わる場合には、区切り文字の@code{<}も削除されずに表示されるので、編集ウィンドウの文字列の終端には2つの@code{<}が表示されます。

@emindex editing multiple entries
翻訳(またはコメント)を編集するとき、翻訳者はカーソルをPOファイルのバッファーに戻してから、エントリーを表示するために自由に他のエントリーに移動を行えます。編集を保留して、POファイルバッファーの他の箇所に移動したり、他のエントリーの編集をはじめることもできます。それぞれのエントリーは、それら自身のサブエディットバッファーで編集されます。1つのエントリーにたいする特定の翻訳やコメントを@emph{同時}に編集したり、異なるPOファイルのエントリーを同時に編集することも可能です。すでに編集中のエントリーにたいして@kbd{@key{RET}}をタイプすると、単にそのエントリーの編集を再開します。Emacsの複数のウィンドウの扱いに慣れれば、翻訳者はより快適になるでしょう。

@emindex pending subedits
保留したサブエディットの完了または中止は、編集を開始した順番に関わらず任意の順番で行うことができます。複数のサブエディットを保留している状態で、(@kbd{q}コマンドで)POファイルを閉じようとすると、サブエディットが1つずつ順番に再開されるので、翻訳者それら個々について決定していくことができます。

@node C Sources Context
@subsection Cソースのコンテキスト
@emindex consulting program sources
@emindex looking at the source to aid translation
@emindex use the source, Luke

POモードは、GNU
@code{gettext}ユーティリティーで作成されたPOファイルの場合、それらのユーティリティーが生成したPOファイルに特別なコメントを挿入するので、特に威力を発揮します。それらの特別なコメントの中には、POファイルのエントリーの未翻訳の文字列が、プログラムのソース中で出現する位置を示すものがあります。

翻訳者が未翻訳の文字列を翻訳するとき、その元文字列があまりに簡潔すぎたり、不可解あったり、曖昧である等、通常のように有効でない場合があります。そのような文字列をどのように翻訳するか決める前に、その文字列が本当は何を意味するのか、そしてそれにぴったりな翻訳は何なのかを理解する必要があります。このような問題を判断するために残された唯一の方法は、プログラムのソースからその文字列の場所を探し、その周辺に残されたプログラマーのコメントや、他に助けになりそうな@emph{何か}を探すことに時間を割くことです。

翻訳者が有能なプログラマーである場合、プログラムのソースを見ることにより多くの助けを得ることができるでしょう。しかしプログラミングに精通していなくて、Cのコードを見ると不安な気持ちになったとしても、恥ずかしがらずにたまにはソースを見てみましょう。そうすれば彼女が必要とする何らかのヒントを得られるようになれるでしょう。プログラマーのコメント、そして(彼が適切な名前をつけていれば)変数名や関数名、プログラムコード自体の全体的な構成などに注意を払って学習することにより、すぐにプログラムのコードを見ても違和感を感じないようになるでしょう。

@emindex find source fragment for a PO file entry
以下は、翻訳者がPOファイルのエントリーから、プログラムのソースコンテキストを参照するのに助けとなるコマンドです。

@table @kbd
@item s
@efindex s@r{, PO Mode command}
プログラムのソースコンテキストを表示、またはソースコンテキストのサイクル表示を再開します(@code{po-cycle-source-reference})。

@item M-s
@efindex M-s@r{, PO Mode command}
メニューで選択されたプログラムソースのコンテキストを表示します(@code{po-select-source-reference})。

@item S
@efindex S@r{, PO Mode command}
ソースファイルの検索パスにディレクトリを追加します(@code{po-consider-source-path})。

@item M-S
@efindex M-S@r{, PO Mode command}
ソースファイルの検索パスからディレクトリを削除します(@code{po-ignore-source-path})。

@end table

@efindex s@r{, PO Mode command}
@efindex po-cycle-source-reference@r{, PO Mode command}
@efindex M-s@r{, PO Mode command}
@efindex po-select-source-reference@r{, PO Mode command}
@kbd{s}コマンド(@code{po-cycle-source-reference})と@kbd{M-s}コマンド(@code{po-select-source-reference})は、どちらも他のウィンドウを開いてプログラムのソースファイルの、翻訳しようとしている文字列が使用されている場所を表示します。このように、これらのコマンドは文字列にたいするソースプログラムのコンテキストを与えます。しかしエントリーがコンテキストへの参照を保有していなかったり、検索パスにあるプログラムソースでは参照が解決されない場合、コマンドはその旨をエラーとして表示します。

@kbd{s}(または@kbd{M-s})も新しいウィンドウをオープンしますが、カーソルはPOファイルのウィンドウに留まったままです。翻訳者がプログラムソースのウィンドウに移動したい場合には、明示的にOコマンドを使用する必要があります。

はじめて@kbd{s}を使用するときや、POファイルのエントリーのソースコンテキストが直前に取得したものと異なるときには、コマンドはこのエントリーにたいして利用可能な、最初のコンテキストを返します。すでにそのPOファイルのカレントエントリーにたいする、何かしらのコンテキストを表示していて、さらに他のものを探したいときには最後に表示したコンテキストのウィンドウで@kbd{s}を入力することにより、検索を再開できます。このコマンドにより、翻訳者がソースファイルのコンテキストからカーソルを移動していた場合には、カーソルがコンテキストの場所に戻されます。他のコマンドを入力しないで@kbd{s}コマンドを連続して入力すると、POモードはこのエントリーにたいして利用可能なコンテキストを順々に表示していき、最後のコンテキストを表示すると、また最初のコンテキストに戻って表示します。

@kbd{M-s}コマンドは異なる動作をします。このコマンドは参照を循環して表示せずに、いくつか存在する参照のうちから1つを翻訳者に選択させます。翻訳者が@kbd{M-s}で表示される質問にたいして、すぐに@kbd{@key{TAB}}を押すと、翻訳者が適切なものを選べるように利用可能なすべての参照メニューが表示されます。このコマンドは翻訳する1つの文字列にたいして、多数の利用可能なコンテキストが存在するときに有用です。

@efindex S@r{, PO Mode command}
@efindex po-consider-source-path@r{, PO Mode command}
@efindex M-S@r{, PO Mode command}
@efindex po-ignore-source-path@r{, PO Mode command}
プログラムのソースファイルは通常、POファイルの場所から相対的に見つけることができます。この検索が失敗したときには、特別なケースとしてPOファイルの1つ上のディレクトリーからの相対パスのファイルも検索対象になります。これらの2つのケースを考えておけば、大抵のPOファイルを処理することができます。しかしPOファイルが移動されていたり、通常あるべき場所とは異なる場所で編集されているときには検索が失敗します。このような場合には、翻訳者がPOモードにたいして、POファイルが本来どのディレクトリーにあるのかを、伝える必要があります。そのように指定したディレクトリーのことをまとめて、プログラムソースの@dfn{検索パス}と呼びます。@kbd{S}コマンド(@code{po-consider-source-path})は、検索パスに新しいディレクトリーを対話的に入力するために使用され、@kbd{M-S}コマンド(@code{po-ignore-source-path})は、検索パスから削除したいディレクトリーを選択して削除するのに使用されます。

@node Auxiliary
@subsection 追加POファイルを調べる
@emindex consulting translations to other languages

POモードには、複数の言語に通じている翻訳者が、彼女の知っている言語への既存の翻訳を利用するための機能があります。この機能は、他の言語への翻訳を追加のコンテキストとして、彼女の作業に提供することができます。また一度に複数の言語への翻訳を作成したいような場合にも、翻訳者にたいして作業を容易にするための機能をもっています。

@cindex auxiliary PO file
@emindex auxiliary PO file
@dfn{追加(auxiliary)}のPOファイルとは、翻訳者が作業するパッケージの、他の言語用の既存のPOファイルのことです。追加のPOファイルを定義・処理したり、作業中のエントリーのコンテキストを表示するためのコマンドが存在します。

以下は、POモードで利用可能な、追加のPOファイルのコマンドです。

@table @kbd
@item a
@efindex a@r{, PO Mode command}
追加のPOファイルから、同じエントリーにたいする他の翻訳を探します(@code{po-cycle-auxiliary})。

@item C-c C-a
@efindex C-c C-a@r{, PO Mode command}
追加のPOファイルを指定して、それに切り替えます(@code{po-select-auxiliary})。

@item A
@efindex A@r{, PO Mode command}
表示しているPOファイルを、追加のPOファイルとして定義します(@code{po-consider-as-auxiliary})。

@item M-A
@efindex M-A@r{, PO Mode command}
表示しているPOファイルを、追加のPOファイルのリストから削除します(@code{po-ignore-as-auxiliary})。

@end table

@efindex A@r{, PO Mode command}
@efindex po-consider-as-auxiliary@r{, PO Mode command}
@efindex M-A@r{, PO Mode command}
@efindex po-ignore-as-auxiliary@r{, PO Mode command}
@kbd{A}コマンド(@code{po-consider-as-auxiliary})は、現在のPOファイルを、追加のPO
ファイルのリストに追加し、@kbd{M-A}コマンド(@code{po-ignore-as-auxiliary}は、リストから削除します。

@efindex a@r{, PO Mode command}
@efindex po-cycle-auxiliary@r{, PO Mode command}
@kbd{a}コマンド(@code{po-cycle-auxiliary})は、すべての追加POファイルを一つずつ走査して、カレントエントリーと同じ@code{msgid}にたいする、他の言語に翻訳されたエントリーを検索するコマンドです。POファイルが見つかったら、そのPOファイルが現在のウィンドウに表示されます(そのウィンドウがもっとも前面に表示されます)。追加のPOファイルに作業中のPOファイルが含まれていない場合は、これらの処理を行う前に追加しておくとよいでしょう。このようにしておけば、@kbd{a}コマンドで検索された他言語のPOファイルがウィンドウに表示されても、@kbd{a}コマンドを繰り返し入力して、元のPOファイルに戻ることができるからです。

@efindex C-c C-a@r{, PO Mode command}
@efindex po-select-auxiliary@r{, PO Mode command}
@kbd{C-c
C-a}コマンド(@code{po-select-auxiliary})は、翻訳者にたいして追加のPOファイルを補完付き入力で選択させて、そのPOファイルに切り替えるコマンドです。選択したPOファイルにカレントエントリーと同じ@code{msgid}があった場合は、そのエントリーをカレントエントリーとします。同じエントリー存在しない場合には、カーソルは元の位置から変更されません。

この機能が完全に動作するためには、@code{msgid}が、同じ方法で@emph{正確}に、正規化されて記述されている必要があります。たとえ文字列を記述する方法は異なっていても@code{msgid}に同じ文字列が設定されていれば問題はありませんが、違う文字列が記述されていると、POモードの追加POファイル関連のコマンドの動作が損なわれてしまいます。しかしほとんどのPOファイルの@code{msgid}は、同じGNU
@code{gettext}ツールで書き込まれたものなので、実際には問題になることはないでしょう。

@efindex normalize@r{, PO Mode command}
しかしソースファイルの文字列をマークしながら、POモードで一から作成したPOファイルは、異なる形式で正規化されています。そのために@samp{M-x
normalize}コマンドをPOファイルに適用するのです。POモードと他のGNU
@code{gettext}ツール間の矛盾を解決するまでは、翻訳者は正規化の問題に留意してください。

@node Compendium
@section 翻訳compendiaの使用
@emindex using translation compendia

@cindex compendium
@dfn{compendium(要約)}とは、多くのパッケージで繰り返し使用される翻訳を含んだ特別なPOファイルのことです。翻訳者はgettextツールを使って、新しいcompendiumを構築して、compendiumに含まれた翻訳から、エントリーをcompendium
に追加したり、未翻訳エントリーの初期化、既存の翻訳済みエントリーの更新できます。

@menu
* Creating Compendia::       Merging translations for later use
* Using Compendia::          Using older translations if they fit
@end menu

@node Creating Compendia
@subsection compendiaの作成
@cindex creating compendia
@cindex compendium, creating

基本的に、すべてのPOファイルに含まれる翻訳済みエントリーだけを、有効なcompendiumとして定義できます。翻訳者が特別なcompendiaを所有したい場合があります。@cite{連結POファイル(concatenating
PO files)}と@cite{POファイルからメッセージを抽出したサブセット(extracting a message subset from a
PO file)}という、2つのケースを考えてみましょう。

@subsubsection POファイルの連結

@cindex concatenating PO files into a compendium
@cindex accumulating translations
複数の有効なPOファイルを、1つのcompendiumファイルに連結するためには、@samp{msgcomm}か、@samp{msgcat}(推奨)を使用することができます:

@example
msgcat -o compendium.po file1.po file2.po
@end example

デフォルトでは@samp{msgcat}は、同じ文字列にたいして異なる翻訳がある場合には、それらの翻訳を蓄積します。これらの複数の翻訳には@code{fuzzy}マークが付与されるとともに、目立つように装飾されます。たとえば以下のような2つのファイルがあるとします。@file{file1.po}は以下のような内容です:

@example
#: src/hello.c:200
#, c-format
msgid "Report bugs to <%s>.\n"
msgstr "Comunicar `bugs' a <%s>.\n"
@end example

@noindent
そして@file{file2.po}です:

@example
#: src/bye.c:100
#, c-format
msgid "Report bugs to <%s>.\n"
msgstr "Comunicar \"bugs\" a <%s>.\n"
@end example

@noindent
これらにたいして@code{msgcat}を呼び出すと、以下のような結果になります:

@example
#: src/hello.c:200 src/bye.c:100
#, fuzzy, c-format
msgid "Report bugs to <%s>.\n"
msgstr ""
"#-#-#-#-#  file1.po  #-#-#-#-#\n"
"Comunicar `bugs' a <%s>.\n"
"#-#-#-#-#  file2.po  #-#-#-#-#\n"
"Comunicar \"bugs\" a <%s>.\n"
@end example

@noindent
``競合''は翻訳者が手動で解決する必要があります。彼女は最初のバージョンが適しているのか、それとも2番目のバージョンなのか(それとも新しい翻訳を提供する必要があるのか)を決定して、``マーカー行''を削除し、@code{fuzzy}マークをはずす必要があります。

最初に検索される翻訳済みのメッセージが常に最善の翻訳であることを翻訳者が知っている場合は、@samp{--use-first}スイッチを使用できます:

@example
msgcat --use-first -o compendium.po file1.po file2.po
@end example

よいcompendium
ファイルを作るには、@code{fuzzy}や未翻訳エントリーを含めてはいけません。入力ファイルがそのようなエントリーで``汚染''されている場合は、@samp{msgattrib
--translated --no-fuzzy}を使って入力ファイルを前処理するか、結果ファイルを後処理しなければなりません。

@subsubsection POファイルからのメッセージサブセットの抽出
@cindex extracting parts of a PO file into a compendium

同じメッセージを何度も翻訳したいと思う人はいないでしょう。たとえば、あなたが@file{getopt.c}のメッセージを含んだcompendiumファイルが欲しいと思うかもしれません。

既存のPOファイルから1つのcompendiumにメッセージのサブセット(例:
@file{getopt.c}のすべてのメッセージ)を抽出する場合は、@samp{msggrep}を使用できます。

@example
msggrep --location src/getopt.c -o compendium.po file.po
@end example

@node Using Compendia
@subsection compendiaの使用

compendiumファイルを使用して、スクラッチから翻訳を初期化したり、既存の翻訳を更新できます。

@subsubsection 新しい翻訳ファイルの初期化
@cindex compendiumで翻訳を初期化する

まだ翻訳されたPOファイルが存在しないときは、``古い''翻訳済みファイルとして@file{/dev/null}を使用できます。

@example
msgmerge --compendium compendium.po -o file.po /dev/null file.pot
@end example

@subsubsection 既存の翻訳ファイルの更新
@cindex update translations from a compendium

compendiumファイルと既存のPOファイルを結合した後、それをマージしてPOTファイルを作成し、陳腐化したエントリーを削除します(これは任意です。ここでは@samp{msgattrib}が使用されています)。

@example
msgcat --use-first -o update.po compendium1.po compendium2.po file.po
msgmerge update.po file.pot | msgattrib --no-obsolete > file.po
@end example

@node Manipulating
@chapter POファイルの操作
@cindex manipulating PO files

POファイルを手で扱うよりは、自動的な方法で取り扱うほうがよいときがあります。GNU
@code{gettext}には、この目的のための完全なツールが含まれています。

@cindex merging two PO files
2つのパッケージを1つのパッケージにマージするときには、元の2つのパッケージのPOTファイルが結合されたものが、マージされたパッケージのPOTファイルになります。したがってメンテナーは、翻訳された各言語ごとに、既存の2つの翻訳済みパッケージを1つの翻訳カタログにマージしなければなりません。これを行うには@samp{msgcat}を使うのが最善です。マージにより発生し得る競合を解決するのは、翻訳者の役目となります。

@cindex encoding conversion
ある翻訳者が他の翻訳者から作業を引き継ぐときに、彼女がそのlocaleの異なるエンコーディングを使っている場合には、カタログの文字のエンコーディングを変換することになるでしょう。これを行うには@samp{msgconv}プログラムを使うのが最善です。

メンテナーが他のパッケージからタグ付けされたメッセージを取得するとき、彼はこのソースファイルの既存の翻訳も取り込む必要があります(翻訳者が同じ作業をしなくても済むように)。これを行うには@samp{msggrep}を使う方法と、そのソースファイルからPOTファイルを作成して@samp{msgmerge}を使う方法があります。

@cindex dialect
@cindex orthography
翻訳者がある翻訳カタログを特定の方言や正書法に適応させたいとき --
たとえばSwitzerlandで記述されたGermanを、Germanyで記述されたGerman に適応させる場合など --
彼女はカタログの中のすべてのメッセージに適用できるテキストプロセッサーが必要にるでしょう。これを行うためのツールが、@samp{msgfilter}です。

@code{msgfilter}の他の使い方としては、POファイルが作成される元となったPOTファイルに近いものを生成することです。これは、@samp{msgfilter
sed -e d | sed -e '/^#
/d'}のようなフィルターコマンドにより行うことができます。オリジナルのPOTファイルには異なるコメントがあったり、plural
messageの数も異なります。この理由により、利用可能ならオリジナルのPOTファイルを使うほうがよいことに注意してください。

@cindex checking of translations
翻訳者が翻訳をチェックしたいとき、たとえば正書法のルールや非対話型のスペルチェッカーにしたがってチェックをしたいときは、@samp{msgexec}を使うことができます。

@cindex duplicate elimination
サードパーティー製のツールによりPO、またはPOTファイルを作成するとき、重複が無視されるときがあります。しかしGNU
@code{gettext}ツールは、同じファイル中に同じドメインで重複したmsgidがある場合にはエラーとなります。重複をマージするためには、@samp{msguniq}を使うことができます。

複数のファイル間での重複を維持(または破棄)するための、より一般的なツールとしては@samp{msgcomm}があります。

翻訳カタログが完全に翻訳されているかをチェックするには、@samp{msgcmp}を使うことができます。

@cindex attributes, manipulating
翻訳カタログからfuzzyや未翻訳のメッセージだけを選択・抽出するためには、@samp{msgattrib}を使うことができます。

Englishの翻訳カタログを準備するための最初のステップとしては、@samp{msgen}が便利です。これは、各メッセージのmsgidをmsgstrにコピーします。

そして最後に、これらの様々なアプリケーションでも十分でない場合には、POファイルを取り扱う特殊なプログラムを記述するために使用できる、@samp{libgettextpo}ライブラリーが提供されています。

@menu
* msgcat Invocation::        Invoking the @code{msgcat} Program
* msgconv Invocation::       Invoking the @code{msgconv} Program
* msggrep Invocation::       Invoking the @code{msggrep} Program
* msgfilter Invocation::     Invoking the @code{msgfilter} Program
* msguniq Invocation::       Invoking the @code{msguniq} Program
* msgcomm Invocation::       Invoking the @code{msgcomm} Program
* msgcmp Invocation::        Invoking the @code{msgcmp} Program
* msgattrib Invocation::     Invoking the @code{msgattrib} Program
* msgen Invocation::         Invoking the @code{msgen} Program
* msgexec Invocation::       Invoking the @code{msgexec} Program
* Colorizing::               Highlighting parts of PO files
* Other tools::              Other tools for manipulating PO files
* libgettextpo::             Writing your own programs that process PO files
@end menu

@node msgcat Invocation
@section @code{msgcat}プログラムの呼び出し

@include msgcat.texi

@node msgconv Invocation
@section @code{msgconv}プログラムの呼び出し

@include msgconv.texi

@node msggrep Invocation
@section @code{msggrep}プログラムの呼び出し

@include msggrep.texi

@node msgfilter Invocation
@section @code{msgfilter}プログラムの呼び出し

@include msgfilter.texi

@node msguniq Invocation
@section @code{msguniq}プログラムの呼び出し

@include msguniq.texi

@node msgcomm Invocation
@section @code{msgcomm}プログラムの呼び出し

@include msgcomm.texi

@node msgcmp Invocation
@section @code{msgcmp}プログラムの呼び出し

@include msgcmp.texi

@node msgattrib Invocation
@section @code{msgattrib}プログラムの呼び出し

@include msgattrib.texi

@node msgen Invocation
@section @code{msgen}プログラムの呼び出し

@include msgen.texi

@node msgexec Invocation
@section @code{msgexec}プログラムの呼び出し

@include msgexec.texi

@node Colorizing
@section POファイルの一部をハイライトする

翻訳者は通常、POファイル中の未翻訳、およびfuzzyメッセージを見ることだけに関心を持っています。また、msgidが変更されたことによりメッセージにfuzzyがセットされたときに、以前のメッセージと現在のメッセージの差分を見たいと望みます(長いmsgidの中の数語が変更されたときは特に)。そして最後に、POファイル内のセクションのメッセージ(コメント、msgid、msgstrなど)の違いを強調するのは、いつでも歓迎します。

このような強調表示は、オプション@samp{--color}と@samp{--style}を通じて可能になります。これらは@code{msgcat}、@code{msgmerge}、@code{msgunfmt}のような、標準出力のPOファイルを生成するすべてのプログラムによりサポートされています。

@menu
* The --color option::       Triggering colorized output
* The TERM variable::        The environment variable @code{TERM}
* The --style option::       The @code{--style} option
* Style rules::              Style rules for PO files
* Customizing less::         Customizing @code{less} for viewing PO files
@end menu

@node The --color option
@subsection @code{--color}オプション

@opindex --color@r{, @code{msgcat} option}
@samp{--color=@var{when}}オプションは、どのような状況で着色された出力を生成するか指定します。@var{when}には、以下のうち1つを指定できます:

@table @code
@item always
@itemx yes
着色された出力が生成されます。

@item never
@itemx no
出力は着色されません。

@item auto
@itemx tty
出力デバイスがttyのとき(例@: テキスト画面やterminal emulatorウィンドウに直接出力する場合)は、出力に着色します。

@item html
着色されたHTML出力が生成されます。

@item test
これは@code{msgcat}プログラムだけが理解する、特殊な値です。これは次のセクションで説明します(@ref{The TERM
variable}を参照)。
@end table

@noindent
@samp{--color}と@samp{--color=yes}は同じです。デフォルトは@samp{--color=auto}です。

そのため、コマンドウィンドウで@samp{msgcat vi.po}のようなコマンドを実行すると、着色された出力が生成されます。@samp{msgcat
vi.po | less
-R}のように、パイプにたいして出力するときは、出力への着色は行われません。このような状況でも常に着色された出力を得るには、@samp{msgcat
--color vi.po | less -R}のように指定します。

@samp{--color=html}オプションでは、ブラウザーで閲覧可能な出力が生成されます。このオプションは、例えばIndic言語を表示したいときに有用です。なぜなら、通常はIndic文字の表示にはterminal
emulatorよりもブラウザーのほうが適しているからです。

@code{--color}オプションにより生成される出力は、有効なPOファイルでは@emph{ない}ことに注意してください。出力にはterminal特有のエスケープシーケンスやHTMLタグが含まれます。このようなPOファイルをプログラムが読み込むと、文法エラーとなります。@samp{--color=html}オプションでHTMLファイルを生成する場合をのぞき、通常は@code{--color}オプションで生成した結果をファイルに保存する必要はありません。

@node The TERM variable
@subsection 環境変数@code{TERM}

@vindex TERM@r{, environment variable}
環境変数@code{TERM}には、テキストウィンドウの能力に関する識別情報が含まれています。これらの能力について詳細なリストを得るには、@samp{infocmp}コマンドを使用します(リファレンスは@samp{man
5 terminfo}コマンドで参照することができます)。

埋め込みの色指定をもつテキストを生成するとき、@code{msgcat}はTERM変数を参照します。現在のテキストウィンドウは、普通は少なくとも8色の表示をサポートします。しかしテキストウィンドウが16色、またはそれ以上の色数をサポートするのに、@code{TERM}変数には8色しかサポートしないように記述されている場合もあります。そのようなときは、@code{TERM}に異なる値を設定する価値があります。

@table @code
@item xterm
多くのケースでは、@code{xterm}は16色をサポートするように構築されています。88色、または256色をサポートするように構築することもできます(両方はできませんが)。このような場合は、@code{TERM}に@code{xterm-16color}、@code{xterm-88color}、または@code{xterm-256color}をセットすることを試みてもよいでしょう。

@item rxvt
@code{rxvt}が、16色をサポートするよう構築されている場合があります。このような場合は、@code{TERM}に@code{rxvt-16color}をセットすることができます。

@item konsole
@code{konsole}も、16色をサポートするよう構築されている場合があります。このような場合には、@code{TERM}に@code{konsole-16color}、または@code{xterm-16color}をセットすることができます。
@end table

@code{TERM}を設定した後は、@samp{msgcat
--color=test}により設定を検証するとともに、適切なカラーマップに見えるか出力を視認できます。

@node The --style option
@subsection @code{--style}オプション

@opindex --style@r{, @code{msgcat} option}
@samp{--style=@var{style_file}}オプションで、着色時に使用するスタイルファイルを指定できます。この指定は@code{--color}が有効なときだけ効果があります。

@vindex PO_STYLE@r{, environment variable}
@code{--style}オプションが指定されていないときは、環境変数@code{PO_STYLE}が使用されます。この環境変数にはユーザーが好むPOファイル用のスタイルファイルを指定します。

デフォルトのスタイルファイルは、@file{$prefix/share/gettext/styles/po-default.css}です。@code{$prefix}はインストールした場所です。

いくつかのスタイルファイルが事前に定義されています:
@table @file
@item po-vim.css
このスタイルはvim 7の表示を模倣します。

@item po-emacs-x.css
このスタイルは、X11ウィンドウでのGNU Emacs 21、22の表示を模倣します。

@item po-emacs-xterm.css
@itemx po-emacs-xterm16.css
@itemx po-emacs-xterm256.css
このスタイルは、@samp{xterm}(8色)、@samp{xterm-16color}(16色)、@samp{xterm-256color}(256色)の端末でGNU
Emacs 22を実行したときの表示を模倣します。
@end table

@noindent
これらのスタイルについてはディレクトリーを指定しなくても使うことができます。これらのスタイルファイルは@file{$prefix/share/gettext/styles/}にあります。@code{$prefix}はインストールした場所です。

あなた自身でスタイルをデザインできます。これは次のセクションで説明します。


@node Style rules
@subsection POファイルのスタイルルール

端末出力とHTML出力で、同じPOファイル用スタイルを使用できます。POファイル用のスタイルはCSS(Cascading Style
Sheet)の書式で記述します。CSSの正式な定義については、@url{https://www.w3.org/TR/css2/cover.html}を参照してください。CSSについての説明を含んだ、HTML記述のチュートリアルも数多く存在します。

HTML出力の場合、スタイルファイルはHTML出力中に埋め込まれます。テキスト出力の場合、スタイルファイルは@code{msgcat}プログラムにより逐次解釈されます。これは@code{@@import}に関連するファイル名が指定されていて、そのファイル名が以下のような場合、特に意味をもちます:

@itemize @minus
@item
HTML出力のときは関係のある結果HTMLファイル、

@item
テキスト出力のときは@code{@@import}を含む、関係のあるスタイルシート(実際にこのようなケースでは、libcrocoの制限により@@importはまだサポートされていません)。
@end itemize

CSSルールはselectorとdeclarationにより構築されます。declarationにはグラフィカルなプロパティーを指定し、selectorにはそれをいつ適用するかを指定します。

POファイル用に、以下の簡単なselectorがサポートされています("CSS classes"を基本とします。詳細はCSS2 specのsection
5.8.3を参照してください)。

@itemize @bullet
@item
以下はメッセージ全体に適用されるSelectorです:

@table @code
@item .header
POファイルのヘッダーエントリーにマッチします。

@item .translated
翻訳されたメッセージにマッチします。

@item .untranslated
未翻訳のメッセージにマッチします(例: 翻訳が空のメッセージ)。

@item .fuzzy
fuzzyメッセージにマッチします(例: 翻訳者のレビューが必要な翻訳をともなうメッセージ)。

@item .obsolete
陳腐化したメッセージにマッチします(例: 現在のPOTファイルでは必要とされない翻訳済みのメッセージ)。
@end table

@item
以下は、メッセージのPO文法の一部に適用されるSelectorです。PO文法の一般的なメッセージ構造ごとに呼び出されます:

@example
@var{white-space}
#  @var{translator-comments}
#. @var{extracted-comments}
#: @var{reference}@dots{}
#, @var{flag}@dots{}
#| msgid @var{previous-untranslated-string}
msgid @var{untranslated-string}
msgstr @var{translated-string}
@end example

@table @code
@item .comment
すべてのコメントにマッチします(翻訳者コメント、抽出されたコメント、ソースファイルへの参照コメント、フラグコメント、以前のメッセージであることを示すコメント、同様にすべての廃止されたコメント)。

@item .translator-comment
翻訳者のコメントにマッチします。

@item .extracted-comment
抽出されたコメントにマッチします(例: 翻訳者への注意を換気するためにプログラマーにより記述されたコメント)。

@item .reference-comment
ソースファイルへの参照コメントにマッチします(行全体)。

@item .reference
ソースファイルへの参照コメント行中の、特定のソースファイルへの参照にマッチします。

@item .flag-comment
フラグコメントにマッチします(行全体)。

@item .flag
フラグコメント行の中の、特定のフラグにマッチします。

@item .fuzzy-flag
コメント行中の`fuzzy'フラグにマッチします。

@item .previous-comment
以前の未翻訳文字列に含まれるコメントにマッチします(行全体)。

@item .previous
区切り文字、結びつけられたキーワード(@code{msgid}など)、それらの文字列間の空白を含んだ、以前の未翻訳文字列にマッチします。

@item .msgid
区切り文字、結びつけられたキーワード(@code{msgid}など)、それらの文字列間の空白を含んだ、未翻訳文字列にマッチします。

@item .msgstr
区切り文字、結びつけられたキーワード(@code{msgstr}など)、それらの文字列間の空白を含んだ、翻訳済みの文字列にマッチします。

@item .keyword
キーワード(@code{msgid}、@code{msgstr}など)にマッチします。

@item .string
区切り文字(2重引用符)を含む文字列にマッチします。
@end table

@item
以下はメッセージ文字列の一部に適用されるSelectorです:

@table @code
@item .text
文字列の内容全体にマッチします(区切り文字は除く例: 2重引用符)。

@item .escape-sequence
(バックスラッシュで始まる)エスケープシーケンスにマッチします。

@item .format-directive
書式指定文字列にマッチします(多くの言語では@samp{%}、@code{java-format}と@code{csharp-format}では@samp{@{}、@code{lisp-format}と@code{scheme-format}では@samp{~}、@code{sh-format}では@samp{$}で開始されます)。

@item .invalid-format-directive
無効な書式指定文字列にマッチします。

@item .added
未翻訳文字列中で、以前の未翻訳文字列には無かった文字列にマッチします(このリリースではまだ実装されていません)。

@item .changed
未翻訳文字列、または以前の未翻訳文字列中で、変更または置き換えられた文字列にマッチします(このリリースではまだ実装されていません)。

@item .removed
以前の未翻訳文字列中で、現在の未翻訳文字列には無い文字列にマッチします(このリリースではまだ実装されていません)。
@end table
@end itemize

これらのselectorは、以下の例のように階層的なselectorとして組み合わせることができます。

@smallexample
.msgstr .invalid-format-directive @{ color: red; @}
@end smallexample

@noindent
上記の例では、翻訳文字列中の無効な書式指定を強調表示しています。

テキストモードでは、pseudo-classes(CSS2 spec, section 5.11)とpseudo-elements(CSS2 spec,
section 5.12)はサポートされません。

HTMLモードでの宣言には制限はありません。ブラウザーがサポートする任意のgraphical attributeがサポートされます。

テキストモードでの宣言は以下のプロパティーに制限され、他のプロパティーは暗黙に無視されます。

@table @asis
@item @code{color} (CSS2 spec, section 14.1)
@itemx @code{background-color} (CSS2 spec, section 14.2.1)
これらのプロパティーはサポートされます。色数はterminalの能力に適合されます。ほとんどのterminalのサポートは8色であることに注意してください。

@item @code{font-weight} (CSS2 spec, section 15.2.3)
このプロパティーはサポートされますが、ほとんどのterminalは@code{normal}と@code{bold}の2種類のweightしか描画できません。600以上の値を指定したときは@code{bold}として描画されます。

@item @code{font-style} (CSS2 spec, section 15.2.3)
このプロパティーはサポートされます。@code{italic}と@code{oblique}は、同じ方法で描画されます。

@item @code{text-decoration} (CSS2 spec, section 16.3.1)
このプロパティーはサポートされます。値は@code{none}と@code{underline}に制限されます。
@end table

@node Customizing less
@subsection POファイルを閲覧するために@code{less}をカスタマイズする

@samp{less}は、テキストスクリーンやterminal
emulatorでテキストファイルを閲覧するための一般的なプログラムです。このプログラムは、色表示や文字飾りのための埋め込みエスケープシーケンスもサポートします。

以下のようにして、POファイルの閲覧に@code{less}を使用できます(UTF-8 環境の場合):

@smallexample
msgcat --to-code=UTF-8 --color xyz.po | less -R
@end smallexample

これと同じことを、次ような簡単なコマンドで行うための方法を説明します:

@smallexample
less xyz.po
@end smallexample

@noindent
以下の3つの準備が必要です:

@enumerate
@item
環境変数@code{LESS}に@samp{-R}と@samp{-f}のオプションを追加します:
@smallexample
$ LESS="$LESS -R -f"
$ export LESS
@end smallexample

@item
あなたのシステムに@file{lessopen.sh}と@file{lessclose.sh}スクリプトがない場合は、マニュアル(@samp{man
less})に記載されているように、それらのスクリプトを作成して、環境変数@code{LESSOPEN}、@code{LESSCLOSE}にセットします。

@item
以下のような、ファイルの拡張子からPOファイルを認識することにより@code{msgcat}を呼び出し、一時ファイルを生成する断片的なスクリプトを@file{lessopen.sh}に追加します:

@smallexample
case "$1" in
  *.po)
    tmpfile=`mktemp "$@{TMPDIR-/tmp@}/less.XXXXXX"`
    msgcat --to-code=UTF-8 --color "$1" > "$tmpfile"
    echo "$tmpfile"
    exit 0
    ;;
esac
@end smallexample
@end enumerate

@node Other tools
@section Other tools for manipulating PO files

@cindex Pology
``Pology''パッケージは、POファイル保守用の自由ソフトウェアパッケージです。特に特徴としては:

@itemize
@item
POファイルのコレクションの検証とインプレース変更。
@item
フォーマットに対応した差分とパッチ適用。
@item
バージョンコントロールブランチの処理。
@item
きめ細かい非同期レビューワークフロー。
@item
カスタマイズ可能な翻訳検証。
@item
言語とプロジェクト固有のサポート。
@end itemize

これのホームページは@url{http://pology.nedohodnik.net/}です。

@node libgettextpo
@section POファイルを処理するプログラムを独自に記述する

@samp{msgattrib}や@samp{msgcat}などの組み合わせによる処理では十分でない場合のために、一連のC関数がライブラリにより提供されています。これを使うことにより、あなたのプログラムからPOファイルを処理できるようになります。ライブラリーを使う場合は、POファイルをパースするルーチンを自分で記述する必要はありません。かわりにPOファイル内の各メッセージに対応するメモリーへのポインターを取得することができます。現時点では、POファイルへ書き込むための関数は提供されていません。

関数はヘッダーファイル@samp{<gettext-po.h>}で宣言されており、@samp{libgettextpo}というライブラリーで定義されています。

@deftp {Data Type} po_file_t
POファイルのコンテンツをメモリーに読み込んだ後に、それらを参照するためのポインター型です。
@end deftp

@deftp {Data Type} po_message_iterator_t
一連のメッセージを生成するiteratorを参照するためのポインター型です。
@end deftp

@deftp {Data Type} po_message_t
POファイルのメッセージ(翻訳を含む)を参照するためのポインター型です。
@end deftp

@deftypefun po_file_t po_file_read (const char *@var{filename})
関数@code{po_file_read}は、引数としてファイル名を受け取り、そのPOファイルをメモリー内に読み込みます。戻り値はPOファイル内のコンテンツへのハンドルで、そのハンドルは@code{po_file_free}が呼び出されるまで有効です。エラーが発生したときの戻り値は@code{NULL}で、@code{errno}がセットされます。
@end deftypefun

@deftypefun void po_file_free (po_file_t @var{file})
関数@code{po_file_free}は、メモリー内のPOファイルのコンテンツを解放します。iteratorを通じて暗黙にアクセス可能なすべてのメッセージも解放されます。
@end deftypefun

@deftypefun {const char * const *} po_file_domains (po_file_t @var{file})
関数@code{po_file_domains}は、メッセージを所有するPOファイルのdomainを戻します。戻り値は@code{NULL}で終端された配列で、この配列は@var{file}のハンドルが有効な間は有効です。@samp{domain}指定を持たないPOファイルの場合は、デフォルトのドメインである@code{"messages"}という名前のドメインだけが戻されます。
@end deftypefun

@deftypefun po_message_iterator_t po_message_iterator (po_file_t @var{file}, const char *@var{domain})
@code{po_message_iterator}は、与えられた@var{domain}に属する@var{file}のメッセージを生成するiteratorを戻します。@var{domain}が@code{NULL}のときは、かわりにデフォルトのdomainが使用されます。関数@code{po_next_message}を繰り返し呼び出すと、メッセージをリストすることができます。
@end deftypefun

@deftypefun void po_message_iterator_free (po_message_iterator_t @var{iterator})
関数@code{po_message_iterator_free}は、関数@code{po_message_iterator}により割り当てられたiteratorを開放します。
@end deftypefun

@deftypefun po_message_t po_next_message (po_message_iterator_t @var{iterator})
関数@code{po_next_message}は、@var{iterator}から次のメッセージを戻すとともにiteratorを1つ進めます。メッセージリストの終端に達すると、@code{NULL}が戻されます。
@end deftypefun

以下は@code{po_message_t}のメンバーを戻す関数です。@var{file}ハンドルが有効な間は、呼び出しによる結果も有効です。

@deftypefun {const char *} po_message_msgid (po_message_t @var{message})
関数@code{po_message_msgid}は、メッセージの@code{msgid}(未翻訳のEnglish文字列)を戻します。この結果は、非@code{NULL}であることが保証されています。
@end deftypefun

@deftypefun {const char *} po_message_msgid_plural (po_message_t @var{message})
関数@code{po_message_msgid_plural}は、pluralをもつメッセージの@code{msgid_plural}(未翻訳のEnglish
plural文字列)を戻します。メッセージがpluralをもたない場合には、@code{NULL}が戻されます。
@end deftypefun

@deftypefun {const char *} po_message_msgstr (po_message_t @var{message})
関数@code{po_message_msgstr}は、メッセージの@code{msgstr}(翻訳済み)を戻します。未翻訳のメッセージの場合は、空文字列が戻されます。
@end deftypefun

@deftypefun {const char *} po_message_msgstr_plural (po_message_t @var{message}, int @var{index})
関数@code{po_message_msgstr_plural}は、pluralをもつメッセージの@code{msgstr[@var{index}]}を戻します。@var{index}が範囲外のとき、またはメッセージがpluralをもたない場合は@code{NULL}が戻されます。
@end deftypefun

以下は、これらの関数がどのように使用されるかを示す例です。

@example
const char *filename = @dots{};
po_file_t file = po_file_read (filename);

if (file == NULL)
  error (EXIT_FAILURE, errno, "couldn't open the PO file %s", filename);
@{
  const char * const *domains = po_file_domains (file);
  const char * const *domainp;

  for (domainp = domains; *domainp; domainp++)
    @{
      const char *domain = *domainp;
      po_message_iterator_t iterator = po_message_iterator (file, domain);

      for (;;)
        @{
          po_message_t *message = po_next_message (iterator);

          if (message == NULL)
            break;
          @{
            const char *msgid = po_message_msgid (message);
            const char *msgstr = po_message_msgstr (message);

            @dots{}
          @}
        @}
      po_message_iterator_free (iterator);
    @}
@}
po_file_free (file);
@end example

@node Binaries
@chapter バイナリーのMOファイルの生成

@c FIXME: Rewrite.

@menu
* msgfmt Invocation::        Invoking the @code{msgfmt} Program
* msgunfmt Invocation::      Invoking the @code{msgunfmt} Program
* MO Files::                 The Format of GNU MO Files
@end menu

@node msgfmt Invocation
@section @code{msgfmt}プログラムの呼び出し

@include msgfmt.texi

@node msgunfmt Invocation
@section @code{msgunfmt}プログラムの呼び出し

@include msgunfmt.texi

@node MO Files
@section GNU MOファイルのフォーマット
@cindex MO file's format
@cindex file format, @file{.mo}

生成されたMOファイルの書式については、以下のような図を用いて説明するのがよいでしょう。

@cindex magic signature of MO files
最初の2wordには、ファイルの識別が含まれます。magic numberは常にGNU
MOファイルを意味するnumberになります。numberはMOファイルが生成されたときに使用されたバイトオーダーにしたがって格納されます。つまり実際のmagic
numberは、@code{0x950412de}と@code{0xde120495}のいずれかです。

2番目のwordは、ファイル書式の現在のrevisionを説明し、major revision number、およびminor revision
numberから成り立ちます。revision
numberにより、MOファイルの読み手は、古い書式と新しい書式を識別して、(可能なかぎり)内容を処理できます。いまのところmajor
revisionは0か1で、minor revisionも0と1ですが、将来は追加されるかもしれません。想定外のmajor revision
numberの場合、プログラムはMOファイル全体を読み込むのを中止する必要があります。想定外のminor revision
numberは、ファイルは読み込めても、すべての内容は読み込めないことを意味します。プログラムが解析できるのは、より小さなminor revision
numberのときだけです。

異なるmagic numberによって書式の違いを表すのではなく、magic
numberとは別にversionが保持されます。これは@file{/etc/magic}が滅多に更新されないことが主な理由です。

MOファイルの冒頭部の情報が拡張されたときに、それらを読み込むプログラムをリコンパイルしなくても良いように、以降のテーブルのポインターを使ってください。そのようにしておけば、後で新しいフラグのビットを追加したり、使用されている文字コードの表示や、新しいテーブルなどを挿入されたときに便利です。

図中のoffset @var{O}とoffset @var{T}には、2つのstring
descriptorを見出すことができます。この2つのテーブルでは、どちらもstring descriptorとして
32ビットの整数が使用されており、1つは文字列の長さを示し、もう1つは文字列がMOファイルの先頭から何バイト目かというoffsetを示します。最初のテーブルには元の文字列のdescriptorが含まれていて、これらの元文字列は辞書順にソートされて格納されています。2番目のテーブルには翻訳された文字列のdescriptorが含まれており、これらは1番目のテーブルに対応しています。つまり1番目のテーブルと同じ添字で2番目のテーブルにアクセスすれば、対応する翻訳を取得できます。

元の文字列をソートして格納することにより、MOファイルにハッシュテーブルを含まれていなかったり、含まれていたとしても実際に使うことができないときにも、単純な二分探索が可能になります。これには他にも利点があります。GNU
@code{gettext}は、POファイルの空の文字列にたいする翻訳文字列として、MOファイルに付加するシステム情報を割り当てます。この空文字列と翻訳のペアが、元の文字列のテーブルと、翻訳文字列のテーブルの最初に配置されることにより、システム情報を簡単に見つけることができるのです。

@cindex hash table, inside MO files
ハッシュテーブルのサイズ@var{S}が0のときもあります。これは、ハッシュテーブル自体がMOファイルに含まれていない場合です。事前に算出されたハッシュテーブルはディスク容量を消費し、速度も早くないという理由で、この方式を好む人もいます。ハッシュテーブルは、MOファイル中の文字列のソートされた配列の添字を含んでいます。競合はdouble
hashingにより解決しています。使用されている正確なhashing algorithmは、GNU
@code{gettext}のコード実装の説明になってしまうので、ここでは説明しません。

ハッシュテーブルを参照して取得する文字列自体は@key{NUL}終端されており、string
descriptorの文字列長にその@key{NUL}の分は含まれません。@code{msgfmt}プログラムには、MOファイル中の文字列のインデントを選択するオプションがあります。このオプションを指定すると、個々の文字列の開始位置のオフセットは指定されたインデント値の倍数分ずれます。RISCマシンには、適したインデント指定によって速度が改善するものがあります。

@cindex context, in MO files
contextについては、元の文字列の代わりに、context文字列と元の文字列を@key{EOT}で連結したものが、ソートされて格納されます。

@cindex plural forms, in MO files
plural formについては、元の文字列のsingularとpluralが@key{NUL}で区切られて格納されます。string
descriptorには、両方の長さが記述されます。しかし、ハッシュテーブルを参照するときは、元の文字列のsingularだけが使用されます。さまざまなpluralにたいする翻訳は、すべて@key{NUL}区切りで格納されます。この場合もstring
descriptorには、それらすべての長さが格納されます。

MOファイル内の文字列に@key{NUL}が埋め込まれることを防ぐ方法はありません。しかし現在のプログラムのインターフェースは、文字列が@key{NUL}で終端されると仮定しているため、文字列の途中に@key{NUL}が埋め込まれている場合、何らかの不都合が起こり得ます。MOファイルの書式は、後から他のインターフェースを適用できるほどには一般的です。一例としては、意図しない@key{NUL}が出現するような箇所にwide
characterを使用する方法などがあります(実際にはMOファイル中にwide characterを保持することはしません。wide
characterを使用するとファイルの容量が不必要に大きくなります。また@samp{wchar_t}はプラットフォームに依存するため、MOファイルもプラットフォームに依存することになるからです)。

この技術的な問題は、GNU @code{gettext}のdevelopment
forumで盛んに議論されており、MOファイルの書式が将来、進化・変更されることが予想されます。その可能性としては、同時に複数の書式にたいするサポートさえもが含まれます。しかし、わたしたちに何らかの出発点が必要なことは確かで、ここで説明しているMOファイルの書式はよい出発点でした。今の書式には厳密な制約もなく、後から書式を拡張するのは簡単なので、わたしたちは現在のアプローチに満足しています。

@example
@group
        byte
             +------------------------------------------+
          0  | magic number = 0x950412de                |
             |                                          |
          4  | file format revision = 0                 |
             |                                          |
          8  | number of strings                        |  == N
             |                                          |
         12  | offset of table with original strings    |  == O
             |                                          |
         16  | offset of table with translation strings |  == T
             |                                          |
         20  | size of hashing table                    |  == S
             |                                          |
         24  | offset of hashing table                  |  == H
             |                                          |
             .                                          .
             .    (possibly more entries later)         .
             .                                          .
             |                                          |
          O  | length & offset 0th string  ----------------.
      O + 8  | length & offset 1st string  ------------------.
              ...                                    ...   | |
O + ((N-1)*8)| length & offset (N-1)th string           |  | |
             |                                          |  | |
          T  | length & offset 0th translation  ---------------.
      T + 8  | length & offset 1st translation  -----------------.
              ...                                    ...   | | | |
T + ((N-1)*8)| length & offset (N-1)th translation      |  | | | |
             |                                          |  | | | |
          H  | start hash table                         |  | | | |
              ...                                    ...   | | | |
  H + S * 4  | end hash table                           |  | | | |
             |                                          |  | | | |
             | NUL terminated 0th string  <----------------' | | |
             |                                          |    | | |
             | NUL terminated 1st string  <------------------' | |
             |                                          |      | |
              ...                                    ...       | |
             |                                          |      | |
             | NUL terminated 0th translation  <---------------' |
             |                                          |        |
             | NUL terminated 1st translation  <-----------------'
             |                                          |
              ...                                    ...
             |                                          |
             +------------------------------------------+
@end group
@end example

@node Programmers
@chapter プログラマーの視点

@c FIXME: Reorganize whole chapter.

GNU
@code{gettext}により提供される現在のメッセージカタログの実装は、インストーラーにより選択された場合にはシステムによるメッセージカタログ処理を使用することを目標にしています。そのため、まず最初に既知の解決策を概観しておく必要があるかもしれません。POSIXコミティーの人たちは、以下で説明する準公式な標準候補のうちから1つを採択して管理しませんでした。実際、彼らは何も採択せず、インターフェースの例を含めるだけに決めました。Unixのメジャーなベンダーによるのインターフェースの採用は、X/Openのcatgetsと、Uniforumのgettextに二分されました。以下ではそれらのインターフェースについて説明するとともに、このジレンマにたいするわたしたちの解決策を説明します。

@menu
* catgets::                  About @code{catgets}
* gettext::                  About @code{gettext}
* Comparison::               Comparing the two interfaces
* Using libintl.a::          Using libintl.a in own programs
* gettext grok::             Being a @code{gettext} grok
* Temp Programmers::         Temporary Notes for the Programmers Chapter
@end menu

@node catgets
@section @code{catgets}について
@cindex @code{catgets}, X/Open specification

@code{catgets}の実装は、X/Open Portability Guide, Volume 3, XSI Supplementary
Definitions, Chapter
5に定義されています。しかし、この標準を作成する過程は、いくつかのUnixベンダーからは遅すぎると見なされ、それゆえ彼らは標準を先取りしたバージョンを実装しました。プラットフォームに依存したプログラムを記述したことから、これは問題を引き起こしました(@code{catgets}が一意なインターフェースを保証しないことさえありました)。

インターフェースの決定にコメントするのがコミティー仲間だけに制限されていて、彼らだけがインターフェースを作成できました。彼らは、このインターフェースを本当にプログラムに使わせようと考えてはいませんでした。メモリー保存の実装手法により処理は高速だったので、ユーザーはハッピーでしたが、プログラマーはそれを嫌っていました(少なくともわたしと、他の何人かも@dots{})。

Unix(tm)への正しい移植にともなうすべてのトラブルの原因は、結局のところ彼らがこの仕様を発行した人たちと同じ、X/Openの人たちだったことです。これはわたしに、すべてのUnix(という名前を名乗ることを許された)実装にたいして、このインターフェースがUnix標準となる未来を予想させるのです(例:
Spec1170)。

@menu
* Interface to catgets::     The interface
* Problems with catgets::    Problems with the @code{catgets} interface?!
@end menu

@node Interface to catgets
@subsection インターフェース
@cindex interface to @code{catgets}

@code{catgets}の実装にたいするインターフェースには、ファイルのアクセスのための3つの関数:
ファイルを開く@code{catopen}、メッセージテーブルにアクセスする@code{catgets}、そして処理が終わった後にファイルを閉じるための@code{catclose}が含まれます。関数のプロトタイプと、必要となる定義は、@code{<nl_types.h>}というヘッダーファイルにあります。

@cindex @code{catopen}, a @code{catgets} function
@code{catopen}は、以下のように呼び出されます:

@example
nl_catd catd = catopen ("catalog_name", 0);
@end example

関数の引数としてカタログ名を指定します。これは通常、プログラムかパッケージを参照する名前を指定します。2番目のパラメーターは、標準仕様では規定されていません。わたしには、それがさまざまなシステムで一貫した形で実装されているかすら、わからりません。あたりさわりのないアドバイスとしては、値として@code{0}を指定するのがよいでしょう。戻り値はメッセージカタログのハンドルで、このハンドルは@code{open}で戻されるファイルのハンドルと同じです。

@cindex @code{catgets}, a @code{catgets} function
このハンドルは、以下のようにして@code{catgets}関数で使うことができます:

@example
char *translation = catgets (catd, set_no, msg_id, "original string");
@end example

最初のパラメーターはcatalog
descriptorです。2番目のパラメーターには@code{msg_id}に保持されるメッセージの、セット番号を指定します。つまり@code{catgets}は、以下のような3段階のアドレッシングを行います:

@display
catalog name @result{} set number @result{} message ID @result{} translation
@end display

@c Anybody else loving Haskell??? :-) -- Uli

4番目の引数は、翻訳された文字列のアドレスを指すためには使用しません。これはアドレッシングステージが失敗したとき、デフォルト値を与えるためのものです。ここで重要なのは、catgetsの戻り値の型が@code{char
*}だとしても、結果の文字列を変更しては@emph{ならない}ということです。本来、この戻り値の型は@code{const char
*}のほうがよいのですが、この標準はANSI C標準が発行される1年前の、1988年に発行されたものなのです。

@noindent
@cindex @code{catclose}, a @code{catgets} function
最後の関数は期待されたとおりに使用され、そのとおりに振る舞います:

@example
catclose (catd);
@end example

この関数を呼び出すと、そのdescriptorを@code{catgets}の呼び出しには使用できません。

@node Problems with catgets
@subsection @code{catgets}インターフェースに関する問題点?!
@cindex problems with @code{catgets} interface

これを説明するのはとても簡単に見えます --- わたしたちが話してきたインターフェースのどこに問題があったのでしょうか?
実際のところ、分別のある使い方をするかぎり、そのインターフェースを使うことはできます。しかしメッセージカタログを構築するのは苦痛をともないます。その理由は@code{catgets}の3番目の引数となる、一意なmessage
IDです。これには、すべてのメッセージのペアごとに、数字を割り当てなければなりません。ソースコードの変更、たとえばメッセージを追加したり削除するときに、このリストを保守する際に発生する問題を想像してみてください。もちろん、この混沌を組織化するためのツールもたくさん開発されました。しかし、あるツールで処理できるのに、他のツールでは読み込めないといった様相でした。より簡単に管理できて問題もない、他のやり方はあるのですが、述べないでおきましょう。

@node gettext
@section @code{gettext}について
@cindex @code{gettext}, a programmer's view

@code{gettext}のインターフェースの定義は、Uniforumの提案によるものです。これはSunから提出されたもので、Sunは1990頃に、SunOS4で@code{gettext}を実装済みでした。現在では、@code{gettext}のインターフェースは、OpenI18N標準により規定されています。

この解決策の主要な点は、通常のファイル処理の手順(open-use-close)を踏襲しないことと、プログラマーに負担(特に一意なキーの取扱いにたいして)をかけないことにあります。もちろん一意なキーは必要なので、(メッセージの長短に関わらず)メッセージ自身をキーとします。比較に関する2つの方法の詳細については、@ref{Comparison}を参照してください。

以下のセクションでは、より詳細にインターフェースを説明します。インターフェースについて詳細を掘り下げて説明するのは、それが GNU
@code{gettext}ライブラリーに密接に関係しているからです。ライブラリーの使い方に興味をもつプログラマーは、この説明にも興味をもつことでしょう。

@menu
* Interface to gettext::     The interface
* Ambiguities::              Solving ambiguities
* Locating Catalogs::        Locating message catalog files
* Charset conversion::       How to request conversion to Unicode
* Contexts::                 Solving ambiguities in GUI programs
* Plural forms::             Additional functions for handling plurals
* Optimized gettext::        Optimization of the *gettext functions
@end menu

@node Interface to gettext
@subsection インターフェース
@cindex @code{gettext} interface

インターフェースは最小限、a)文字列が由来するドメインの選択(すべてのプログラムが1つのドメインを使用するのは、構築と保守が難しいので、たとえ可能であったとしても合理的ではありません)、b)選択されたドメインの文字列へのアクセス、の機能をもたなければなりません。

これは主に@code{gettext}のインターフェースについての説明です。このインターフェースは、使用するドメインを与えなかった場合に、無条件に参照されるグローバルドメインをもっています。もちろん、このドメインはユーザーが選択することができます。

@example
char *textdomain (const char *domain_name);
@end example

これにより、@code{LC_MESSAGE}カテゴリーにおける現在のグローバルドメインの状態を問い合わせたり変更することができます。引数はヌル終端された文字列で、ファイル名として使用できる文字でなければなりません。引数@var{domain_name}が@code{NULL}の場合、この関数は現在の値を戻します。値がセットされていなければ、デフォルトのドメイン名@emph{messages}が戻されます。@code{textdomain}の戻り値型は@code{char
*}となっていますが、それを変更することはできないことに注意してください。それと、ドメイン名が利用可能かのチェックは行われないことを知ることも重要です。ドメイン名が利用可能でない場合、それは翻訳が提供されていないという事実をあらわします。

@noindent
@code{textdomain}でセットしたドメインは、以下の関数で使用されます

@example
char *gettext (const char *msgid);
@end example

@noindent
この関数は想像されるとおりの簡単な方法で使用されます。これにより、現在のドメインが利用可能な場合には、@var{msgid}にたいする翻訳文字列が戻されます。ドメインが利用可能でない場合には、引数自身が戻されます。引数に@code{NULL}が指定された場合の戻り値は未定義です。

1つ念頭においてもらいたいのは、使用するドメインを明示的に与えられなかった場合のことです。この場合には現在のドメインが使用されます。プログラム中で同じ@code{gettext}を呼び出したとしても、実行の間にドメインが変更された場合には、異なるメッセージカタログが参照されることになります。

もっとも簡単なのは、国際化されたパッケージで普通に使うケースで、この場合は実行開始時に呼び出される@code{textdomain}により、一意なドメイン名(通常はパッケージ名)がセットされます。以降のコードでは、翻訳が必要な文字列はすべてgettext関数により処理されます。これだけでパッケージがあなたの言語で話し出すのです。

@node Ambiguities
@subsection あいまいざの解決
@cindex several domains
@cindex domain ambiguities
@cindex large package

ほとんどのアプリケーションでは、単一のドメイン名でうまく動作するかもしれませんが、複数のドメインから翻訳を取得する必要があるアプリケーションも存在します。@code{textdomain}を呼び出すことにより異なるドメインに切り替えることもできますが、これは不便だし低速です。起こり得る状況としては、この文書を記述しているときに提出された議論(一般的に使われる関数のすべてのエラーメッセージは、errorというドメインに分離するべきである)のケースがあります。これには翻訳が1度で済むという意味があります。他のケースとしてはライブラリーのメッセージの場合で、これらがアプリケーションの現在のドメインからは独立している@emph{必要}があります。

@noindent
これらの理由により、文字列を取得するために、さらに2つの関数が用意されています:

@example
char *dgettext (const char *domain_name, const char *msgid);
char *dcgettext (const char *domain_name, const char *msgid,
                 int category);
@end example

これらの関数は、どちらも1番目に追加の引数があります。これには@code{textdomain}と同じ引数を与えます。@code{dcgettext}の3番目の引数により、@code{LC_MESSAGES}以外の、他のlocale
categoryを使うことができます(実際のところ、わたしにはこれがどんなときに便利なのか、わかりませんが)。@var{domain_name}が@code{NULL}のとき、または@var{category}に未知のものが指定された場合、結果は未定義となります。Solarisの関数ファミリーの2番目の実装にはでは、1つは含まれているのに、この関数は含まれていないことも触れておくべきでしょう

多重定義が発生する2番目の理由は、複数のドメインが同じ名前を共有するかもしれないという事実に起因します。これは必要なメッセージカタログがどこにあるか指定することで解決します。

@example
char *bindtextdomain (const char *domain_name,
                      const char *dir_name);
@end example

この関数を呼び出すことにより、指定されたドメインとディレクトリーのファイルがバインドされます(ファイルがどのように決定されるかは以下で説明します)。特に、システムの既定の位置にあるファイルのかわりに、指定された位置のファイルを使って@code{textdomain}を呼び出したいときに使用します。@var{dir_name}パラメーターに@code{NULL}ポインターを与えると、@var{domain_name}にバインドされている値が戻されます。@var{domain_name}自身が@code{NULL}の場合は何も行われず、@code{NULL}ポインターが戻されます。他の関数と同様に、戻された値を変更することはできません!

@var{dir_name}に相対パスを指定することは、トラブルの原因になることを覚えておくことは重要です。プログラムが@code{chdir}コマンドを呼び出すことにより、カレントディレクトリーに関連づいた相対パスは、再計算されます。相対パスの使用により、常に非依存性と信頼性が無効にされます。

@node Locating Catalogs
@subsection メッセージカタログファイルの配置
@cindex message catalog files location

さまざまなパッケージごとに、多くの異なる言語を保存する必要があるという理由により、わたしたちにはこれらの情報をメッセージカタログファイルに記録するための、何らかの方法が必要です。Unix環境でよく使われるのは、ファイル名にエンコード名をもたせる方法で、ここでも同じ方法を用います。ディレクトリーは、@code{bindtextdomain}の2番目の引数に指定するディレクトリー(または既定のディレクトリー)の後ろに、locale名とlocale
category、それとdomain名を連結したものになります:

@example
@var{dir_name}/@var{locale}/LC_@var{category}/@var{domain_name}.mo
@end example

@var{dir_name}の既定値はシステムにより定義されます。この習慣を順守するGNUのライブラリーやパッケージのために、以下のように定義されています:
@example
/usr/local/share/locale
@end example

@noindent
@var{locale}は、@code{LC_@var{category}}で指定されたlocale
categoryの名前です。@code{gettext}と@code{dgettext}の場合、@code{LC_@var{category}}は常に@code{LC_MESSAGES}になります@footnote{@code{LC_MESSAGES}のないシステムも存在します(例:
mingw)。そのような場合には、任意の値として1729(2つの立方数の和として、2通りの方法で表すことのできる最小の正の整数。訳注:ハーディ＝ラマヌジャン数と呼ぶそうです)を使用します。}。locale
category の名前は、@code{setlocale (LC_@var{category},
NULL)}を通じて決定されます@footnote{@code{setlocale}がサポートされないシステムでのlocaleの値のセットは、環境変数を参照するのと同じ方法によりシミュレートされます。}。@code{dcgettext}関数では、3番目の引数にlocale
categoryを指定できます。

@node Charset conversion
@subsection @code{gettext}が使用する出力文字セットの指定方法
@cindex charset conversion at runtime
@cindex encoding conversion at runtime

@code{gettext}は、メッセージカタログ内の翻訳を取得するだけでなく、オンザフライで翻訳出力の文字セットを変換することもできます。これは、翻訳者がメッセージカタログを作ったときとは異なる文字セットを使っているユーザーにとって便利です。これにより、文字セットだけが異なるメッセージカタログをいくつも作らなくてよくなるからです。

出力される文字セットのデフォルトは@code{nl_langinfo
(CODESET)}です。これは現在のlocaleの@code{LC_CTYPE}の部分に依存します。文字列をlocaleとは関係のない文字セット(例:
UTF-8)で保存するプログラムは、@code{gettext}や、それに関連するプログラムにたいして、そのエンコードで翻訳を戻すように要求することができます。これは、@code{bind_textdomain_codeset}関数により行います。

@code{gettext}の引数である@var{msgid}は、文字セットの変換の対象外であることに注意してください。@code{gettext}が、@var{msgid}に対応する翻訳を見つけられなかったときは、現在の出力の文字セットとは関係なく、元の@var{msgid}が変更されずに出力されます。すべての@var{msgid}に
US-ASCII 文字列が推奨されているのは、これが理由です。

@deftypefun {char *} bind_textdomain_codeset (const char *@var{domainname}, const char *@var{codeset})
関数@code{bind_textdomain_codeset}は、ドメイン@var{domainname}用のメッセージカタログの出力文字セットを指定するのに使用します。引数@var{codeset}には、関数@code{iconv_open}で使用できる有効なコードセット名、またはNULLポインターでなければなりません。

パラメーター@var{codeset}がNULLポインターの場合、@code{bind_textdomain_codeset}は、ドメイン@var{domainname}で現在選択されているコードセットを戻します。コードセットが選択されていないときは、@code{NULL}が戻されます。

@code{bind_textdomain_codeset}関数を複数回呼び出すこともあるでしょう。引数@var{domainname}を変更せずに複数回呼び出したときは、それ以前に呼び出したときのセッティングによりオーバーライドされます。

@code{bind_textdomain_codeset}関数は、選択されたコードセットを結合した文字列へのポインターを戻します。その文字列は関数内部で割り当てられ、ユーザーは変更できません。@code{bind_textdomain_codeset}の実行中にシステムが割り当てに失敗すると、戻り値は@code{NULL}となり、グローバル変数@var{errno}に対応するエラーがセットされます。
@end deftypefun

@node Contexts
@subsection あいまいさの解決のためにコンテキストを使用する
@cindex context
@cindex GUI programs
@cindex translating menu entries
@cindex menu entries

グラフィカルユーザーインターフェース(GUI)をもつプログラムで、@code{gettext}関数を普通に使うと、大きな問題がおきるかもしれない箇所があります。その問題とは、翻訳する必要がある文字列のほとんどが、短い文字列であるような場所で発生します。そらの文字列とは、プルダウンメニューの文字列のように、長さを制限する必要のある文字列です。それらの文字列は、センテンス全体を含んでいなかったり、センテンスの断片がプログラムの異なるシチュエーションで出現し、シチュエーションごとに異なる翻訳を割り当てる必要のあるものです。特にGUIプログラムで頻繁に使用される、1単語の文字列が問題になります。

@code{gettext}のアプローチには問題があるので、このような問題が存在しない@code{catgets}を使う必要があるという人もたくさんいます。しかし、この種の問題を処理するための簡単で強力な方法が、@code{gettext}関数には備わっているのです。

それは翻訳するべき文字列に、contextを追加する方法です。contextにもとづく翻訳参照とは、与えられた文字列にたいする翻訳を検索するときに与えられたcontextに検索範囲を限定することです。同じ文字列でも、異なるcontextに属する場合、異なる翻訳を割り当てることができます。ある文字列にたいするcontextごとの翻訳は、1つのMOファイルに一緒に保存でき、翻訳者も1つのPOファイルを編集するだけです。

@file{gettext.h}には、context付きの文字列を参照するためのマクロが含まれます。これらは@code{<libintl.h>}由来の軽量マクロ、またはインライン関数により実装されています。

@findex pgettext
@example
const char *pgettext (const char *msgctxt, const char *msgid);
@end example

このマクロの呼び出しでは、@var{msgctxt}と@var{msgid}を文字列リテラルにしなければなりません。マクロは、@var{msgctxt}に与えられたcontextの、@var{msgid}に対応する翻訳を戻します。

@var{msgctxt}は、POファイル中で翻訳者が目にすることのできる文字列です。あなたは何らかの方法により標準的なものを定めることと、それを決して変更しないことが必要です。なぜなら@var{msgctxt}を変更する度に、翻訳者は@var{msgid}にたいする翻訳をレビューする必要があるからです。

時間を経過しても変更されないような、標準的な@var{msgctxt}文字列を見つけるのは困難です。しかし@code{pgettext}の呼び出しに、ファイル名やクラス名を使うべきではありません
--
なぜならファイルやクラスの名前を変更するのは開発タスクでは一般的なので、それが翻訳者の作業に影響を及ぼすべきでないからです。また、@var{msgctxt}に完全な英語センテンスのコメント形式を使うべきでもありません
--
なぜなら、そのようなセンテンスに適用される正書法や文法はしばしば変更されるので、繰り返しになりますが、その変更により翻訳者がレビューを強いられるべきではありません。

@samp{pgettext}の@samp{p}は、``particular(特定の)''から由来しています:
@code{pgettext}は、特定の@var{msgid}から翻訳を取得します。

@findex dpgettext
@findex dcpgettext
@example
const char *dpgettext (const char *domain_name,
                       const char *msgctxt, const char *msgid);
const char *dcpgettext (const char *domain_name,
                        const char *msgctxt, const char *msgid,
                        int category);
@end example

これらの関数は@code{pgettext}を、より一般化したものです。それぞれの関数は、@code{dgettext}や@code{dcgettext}と同様に振る舞います。引数@var{domain_name}には、翻訳のドメインを定義します。引数@var{category}を指定することにより、@code{LC_MESSAGES}とは異なるlocale
categoryを指定できます。

次のような例で考えてみましょう。メニューバーをもつGUIプログラムがあり、メニューには以下のようなエントリーがあるとします:

@smallexample
+------------+------------+--------------------------------------+
| File       | Printer    |                                      |
+------------+------------+--------------------------------------+
| Open     | | Select   |
| New      | | Open     |
+----------+ | Connect  |
             +----------+
@end smallexample

コード中の@code{File}、@code{Printer}、@code{Open}、@code{New}、@code{Select}、@code{Connect}の文字列は、@code{gettext}ファミリーの関数によって翻訳される必要があります。しかし@code{Open}という文字列は、2ヶ所で使われており、それにたいして異なる翻訳を割り当てなければならないかもしれず、それゆえ上述したようなジレンマが発生します。

メニュー中の同じ2つの文字列を区別するのは、メニューのルートからそれらのエントリーへのパスです:

@smallexample
Menu|File
Menu|Printer
Menu|File|Open
Menu|File|New
Menu|Printer|Select
Menu|Printer|Open
Menu|Printer|Connect
@end smallexample

したがってcontextは、メニューのパスから最後の部分を除いたものになります。そうすると呼び出しは以下のようになるでしょう:

@smallexample
pgettext ("Menu|", "File")
pgettext ("Menu|", "Printer")
pgettext ("Menu|File|", "Open")
pgettext ("Menu|File|", "New")
pgettext ("Menu|Printer|", "Select")
pgettext ("Menu|Printer|", "Open")
pgettext ("Menu|Printer|", "Connect")
@end smallexample

contextの最後に、区切り文字の@samp{|}をつけるかどうかは、スタイルの問題になります。

より複雑なケースとしては、@var{msgctxt}や@var{msgid}が文字列リテラルでない場合があります。そのようなケースにたいしては、より一般的なマクロが利用できます:

@findex pgettext_expr
@findex dpgettext_expr
@findex dcpgettext_expr
@example
const char *pgettext_expr (const char *msgctxt, const char *msgid);
const char *dpgettext_expr (const char *domain_name,
                            const char *msgctxt, const char *msgid);
const char *dcpgettext_expr (const char *domain_name,
                             const char *msgctxt, const char *msgid,
                             int category);
@end example

これらのマクロは、@var{msgctxt}と@var{msgid}に、任意の文字列変数を指定できるので、より一般的です。どちらの引数も文字列リテラルのときは、@samp{_expr}が付加されていないマクロのほうが効率的です。

@node Plural forms
@subsection 複数形(plural forms)にたいする追加の関数
@cindex plural forms

いままで説明してきた既存のアプローチでは完全に無視してきましたが、@code{gettext}ファミリーの関数(すべての@code{catgets}関数も同様)を実世界で使用する場合は、1つの問題があります。それはplural
form(複数形書式)の取り扱いです。

インターナショナリゼーション以前のUnixのソースコード(そして悲しいことにインターナショナリゼーション以降のソースコードさえも)を見てみると、以下のようなコードを目にすることがあります:

@smallexample
   printf ("%d file%s deleted", n, n == 1 ? "" : "s");
@end smallexample

@noindent
最初にコードをインターナショナライズする人々から不具合が報告された後は、このような複数形についての場合分けを無視するか、@code{"file(s)"}という文字列を使うようになりました。これはどちらも不自然で解決法とはなりませんでした。最初の試みとして、以下のようにすることで解決が図られました:

@smallexample
   if (n == 1)
     printf ("%d file deleted", n);
   else
     printf ("%d files deleted", n);
@end smallexample

しかし、これは問題の解決になっていません。この方法は、単純に名詞に
@ifhtml
‘s’
@end ifhtml
@ifnothtml
`s'
@end ifnothtml
を追加することによりplural
formを表現するだけではない言語をも対象としていましたが、結局それだけのことでした。人々は自分が使っている言語のルールが、他の言語にも適用できる普遍的なものだと信じるという罠に陥っていたのです。実際には言語ファミリー間でplural
formの取り扱いかたは大きく異なっていたのです。たとえば、Rafal Maszkowski
@code{<rzm@@mat.uni.torun.pl>}による以下のレポートを見てください:

@quotation
わたしたちはPolishでplik(fileのこと)を以下ように表現します:
@example
1 plik
2,3,4 pliki
5-21 pliko'w
22-24 pliki
25-31 pliko'w
@end example
以下同様にカウントしていきます(o'は8859-2 oacuteを意味しており、okreskaより、むしろaogonekと似ています。
@end quotation

言語間(そして言語ファミリー内部においてさえも)には、2つの異なる事象が存在しました:

@itemize @bullet
@item
plural
formを構築する方式が異なること。これは規則的ではないルールを多くもつ言語で問題になります。極端なケースとしてはGermanがあげられます。EnglishからGermanへは、同じ言語ファミリー(Germanic)ですが、名詞に(
@ifhtml
‘s’)
@end ifhtml
@ifnothtml
`s')
@end ifnothtml
を付加して複数形を表す標準的な方式を、Germanではほとんど見出せません。

@item
plural
formを適用するべき数値が異なること。これは、複数形にすべき数値が単に2からであるような、RomanicやGermanicしか経験したことのない人を驚かせます。

単一の形式しかもたない言語ファミリーや、多数の形式をもつ言語ファミリーがあります。これに関する更なる情報は、このセクションの範囲を超えています。
@end itemize

これらの理由により、アプリケーションを記述する人は、これらの問題をコードで解決するべきではないという結論になります。これは言語環境にたいしてハードコードされた状態においてのみ有用なローカリゼーションでしょう。かわりに拡張された@code{gettext}のインターフェースを使うべきです。

これらの追加の関数は、単一のキー文字列ではなく、2つの文字列と、数値の引数をとります。この考え方の背景には、数値の引数と最初の文字列をキー文字列として使用することにより、翻訳者が指定した正しいplural
formを実装が選択できるようにするというアイデアがあります。それから、2つの文字列引数は、メッセージカタログが見つからなかったときの戻り値を提供するために使用されます(これは通常の@code{gettext}の振る舞いと同じです)。このケースではGermanic言語のルールが適用され、最初の文字列引数はsingular
form、2番目の文字列引数はplural formとみなされます。

この結果、言語カタログをもたないプログラムは、それがGermanic言語のルールにしたがって記述された場合のみ正しい文字列を表示できるということになります。これは確かに制限なのですが、GNU
C library(とGNU
@code{gettext}パッケージ)がGNUパッケージの一部として記述されていること、そしてGNUプロジェクトのコーディング規約がEnglishによるプログラム記述を要請しているので、制限があるにもかかわらずこの解決策により要件を満足することができるのです。

@deftypefun {char *} ngettext (const char *@var{msgid1}, const char *@var{msgid2}, unsigned long int @var{n})
@code{ngettext}関数は、@code{gettext}関数と似ており、メッセージカタログを検索する方法は同じですが、2つの追加の引数をとります。パラメーター@var{msgid1}には、変換する必要のある文字列のsingular
formを指定します。このパラメーターはカタログを検索するキーとしても使用されます。パラメーター@var{msgid2}にはplural
formを指定します。パラメーター@var{n}は、plural
formの適用を決定するのに使用されます。メッセージカタログが見つからなかったとき、@code{n ==
1}なら@code{msgid1}が戻され、それ以外のときは@code{msgid2}が戻されます。

以下はこの関数の使用例です:

@smallexample
printf (ngettext ("%d file removed", "%d files removed", n), n);
@end smallexample

@var{n}の数値は、@code{printf}関数にも引き渡されることに注意してください。@code{ngettext}だけに渡したい場合、この例は不適切です。

Englishのsingular caseの場合、常に1であるような数値は、"one"に置き換えることができます:

@smallexample
printf (ngettext ("One file removed", "%d files removed", n), n);
@end smallexample

@noindent
@samp{printf}関数は、format stringが与えられていない余分な引数を無視するので、この例は問題なく動作します。

ここで2つ以上の引数を要求するようなformat stringを関数で使う場合、以下の例のような使い方はできません:

@smallexample
printf (ngettext ("%d file removed from directory %s",
                  "%d files removed from directory %s",
                  n),
        n, dir);
@end smallexample

@noindent
Englishでsingular
caseのときに@samp{%d}を``one''に置き換えたように、他の言語の翻訳者も特定の単語に置き換えたいと望むかもしれません。しかしCのformat
stringでは、1番目の引数をスキップして2番目の引数を使用するようなことはできません。このような場合は引数の順番を変えて、@samp{n}が最後にくるようにする必要があります:

@smallexample
printf (ngettext ("%2$d file removed from directory %1$s",
                  "%2$d files removed from directory %1$s",
                  n),
        dir, n);
@end smallexample

@noindent
このように引数の配置を指定する文法についての詳細は、@ref{c-format}を参照してください。

@code{n}の値がとる範囲がわかっている場合には、@code{xgettext}ツールのためのコメントを指定することができます。以下の例のような情報は、翻訳者が適切な翻訳を行う助けとなるでしょう:

@smallexample
if (days > 7 && days < 14)
  /* xgettext: range: 1..6 */
  printf (ngettext ("one week and one day", "one week and %d days",
                    days - 7),
          days - 7);
@end smallexample

以下の例のように、文字列に数値が含まれないようなときに、この関数を使うこともできます:

@smallexample
puts (ngettext ("Delete the selected file?",
                "Delete the selected files?",
                n));
@end smallexample

この例で、@var{n}はplural formであるかを判定するためだけに使用されています。
@end deftypefun

@deftypefun {char *} dngettext (const char *@var{domain}, const char *@var{msgid1}, const char *@var{msgid2}, unsigned long int @var{n})
@code{dngettext}は、選択されたメッセージカタログにたいして、@code{dgettext}と同様な方法で使用します。異なるのは、正しいplural
formのために、2つの余分なパラメーターを指定できる点です。この2つのパラメーターは、@code{ngettext}のときと同様に処理されます。
@end deftypefun

@deftypefun {char *} dcngettext (const char *@var{domain}, const char *@var{msgid1}, const char *@var{msgid2}, unsigned long int @var{n}, int @var{category})
@code{dcngettext}は、選択されたメッセージカタログにたいして、@code{dcgettext}と同様な方法で使用します。異なるのは、正しいplural
formのために、2つの余分なパラメーターを指定できる点です。この2つのパラメーターは、@code{ngettext}のときと同様に処理されます。
@end deftypefun

では、これらの関数はどのようにしてplural formsの問題を解決しているのでしょうか?
言語学の情報(そして、それは利用可能ではありません)がないかぎり、少しの差異しかないplural
formのうちからどれを使用すればよいのか、そして新たにサポートされる言語ごとに数を増やせるかを決定することはできません。

したがって、plural
formを選択するルールを翻訳者が指定するという解決策が実装されました。各言語ごとに方式が異なる以上、これはコード内に情報をハードコーディングする以外の、唯一可能な解決策なのです(それでもまだ新しい言語の使用を妨げない拡張可能性を満たすという要件は残されています)。

@cindex specifying plural form in a PO file
@kwindex nplurals@r{, in a PO file header}
@kwindex plural@r{, in a PO file header}
plural
form選択のための情報は、以下のようにPOファイルのヘッダーエントリー(@code{msgid}が空文字列のエントリーのうちの1つ)に保存されています:

@smallexample
Plural-Forms: nplurals=2; plural=n == 1 ? 0 : 1;
@end smallexample

@code{nplurals}には、その言語では何種類のplural
formがあるのかを数字で指定します。@code{plural}に続く文字列には、C言語で使用できる評価式です。負の数値は使用できません。数値には正の整数を指定します。また、変数として使用できるのは@code{n}だけです。式で空白を使うことはできますが、バックスラッシュは使用できません。以下の例のうち、バックスラッシュと改行が使用されている例がありますが、これは表示を見やすくする目的のためだけに使用しています。この式は@code{ngettext}、@code{dngettext}、@code{dcngettext}が呼び出されたときに評価されます。これらの関数に数値が渡されると、式中の変数@code{n}の値として、その数値が評価されます。結果は0以上、かつ@code{nplurals}に指定した値より小さくなければなりません。

@noindent
@cindex plural form formulas
複数形の使い分けについては、以下のルールが知られています。言語と言語のファミリーが記載されていますが、この情報を言語ファミリー全体に適用する必要があるという訳ではありません(見やすくするために併記しています)。@footnote{追加の情報を歓迎します。@email{bug-gnu-gettext@@gnu.org}か
@email{bug-glibc-manual@@gnu.org}までメールしてください。Unicode CLDR Project
(@uref{http://cldr.unicode.org})は、異なるフォーマットによる、包括的なplural
formsを提供しています。@code{msginit}プログラムは、このフォーマットにたいする予備的なサポートをもっているので、これを基本として使用することができます(@ref{msginit
Invocation}を参照してください)。}

@table @asis
@item １つの形式だけを使うもの:
1つの形式しか必要としない言語があります。これらの言語ではsingular formとplural
formの区別はありません。この場合の適切なヘッダーエントリーは以下のようになるでしょう:

@smallexample
Plural-Forms: nplurals=1; plural=0;
@end smallexample

@noindent
このような特性をもつのは以下の言語です:

@table @asis
@item Asian family
Japanese, Vietnamese, Korean 
@item Tai-Kadai family
Thai 
@end table

@item 2つの形式がありsingularは１にしか適用しないもの
この形式はEnglishで使われているもので、既存のプログラムでも一番多く使用されています。この場合のヘッダーエントリーは以下のようになるでしょう:

@smallexample
Plural-Forms: nplurals=2; plural=n != 1;
@end smallexample

(注意: これはCの真偽値が0か1の2値をとる機能を使用しています。)

@noindent
このような特性をもつのは以下の言語です:

@table @asis
@item Germanic family
English, German, Dutch, Swedish, Danish, Norwegian, Faroese 
@item Romanic family
Spanish, Portuguese, Italian 
@item Latin/Greek family
Greek 
@item Slavic family
Bulgarian 
@item Finno-Ugric family
Finnish, Estonian 
@item Semitic family
Hebrew 
@item Austronesian family
Bahasa Indonesian 
@item Artificial
Esperanto 
@end table

@noindent
同じヘッダーエントリーを使う他の言語:

@table @asis
@item Finno-Ugric family
Hungarian 
@item Turkic/Altaic family
Turkish 
@end table

Hungarianは、数字を含んだセンテンスでは複数形を使いません。たとえば``1 apple''は “1 alma” で、``123
apples''も``123 alma''です。しかし数が明確でない場合には``the apple''は``az alma''、``the
apples''は``az
alm@'{a}k''のようにsingularとpluralを区別します。このようなセンテンスを@code{ngettext}がサポートするようになってから、Hungarianも2つの形式をもつクラスに分類されるようになりました。

Turkish も同様です: ``1 apple''は``1 elma''で、``123 apples''も``123
elma''です。しかし数字が省略された場合には、``the apple''は``elma''、``the
apples''は``elmalar''のようにsingularとpluralを区別します。

@item 2つの形式がありsingularを0と1に適用するもの
言語ファミリーの例外的なケースです。ヘッダーエントリーは以下のようになります:

@smallexample
Plural-Forms: nplurals=2; plural=n>1;
@end smallexample

@noindent
このような特性をもつのは以下の言語です:

@table @asis
@item Romanic family
Brazilian Portuguese, French 
@end table

@item 3つの形式があり、0を特別なケースとして扱うもの
ヘッダーエントリーは以下のようになります:

@smallexample
Plural-Forms: nplurals=3; plural=n%10==1 && n%100!=11 ? 0 : n != 0 ? 1 : 2;
@end smallexample

@noindent
このような特性をもつのは以下の言語です:

@table @asis
@item Baltic family
Latvian 
@end table

@item 3つの形式があり、1と2を特別なケースとして扱うもの
ヘッダーエントリーは以下のようになります:

@smallexample
Plural-Forms: nplurals=3; plural=n==1 ? 0 : n==2 ? 1 : 2;
@end smallexample

@noindent
このような特性をもつのは以下の言語です:

@table @asis
@item Celtic
Gaeilge (Irish) 
@end table

@item 3つの形式があり、00または[2-9][0-9]で終わる数字を特別なケースとして扱うもの
ヘッダーエントリーは以下のようになります:

@smallexample
Plural-Forms: nplurals=3; \
    plural=n==1 ? 0 : (n==0 || (n%100 > 0 && n%100 < 20)) ? 1 : 2;
@end smallexample

@noindent
このような特性をもつのは以下の言語です:

@table @asis
@item Romanic family
Romanian 
@end table

@item 3つの形式があり、1[2-9]で終わる数字を特別なケースとして扱うもの
ヘッダーエントリーは以下のようになります:

@smallexample
Plural-Forms: nplurals=3; \
    plural=n%10==1 && n%100!=11 ? 0 : \
           n%10>=2 && (n%100<10 || n%100>=20) ? 1 : 2;
@end smallexample

@noindent
このような特性をもつのは以下の言語です:

@table @asis
@item Baltic family
Lithuanian 
@end table

@item 3つの形式があり、1、または2、3、4で終わる数字を特別なケースとして扱うもの、ただし1[1-4]で終わる数字を除く
ヘッダーエントリーは以下のようになります:

@smallexample
Plural-Forms: nplurals=3; \
    plural=n%10==1 && n%100!=11 ? 0 : \
           n%10>=2 && n%10<=4 && (n%100<10 || n%100>=20) ? 1 : 2;
@end smallexample

@noindent
このような特性をもつのは以下の言語です:

@table @asis
@item Slavic family
Russian, Ukrainian, Belarusian, Serbian, Croatian 
@end table

@item 3つの形式があり、1と、2、3、4を特別なケースとして扱うもの
ヘッダーエントリーは以下のようになります:

@smallexample
Plural-Forms: nplurals=3; \
    plural=(n==1) ? 0 : (n>=2 && n<=4) ? 1 : 2;
@end smallexample

@noindent
このような特性をもつのは以下の言語です:

@table @asis
@item Slavic family
Czech, Slovak 
@end table

@item 3つの形式があり1と、2、3、4で終わる数字を特別なケースとして扱うもの
ヘッダーエントリーは以下のようになります:

@smallexample
Plural-Forms: nplurals=3; \
    plural=n==1 ? 0 : \
           n%10>=2 && n%10<=4 && (n%100<10 || n%100>=20) ? 1 : 2;
@end smallexample

@noindent
このような特性をもつのは以下の言語です:

@table @asis
@item Slavic family
Polish 
@end table

@item 4つの形式があり1と、02、03、04で終わるすべての数字を特別なケースとして扱うもの
ヘッダーエントリーは以下のようになります:

@smallexample
Plural-Forms: nplurals=4; \
    plural=n%100==1 ? 0 : n%100==2 ? 1 : n%100==3 || n%100==4 ? 2 : 3;
@end smallexample

@noindent
このような特性をもつのは以下の言語です:

@table @asis
@item Slavic family
Slovenian 
@end table

@item 6つの形式があります。1つ目は0、2つ目は1、3つ目は2、4つ目は03、...、10で終わるすべての数字、5つ目は11、...、99で終わるすべての数字、そして6つ目はそれ以外です。
ヘッダーエントリーは以下のようになります:

@smallexample
Plural-Forms: nplurals=6; \
    plural=n==0 ? 0 : n==1 ? 1 : n==2 ? 2 : n%100>=3 && n%100<=10 ? 3 \
    : n%100>=11 ? 4 : 5;
@end smallexample

@noindent
このような特性をもつのは以下の言語です:

@table @asis
@item Afroasiatic family
Arabic 
@end table
@end table

ここまで読んで、あなたは思うかもしれません。@code{ngettext}が扱う@var{n}の型は@samp{unsigned
long}だ。では、もっと大きな整数型の場合はどうだろうか? 負の数値については? 浮動小数値の場合は?

@samp{uintmax_t}や@samp{unsigned long
long}のようなより大きな数値のための整数型の場合、これらの数値は@samp{unsigned
long}の範囲に適合するように値を小さくして処理できます。この場合、単に値を@samp{unsigned
long}にキャストするのは正しくありません(キャストでは@code{ULONG_MAX + 1}は0、@code{ULONG_MAX +
2}は1、...のようにキャストされます)。あなたは、いままで紹介してきたすべてのplural
formで、100(または1000や1000000)で除する方法によって数式を間接的に評価できるという事実を見てきたでしょう。もし大きな数値を、下6桁を保持して[1000000,
1999999]という範囲の他の数値に置き換えられれば、同じplural formの選択方法で取り扱えます。この場合のコードは以下のようになるでしょう:

@smallexample
#include <inttypes.h>
uintmax_t nbytes = ...;
printf (ngettext ("The file has %"PRIuMAX" byte.",
                  "The file has %"PRIuMAX" bytes.",
                  (nbytes > ULONG_MAX
                   ? (nbytes % 1000000) + 1000000
                   : nbytes)),
        nbytes);
@end smallexample

負の数や小数については、通常はsingularかpluralが明解でない物質量に適用されます。このようなケースでは、@code{ngettext}を使う必要はなく、単にすべての値に適切な形式を指定して@code{gettext}を呼び出します:

@smallexample
printf (gettext ("Time elapsed: %.3f seconds"),
        num_milliseconds * 0.001);
@end smallexample

@noindent
@var{num_milliseconds}が1000の倍数のようなときでも、出力は以下のようになります
@smallexample
Time elapsed: 1.000 seconds
@end smallexample
@noindent
これは、Englishや他の言語でも許容できる出力です。

plural formにたいする翻訳者の考え方については、@ref{Translating plural forms}で説明しています。

@node Optimized gettext
@subsection *gettext関数の最適化
@cindex optimization of @code{gettext} functions

この点を議論するには、GNU
@code{gettext}の実装の優位性について話す必要があります。インターナショナライズされたプログラムは、翻訳する必要のある文字列がループ内にあるような場合に性能が劣化すると思う読者がいるかもしれません。たしかにループを実行するごとに文字列が評価されることによる劣化は無視できません。ループの実行中に文字列が変化しない場合に毎回文字列を翻訳する場合は、時間の無駄になります。以下の例で考えてみましょう:

@example
@group
@{
  while (@dots{})
    @{
      puts (gettext ("Hello world"));
    @}
@}
@end group
@end example

@noindent
選択したlocaleが実行中に変更されないような場合、翻訳結果の文字列は常に同じです。以下のようなやり方も1つの方法です:

@example
@group
@{
  str = gettext ("Hello world");
  while (@dots{})
    @{
      puts (str);
    @}
@}
@end group
@end example

@noindent
しかしこの解決策は、すべての状況で使える訳ではありません(例: 実行中にlocaleが変更される場合)。また、コードも読みにくくなってしまいます。

この理由により、GNU
@code{gettext}は以前の結果をキャッシュしています。同じ翻訳が2度要求された場合、要求の間に新たなメッセージカタログがロードされていなければ、2度目の呼び出しでは@code{gettext}は結果をキャッシュから取得します。

@node Comparison
@section 2つのインターフェースの比較
@cindex @code{gettext} vs @code{catgets}
@cindex comparison of interfaces

@c FIXME: arguments to catgets vs. gettext
@c Partly done 950718 -- drepper

以下の議論は幾分誇張されたものかもしれません。これまで述べてきたように、わたしたちはUniforumの勧告にしたがう理由があって、GNU
@code{gettext}を実装しました。しかし、どのようにしてこの決定に至ったかをお見せするべきでしょう。

最初に開発プロセスを概観してみましょう。わたしたちが@code{gettext}により提供されるNLSを使ってアプリケーションを記述するときは、いつものとおり処理のことです。ユーザーの目に触れるので文字列を翻訳する必要があるときだけ、わたしたちは@code{"@dots{}"}のかわりに@code{gettext("@dots{}")}を使って翻訳を行います。各ソースファイル(または中核となるヘッダーファイル)で、以下を定義します

@example
#define gettext(String) (String)
@end example

この定義により、システムのCライブラリー自体で@code{gettext}がサポートされていても、それを無効化できます。このコードをコンパイルすると、NLSコードを使わない場合と同じ結果が得られます。GNU
@code{gettext}のコードを見ると、@code{gettext("@dots{}")}のかわりに@code{_("@dots{}")}を使っているのがわかるでしょう。これにより翻訳可能な文字列のために余分にタイプしなければならない文字数を3文字まで減らせます。

これを出荷するバージョンのプログラムにする場合は、単に以下の定義

@example
#define _(String) (String)
@end example

@noindent
を、以下の定義に置き換えるだけで済みます。

@cindex include file @file{libintl.h}
@example
#include <libintl.h>
#define _(String) gettext (String)
@end example

@noindent
そして、翻訳可能な文字列を含むすべてのソースファイルにたいして@file{xgettext}プログラムを実行します。わたしたちは翻訳が利用できないものにたいしても、利用可能になったら使えるように、プログラムを実行します。

@cindex @code{N_}, a convenience macro
同様のことは@code{gettext_noop}呼び出しでも行うことができます(@ref{Special
cases}を参照してください)。@code{gettext_noop}は通常、no-op(訳注: no-operation = 何もしない)
マクロとして定義します。プロジェクトでは以下のようなコードを考慮する必要があります:

@example
#define gettext_noop(String) String
#define N_(String) gettext_noop (String)
@end example

@code{N_}は、@code{_}と同様、省略形です。GNU
@code{gettext}の@file{po/}ディレクトリーにある@file{Makefile}は、これらの省略形を認識するので、必要に応じて使うことができます。

今度は@code{catgets}を見てみましょう。主な問題点はプログラマー向けの機能にあります。彼は、翻訳可能な文字列ごとに、毎回異なる数字(または記号定数)を割り当てる必要があります。彼は重複したエントリー、重複したメッセージID、etc...にも注意を払わなければなりません。もしGNU
@code{gettext}プログラムが提供するのと同じ品質をメッセージカタログにもたせたい場合、文字列にたいする説明コメントやソースコード中での場所をメッセージカタログに記述しなければなりません。これはほとんどMission:
Impossibleでしょう。

しかし@code{catgets}の優位性を語る人たちが触れる点もいくつかあります。文字列内にある単語があり、その文字列が異なるコンテキストや他の言語で使われている場合に、その単語は異なる翻訳をもつことができます。以下に例を示しましょう:

@example
printf ("%s: %d", gettext ("number"), number_of_errors)

printf ("you should see %d %s", number_count,
        number_count == 1 ? gettext ("number") : gettext ("numbers"))
@end example

この例では、@code{"number"}という文字列を2回翻訳する必要があります。たとえあなたがEnglishに類する言語を話さなくても、この単語が2つの文で異なる意味をもつかもしれないことに気づくでしょう。Germanでは、1番目にたいして@code{"Anzahl"}、2番目には@code{"Zahl"}と翻訳する必要があります。

これであなたはこのが難解な例だということに同意するでしょう。そしてあなたは間違っていません!
では問題を正確に把握して、その問題がそれほど深刻ではないことにも気づくはずです。この問題は以下のようにして簡単に解決することができます:

@example
printf ("%s %d", gettext ("number:"), number_of_errors)

printf (number_count == 1 ? gettext ("you should see %d number")
                          : gettext ("you should see %d numbers"),
        number_count)
@end example

わたしたちは、この方法で文字列の競合はすべて解決できると信じます。もし競合する文字列の一方を変更するのが困難なら、もう一方の文字列を少しだけ変更することも考慮できます。これを克服するのは不可能ではありません。

@code{catgets}は、同じ元文字列にたいして異なる翻訳をもたせることができます。@code{gettext}では同じ元文字列にたいして異なる翻訳をもたせることはできませんが、この種のあいまいさによる問題を解決する、よりスケーラブルな解決策があります。@ref{Ambiguities}を参照してください。

@node Using libintl.a
@section 独自のプログラム内でlibintl.aを使用する

ライブラリーのバージョン0.9.4から始める場合、@code{libintl.h}は自己充足的になっています(例:
追加の関数なしでプログラムで使用できます)。ヘッダーとライブラリーは@file{Makefile}により、@code{$(prefix)}で選択されたディレクトリーに配置されます。

@node gettext grok
@section @code{gettext}を根底から理解する

@strong{注意: }このセクションの文書は時代遅れになっているので、改訂する必要があります。

ソースコードを読むことは、GNU
@code{gettext}の機能を完全に活用するための助けになるでしょう。しかし、(時として込み入った内容の)コードを読むために時間
費やすことを望まない人々のために、幾つかのコメントを挙げておきます:

@itemize @bullet
@item 実行時に言語を変更する
@cindex language selection at runtime

対話的なプログラムにおいては、使用する言語を実行時に尋ねたほうが有用であることがあります。これを理解するためには、@code{gettext}関数が使用する言語をどのように決定しているのかを知る必要があります。ここに示す方法はGNUによる@code{gettext}関数の実装においてのみ正しいものです。

dcgettext関数は呼出しごとに、環境変数の中で最高のプライオリティを持つものを探し出して使用します。プライオリティは以下のリストで示されます。プライオリティは下にいくにつれて低くなります。

@enumerate
@vindex LANGUAGE@r{, environment variable}
@item @code{LANGUAGE}
@vindex LC_ALL@r{, environment variable}
@item @code{LC_ALL}
@vindex LC_CTYPE@r{, environment variable}
@vindex LC_NUMERIC@r{, environment variable}
@vindex LC_TIME@r{, environment variable}
@vindex LC_COLLATE@r{, environment variable}
@vindex LC_MONETARY@r{, environment variable}
@vindex LC_MESSAGES@r{, environment variable}
@item @code{LC_xxx}、選択されたロカールによる
@vindex LANG@r{, environment variable}
@item @code{LANG}
@end enumerate

その後、検索された値を用いてパスが設定され、可能であれば翻訳ファイルがロー ドされます。

「今」とは、@code{LANGUAGE}が変更されたときです。上で説明した過程に従い、この変数の新しい値は@code{dcgettext}関数が呼び出された時点で決定されます。これは(おそらく)異なったメッセージカタログがロードされることを意味します。即ち、使用する言語が変更されるのです。

しかし、これは一つの小さなフックに過ぎません。 gcc
2.7.0以上のコードでは幾分の最適化が図られています。この最適化は通常、@code{dcgettext}関数の呼び出しによって新しいカタログがロードされる前に行われます。しかし、もしdcgettextが呼び出されなければ、プログラムもまた@code{LANGUAGE}変数の値が変更されたことを知ることができないでしょう(@ref{Optimized
gettext}を参照してください)。この解決方法は非常に簡単です。以下のコードを言語変更関数の前に 置けばよいのです。

@example
  /* Change language.  */
  setenv ("LANGUAGE", "fr", 1);

  /* Make change known.  */
  @{
    extern int  _nl_msg_cat_cntr;
    ++_nl_msg_cat_cntr;
  @}
@end example

@cindex @code{_nl_msg_cat_cntr}
変数@code{_nl_msg_cat_cntr}は@file{loadmsgcat.c}中で定義されています。あなたはこれが何のためのものなのか知る必要はありません。しかし、これは、ある@code{gettext}実装がGNU
gettextなのか、それとも非GNUシステムのネイティブのgettext実装なのかを決定するために使用できます。

@end itemize

@node Temp Programmers
@section プログラマの章についての一時的なメモ

@strong{注意: }このセクションの文書は時代遅れになっているので、改訂する必要があります。

@menu
* Temp Implementations::     Temporary - Two Possible Implementations
* Temp catgets::             Temporary - About @code{catgets}
* Temp WSI::                 Temporary - Why a single implementation
* Temp Notes::               Temporary - Notes
@end menu

@node Temp Implementations
@subsection 一時的な情報 - 二つの実装

言語に依存せずにメッセージを扱う二つの手法があります。一つはX/Openの
catgetsによるものであり、もう一つはUniforumのgettextによるものです。catgetsによる方法では、整数によってメッセージを指定します。gettextによる方法では、英語のメッセージによって指定します。catgetsによる方法は長く使われ、多くのベンダでサポートされています。gettextによる方法ははSunでサポートされていて、COSEマルチベンダイニシアティブ(COSE
multivendor initiative)がサポートするようです。どちらもPOSIX標準とはなりませんでした。POSIX.1
委員会では、この件に関して様々な見解の相違がありました。

二つの手法のいずれもPOSIX標準ではありません。@code{gettext}と@code{catgets}(XPG)ルーチンのいずれを標準として採用するかについて、POSIX.1
委員会ではは様々な議論がなされました。委員会の終盤に至っても何らの合意は得られず、結局メッセージングシステムは標準規格には含まれませんでした。私はXPG3メッセージングインターフェースに関する追記を標準に付与するのは有益であると信じていますし、``...メッセージングシステムの実例は既に実装されているのです...''

委員会は、ある一つのインターフェースの実装を使うのが良いということをどの場所でも言わないように非常に注意していました。この話題に関するこれ以上の情報
については、国際化プログラミングFAQ(Programming for Internationalization FAQ)を参照して下さい。

@node Temp catgets
@subsection 一時的な情報 - @code{catgets}について

@code{catgets}を基盤として使用することに関する討議の末期には、幾つかの議論がありました。その議論の両側を提示することは大切だと思いますし、これから、私はちょっとしたことに対して「悪魔の弁護士」となってみることにします。

@code{catgets}はもっと良くデザイン出来たでだろうということは否定しません。その実装には既に指摘したような制限が少なからずあります。

しかしながら、その一貫性と標準化の度合いについては申し分ありません。UNIXソフトウェアを書くときに繰り返し発生する問題とは、UNIXプラットフォーム間での移植性に関する問題です。それは全ての
UNIXベンダがオペレーティングシステム上を調べて改良する部分を見つけたようなものです。疑いもなく、これらの修正は革新的なものであり、現実の問題を解決するものです。しかしながら、ソフトウェアベンダがこれらの変更を多くのプラットフォームで行いつづけるには、多くの労力が必要です。

そしてこれは各UNIXベンダが自社のシステムを標準化することを促進します。Spec1170に準拠するためにです。各主要UNIXベンダはこの標準化のために委員会を設けました。そして全てのUNIXソフトウェア開発者はこの標準に従ってソフトウェアを作成し、異なるプラットフォームへソフトウェアを導入する際には
(autoconfを使うことなく)リコンパイルするだけで済むようになる日を心待ちにし ているのです。

私の理解しているところでは、Spec1170はX/Open Portability
Guidelinesのバージョン4(XPG4)に基づいたものです。@code{catgets}とその眷属がXPG4で定義されているので、私は@code{catgets}がSpec1170の一部であり、それがすべてのUNIXシステムの標準的なコンポーネントになることを信じています。

@node Temp WSI
@subsection 一時的な情報 - なぜ一つの実装なのか

メッセージカタログにアクセスするために二つの異なるシステムをインストールすることは不経済なことのように思えます。我々が@code{catgets}の不足しているものを改善したいと思ったのなら、なぜ新しいシステムを実装するのではなく、@code{catgets}を(互換性を保ちながら)拡張しようとしないのでしょうか?
いずれにせよ我々は、メッセージカタログにアクセスするためのシステムをオペレーティ
ングシステムに対して二つインストールすることになるでしょう。一つはGNUソフ
トウェアのためルーチン群であり、もう一つはその他全てのソフトウェアのためのルーチン群(catgets)です。傲慢でしょうか?

カタログにアクセスする別のシステムが実装されたと仮定してみましょう。我々がお奨めするのはどちらでしょうか?
少なくともLinuxシステムに対しては、我々は可能な限り多くのソフトウェア開発者を呼び込む必要があります。そのため、我々はソフトウェア開発者が彼らのソフトウェアを移植しやすいようにする必要があります。そしてそれは@code{catgets}をサポートすることを意味します。我々は
@code{libintl}コードを@code{libc}中に実装するでしょうが、@code{libc}には別のメッセージカタログに対するアクセス方法を同じように取り込まなければいけないということなのでしょうか?
そして、@code{libintl}と非@code{catgets}ルーチンを組み合わせて使おうとする人達に関してはどうでしょうか?ソフトウェア開発者が彼らのソフトウェアを他のプラットフォームに移植する際、彼らはそのソフトウェアに単に@code{libintl}を含めるだけでなく、フロントエンド(@code{libintl})コードと、バックエンド(非@code{catgets}アクセスルーチン)コードを付け加えようとするでしょう。

しかしメッセージカタログのサポートは氷山の一角に過ぎません。他のロカールカテゴリのデータはどうでしょうか。それらもまた、多くの相違点を持っています。我々はそれに対処することを諦めて、重複したルーチン群を別々に開発せねばならないのでしょうか(@code{libintl}をメッセージカタログサポート以上のものにすべきなのでしょうか)?

UNIX上の改良可能な多くの部分と同じように、我々は将来に向けて改良を加えつつも、過去のものに対する互換性を落とさないようにしていました。

@node Temp Notes
@subsection 一時的な情報 - ノート

多くの実装が最終形式からかけ離れたものであったため、X/Openが標準形式を承認するのは非常に遅くなりました。私の使っている両方のシステム(古いLinux
catgetsとUltrix-4)には奇妙なバリエーションがあります。

最後の変更を加えた後、私はGNU/Linux
@code{libc}の@code{gettext}関数群を作成するために時間を割かねばなりませんでした。従って、将来的にはSolarisが@code{gettext}を備えた唯一のシステムであるということはなくなります。

@node Translators
@chapter 翻訳者の視点

@c FIXME: Reorganize whole chapter.

@menu
* Trans Intro 0::            Introduction 0
* Trans Intro 1::            Introduction 1
* Discussions::              Discussions
* Organization::             Organization
* Information Flow::         Information Flow
* Translating plural forms::  How to fill in @code{msgstr[0]}, 
                                @code{msgstr[1]}
* Prioritizing messages::    How to find which messages to translate first
@end menu

@node Trans Intro 0
@section イントロダクション0

@strong{注意: }このセクションの文書は時代遅れになっているので、改訂する必要があります。

GNUは国際化しつつあります!
翻訳プロジェクトは保守担当者、翻訳者、そしてユーザーを全てまとめるもので、そのためGNUソフトウェアは徐々に多くの言語を喋ることが出来るようになります。

GNU
@code{gettext}ツールセットには、保守担当者がパッケージのメッセージを国際化するために必要となる@emph{全て}があります。また、パッケージが国際化された後で、翻訳者がメッセージの地域化を行う際の助けになるような便利なツールもあります。

翻訳プロジェクトを完遂するために、我々は自分の国の言葉を愛し、良く書くことが出来、そして他の翻訳者が話しているのと同じ言語で助けることの出来る(synergize)能力を持った人間を数多く必要としています。もしあなたが翻訳チームでボランティアとして働くことを望むなら、該当する翻訳チームにメー
ルを出して下さい。

各チームはLinux
Internationalの好意による自身のメーリングリストを持っています。@file{@var{ll}@@li.org}というアドレスの@var{ll}をあなたの注目する言語の@w{ISO
639}の二文字コードに置き換えることによって、その言語の翻訳チームに連絡できます。言語コードは@w{ISO
3166}に定められている国コードと同じではありません。現時点では以下の翻訳チームが存在します。

@quotation
Chinese @code{zh}、Czech @code{cs}、Danish @code{da}、Dutch @code{nl}、Esperanto
@code{eo}、Finnish @code{fi}、French @code{fr}、Irish @code{ga}、German
@code{de}、Greek @code{el}、Italian @code{it}、Japanese @code{ja}、Indonesian
@code{in}、Norwegian @code{no}、Polish @code{pl}、Portuguese @code{pt}、Russian
@code{ru}、Spanish @code{es}、Swedish @code{sv}、Turkish @code{tr}。
@end quotation

@noindent
仮に中国語翻訳チームにメールを出すとすれば、@file{zh@@li.org}となります。翻訳チームのメンバーになるには、その言語チームのメーリングリストに登録する必要があります。例えば、スウェーデン人は本文に以下の内容を記述して@w{@file{sv-request@@li.org}}にメールを出します。

@example
subscribe
@end example

チームのメンバーは翻訳@emph{作業}に興味を持つべきだということを心に留めて置いて下さい。そうでなければ翻訳を果たすことは難しいのです。もしが希望する言語のチームがまだ存在せず、その言語のチームを作りたいという場合には@w{@file{coordinator@@translationproject.org}}まで連絡して下さい。それによって全ての翻訳チームの調整者に連絡が取れます。

一握りのGNUパッケージには幾つかの言語に対するメッセージの翻訳が適用・提供
されています。翻訳チームは組織化され始めており、これらのパッケージを起点として使っています。しかしまだまだ多くのパッケージがあり、多くの言語についてはボランティアの翻訳者がいません。もし翻訳チームでボランティアとして作業したいと思うのでしたら、@file{coordinator@@translationproject.org}に作業することの出来る言語を明記してメールを送って下さい。

@node Trans Intro 1
@section イントロダクション1

@strong{注意: }このセクションの文書は時代遅れになっているので、改訂する必要があります。

現在公式に、GNUは国際化しつつあります! 以下は1995年1月のGNU Bulletinで述べられた声明です。

@quotation
一握りのGNUパッケージには幾つかの言語に対するメッセージの翻訳が適用・提供されています。翻訳チームは組織化され始めており、これらのパッケージを起点として使っています。しかしまだまだ多くのパッケージがあり、多くの言語についてはボランティアの翻訳者がいません。もし翻訳チームでボランティアとして作業したいと思うのでしたら、@samp{coordinator@@translationproject.org}に作業することの出来る言語を明記してメールを送って下さい。
@end quotation

本ドキュメントはその過程に興味を持ったり、貢献したいと考えている人々が持つ多くの疑問に答えます。願わくばざっと目を通し、GNUの国際化に対するこの集合的努力から産み出される大量のメールの幾ばくかでもを担当して下さい。

広く共用される多くのフリーソフトウェアのプログラミングは英語で行われています。そして現在のところ、英語はGNUプロジェクトに協力する国家的コミュニ
ティ間での主要なコミュニケーション言語として使われています。このドキュメントでさえも英語で書かれています。これは当面変わらないでしょう。

しかしながら、多くのソフトウェアで自国語や自国の習慣を用いたいという、国家的コミュニティからの強い欲求があります。また、GNUソフトウェアをそのようにするための努力が現在も行われています。この試みは今までのところプリテスタからの熱心な反応の向上によって動かされており、我々はGNUの国際化は成功すると信じています。

このドキュメントに対する内容の明確化、追加、訂正に関する提案については、@file{coordinator@@translationproject.org}までメールを送って下さい。

@node Discussions
@section 議論

@strong{注意: }このセクションの文書は時代遅れになっているので、改訂する必要があります。

この国際化の効果を目の当たりにして、幾人かのユーザが彼らの考えを表明しています。紹介され議論されたこれらの疑問の幾つかをここに挙げてみましょう。

@itemize @bullet
@item より小さいグループ

幾つかの言語は多くの人々によって話されていないため、その言語を話す人々はフリーソフトウェアパッケージの当該言語版に対する必要性はあまりないと考えています。更に、幾つかの国にいるコンピュータの@emph{中にいる}多くの人々は一般的に英語版ソフトウェアのほうを好むようです。

一方で、人々は自分達の言語を非常に好きですし、彼らのお気に入りのフリーソフトウェアが彼らの母国語を喋ることが出来るように努力します。彼らは個人的な楽しみのためにそれを行います。そしてどのくらいの人間がその作業によって便益を得るかなどといったことは考えません。

@item 解釈の誤り

ある種の誤ったプロパガンダのせいか、一部のユーザは自身の言語を押し出すことについて臆病になっています。ある人は、ネットワークの向こう側にはその言語をうるさくせがむユーザがいるに違いないと考えています。

しかしあらゆる言語には地域化される価値があります。なぜなら、その言語が大切で敬愛されるものであると考える人々がその言語の向こうにいるからです。

@item 変な翻訳

誰もがメッセージを理解出来るためには、正しい翻訳を見つけ出すことがもっとも大きな問題となります。翻訳は通常、少し変なものなのです。一部の人々は、「どちらかといえば押しが強く、嫌でときどき滑稽な」彼らの言語に対する翻訳を行うことが出来る程度には英語を扱うことが出来ます。フランス語を話す人間として、私は韓国または台湾において商品の取扱説明書を貧弱なフランス語へと翻訳した経験があります。...

我々はときどきある種の国家的計算機文化を作り上げる必要があるというのは事実です。そして、その作業は彼らの母国語によって繋がっている多くの人間の協調作業なしに簡単に出来ることではありません。翻訳は彼ら自身の言語を知りそして愛する人々によってより良く行われ、より良い結果を得るという点において一緒に作業されるものなのです。

@item GPL(またはLGPL)への依存

何人かの人々は、彼らが彼らのプログラムをフリーにしたくない場合、又は別の種類の自由を与えたい場合に、GNU
@code{gettext}を使うことによって彼らのパッケージをGNU一般公有許諾書(GNU General Public
License)の保護の元で配布する必要があるのではないかと思案します。これに対する単純な答えは``通常はいいえ''です。

GNU @code{gettext}の@code{gettext-runtime}の部分(たとえば@code{libintl}のコンテンツ)は、GNU
Lesser General Public Licenseにより保護されています。GNU
@code{gettext}の@code{gettext-tools}の部分(たとえば、GNU
@code{gettext}パッケージの残りの部分)は、GNU General Public Licenseにより保護されています。

パッケージ中の僅かな地域化された文字列のマーキング、又は国際化のための条件つきの数行の包含はGPLまたはLGPLのコードを含んでいません。しかしながら、@code{libintl}内の地域化ルーチンそれ自身はLGPLの元にあり、LGPLとして考慮される必要があります。これは、たとえ非フリーなプログラムでさえ、変更されていない@code{libintl}の完全なソースコードを配布する権利を与えます。これはまた、非フリーなプログラムでさえ、共有ライブラリーとして@code{libintl}を使用する権利を与えます。しかしこれは、フリーなソフトウェアーだけにたいして、静的ライブラリーとして@code{libintl}を使用、または他のライブラリー内に@code{libintl}を含める権利を与えます。

@end itemize

@node Organization
@section 組織

@strong{注意: }このセクションの文書は時代遅れになっているので、改訂する必要があります。

大きな尺度で見れば、真の解決方法は有志が参加できるようなある種の正しく厳密な集合を組織化することでしょう。私は、最近このアイディアについて幾つかの考察を行い、幾つかの微妙なポイントがあるであろうことを認識しています。私は、そのようなプロジェクトを開始するために、Richard
Stallmanに連絡することを考えましたが、まず最初に我々の間でアイディアを揺り落とすことが良いだろうと感じました。おそらく、Linux
Internationalは既にこの分野における幾らかの経験、または、有志の作業のオーケストラのようなものを持っています。あらゆる場合に、思考のための食物を!

我々は早々に何らかの方法で何かをセットアップせねばならないと考えます。同じ言語に対する作業のインターロックと重複を避けるという点で、それは多くの言語のコントリビュータを助けるでしょう。そして、更にそれらの言語(大部分の言語では技術的な英語の翻訳について独特な多くの問題点があります)についての独特な問題を共に解決するように連絡が取れるようにします。スウェーデンのコントリビュータはこれらの問題点を認め、そして私はフランス語においてのそれらの問題点に相当に気が付いています。

確かにこれは技術的問題ではありません、しかし我々は、コントリビュータ、及び管理者間の国家チーム層のインターフェースに関わらず、ロカールコントリビュータの努力が最大限に有益になるように管理するべきです。

翻訳プロジェクトは言語コーディネータを統合するためにある準備を必要とします。一度この作業が始められたなら、発展中のプログラムのローカライズは、確かにフリーソフトウェアコミュニティにおいて永久の、そして、連続的な動きになるでしょう。GNU
@code{gettext}が公式の現実になる前に、最小限の準備が完了し、そしてテストされているべきです。電子メールアドレス@file{coordinator@@translationproject.org}は、これらの話題に基づくボランティア、及び、一般的な電子メールから申し出を受けるための準備でした。このアドレスは、翻訳プロジェクトのコーディネータに届きます。

@menu
* Central Coordination::     Central Coordination
* National Teams::           National Teams
* Mailing Lists::            Mailing Lists
@end menu

@node Central Coordination
@subsection 中央による調整

そのことについて考えるよりも更に早く、GNUは誰かがそれらのグループを組織化し調整する方法を準備する必要があると私もまた考えます。ある種のグループのグループです。GNUは直ちに共同で働いているボランティアの小さなグループにこのタスクを委託することが良いだろうと、私は考えています。
おそらく、この国家委員会的なグループのリストは@file{gnu.announce}において公表され得ます。

コーディネータとしての私の役割は単に、Ulrichをフリーソフトウェアの地域化に興味を持っているドイツ語を話すボランティアに紹介すること、そして国家的グループの準備が出来るまでの国家的登録機関のメンテナンス中に、国家的グループの最初の組織化を助けることです。実際、コーディネータは、ボランティアが国家チーム(言語または国(局地的言語)について1人のコーディネータを選択するべきです)を作成するために相互と連絡を取りやすくせねばなりません。これが正しく行われたならば、コーディネーションは不可抗力的作業を除いて便利なものとなり、代理人に時間を任せることが出来るようになります。

@node National Teams
@subsection 国家チーム

私は、我々が個々の言語のための有志のコーディネータ/エディタを捜すことを提案します。これらの人々は彼ら自身の言語のために、様々なプログラムの翻訳ファイルを探し出し、そして、語法に対する高度で一定の標準を保証することになるで
しょう。

今までの他の人々との間の私の現在の経験によれば、地域化を実現する人々はこのプロセスに対して非常に熱心であり、彼らは自分自身が地域化するプログラムよりも地域化のプロセスにほうに興味を持ち、それだけでなく多くのプログラムを地域化したいと思うものです。この事実は、各言語のためのコーディネータ/エディタを持つことは良いアイディアであることを確信させます。

我々は、問題となる言語において明瞭かつ簡潔な文章を書く際、適任となる人物を選択する必要があります。これは難しい作業です ---
我々は、自分自身でそれをチェックすることができません。従って、我々は数人の人間対してに互いの記述を判断するように要請し、そして最適任者を選択する必要があります。

私は私のプレリリースを20人から30人の人々に発表ましたが、そのプレリリースが既に生み出した全ての議論をあなたは信じないでしょう。私は、真に、公式に、世界中でこの作業が開始されるときに起こるであろうことを想像すると身震いがします。例えば、相互に反論しあう二人のチェコスロヴァキアのユーザーの間を仲裁するのは私なのでしょうか?

私がこれらの公式化について判断することが出来ないように、あなたのドイツ語が私のフランス語よりはるかに良いとは限らないと推測します。私が提案するものは、各言語に対してPOファイルをメンテナンスしその変更を判定する人々のグループを置くということです。そのような人々のグループがどのように行動するかについて、グループ間には文化的な相違点があると考えます。幾つかのグループはは緩い方法を採用し、簡単にコンセンサスの一致に達し、グループ中の誰もが保守者に関わることができます。一方は死ぬまで戦い、重い管理を国家の標準にまで組織化し、厳密なチャネルを使用するでしょう。

ドイツのチームは良い例を出しています。直ちに、彼らはおそらくお互いの翻訳を訂正する半数の人々と言語上の論点について議論する半ダースの人々です。私は全ての名前を知っているわけではありません。Ulrich
Drepperはドイツのチームのコーディネートを担当しています。彼は私のプレテストのリストの購読を申し込みました。従って、私は彼に対して、連絡されるリリースの詳細について警告する必要は特にありません。

各言語を担当する翻訳チームを得るためには、それはよいアイディアだと思います。 翻訳を更に良く首尾一貫した状態にするでしょう。

@menu
* Sub-Cultures::             Sub-Cultures
* Organizational Ideas::     Organizational Ideas
@end menu

@node Sub-Cultures
@subsubsection サブカルチャー

フランス語を例に取ってみましょう。コンピュータの世界では、意味が異なる語彙を持つ幾つかのサブカルチャーがあります。組織化された方法でこの問題を提起することなしにあちこちでボランティアを選んでいると、プロジェクトにはすぐに国際化されたプログラムのごちゃ混ぜ状態が発生します。そしてことによると、実際にこの問題を気にする人々の間で終りなき口論が始まるでしょう。

国際化されたプログラムをフランス語へ地域化する過程において、ある種の統一を保つことは難しい(そしてデリケートな)仕事です。フランス人のラテンな人柄
(:-)
を知っていても、もし我々がこのことを間違った方法で捉えれば、我々はどことも知れぬ場所で終わってしまうか、多くのエネルギーを無駄にしてしまうことでしょう。おそらく我々は、GNU
@code{gettext}が公式に発表される前に真剣にこの問題に取り組まなければならないでしょう。そして、それはすぐではないかと私は推測します!

@node Organizational Ideas
@subsubsection 組織化へのアイディア

私は、公式リリース後に次の大きな変更があると考えています。どうか、私が短いGPLメッセージのドイツ語翻訳を用いることに注目してください。我々は、フリーソフトウェアコミュニティにおける真の地域化が消え去ってしまう前に2、3の良い例を示す必要があります、ここでは、議論が必要ないくつかのポイントを示します。

@itemize @bullet
@item
各グループは、一つのFTPサーバ(少なくとも一つのマスタサーバ)を持つべきです。

@item
サーバ上のファイルは、最新版(もちろん!)を反映すべきであり、そしてサーバは、対応するするアーカイブと共にRCSディレクトリ(私は今、これを持っていません)をもまた含んでいるべきです。

@item
同じくChangeLogファイル(これはRCSアーカイブより有益ですが、しかしEmacsによって後から自動的に生成することが出来ます)を含んでいるべきです。

@item
@dfn{コアグループ}は、疑わしい変更について判定するべきです(現在、このグループは私だけで構成されていますが、私は時折他の人間に「これもまた仕事に見える」と尋ねます)。

@end itemize

@node Mailing Lists
@subsection メーリングリスト

GNU @code{gettext}に関するあらゆる問合せについては、以下に送ってください。

@example
@file{coordinator@@translationproject.org}
@end example

@file{*-pretest}リストは、私にとって本当に有益です、アイディアはおそらく、多くのGNU、及び、非GNUパッケージへと一般化されるでしょう。しかし、保守者以外の、彼/彼女の方法!

Fran@,{c}ois、我々は、チーム、チームをサポートするメーリングリストそしてログメンバを追跡するために、@file{gnu.ai.mit.edu}に適当なメカニズムを持って
います。我々は、あなたが使うわずかな優先権を持っています。これがあなたにとって問題ないならば、私はあなたに情報を与えることができます。

事物は変化しています! 2、3年前、Daniel
Feketeと私がGNU地域化のメーリングリスト(FSFの中にあった)に尋ねたとき、我々は作業をどこででも組織化するように礼儀正しく勧められ、そして我々はそれを実行しました。私のプリテスタと連絡を取るために、私は@code{majordomo}で管理される少数のメーリングリストをiro.umontreal.caに作成しました。これらのリストは今までのところ非常に信頼できました...

私は、ドイツ語のチームがドイツにあるメーリングリストを組織化し、他の国にも組織化をさせると思います。しかし組織化が行われる前に、FSFにおいて各国のチームのためのメーリングリストを提供することは確かに有益でしょう。そうです、私にどのようにメーリングリストを作成し扱えばよいかを説明して下さい。

我々は一時的なメーリングリストを、人々を組織化しやすいように国ごとに一つずつ作らねばなりません。なぜ一時的か、なぜなら一度再構成されたなら、各国のボ
ランティアは彼らのリストへと戻ってきて、そして自分達が望むように管理するだろうからです。このことについては、個々のチームは自分達の国の中から
自分達のリストを動かすだろうと思います。全てのチームが購読することの出来る、 中央のメーリングリストも作る必要があるでしょう。

@node Information Flow
@section 情報の流れ

@strong{注意: }このセクションの文書は時代遅れになっているので、改訂する必要があります。

パッケージが最終的にリリースされた後、このメッセージについての幾つかの議論があることでしょう。今、人々が更に良い幾つかのメッセージを提案したとしたら、あなたはどうしますか?
Jim、私が提供する1ダース近い地域化されたプログラムと同様、どうか直ちにそれらのメッセージに注目して下さい。私は翻訳とそれらに関する調整の両方を受け取るのです。

私が事前にテストするものを一つ置いたならば、Ulrichはその告知を受け取り、そしてそれを最後に修正するドイツ語のチームに渡します。そして彼は@emph{保守者}として私に翻訳ファイルを引き渡します。私が保守していないフリーのパッケー
ジについては何も聞きません。私が思うに、全ての翻訳プロジェクトにおいてこのスキームが作られるでしょう。セキュリティに関わる理由のために、おそらく
Ulrich(実際の国家的コーディネータ)は時折翻訳プロジェクト(Jim、私、又はLenの新人)によって保持される中央のレジストリをアップデートすべきです。

私は小さなGNUパッケージは一週間に一つずつ、より大きなパッケージは数週間か数ヵ月をかけるという責務を私自身に課し、12月か1月には私はにGNUの全パッケー
ジを国際化する準備を積極的に整えていました。しかし、それはそのようには動きません。私は最初に、私が責任を持つ全てのことを行いました。私は他の保守者の幾らかの伝道作業に対して何も持っていませんでした。しかし私もまた多くのエネルギーを失いました
--- 同じ議論を繰り返します。

そして、最初に地域化されたパッケージがリリースされるとき、我々は、醜悪な翻訳 :-)
についての多くの反応を得るでことしょう。確かに、そして我々は事前に、パッケージ保守者と国家チームの間の情報の流れを制御することに関する良いアイディアを持つ必要があります。

どうかどこかに各POファイルの迅速なヒストリを保存し始めて下さい。コメントを認めることによってファイルフォーマットがいずれ変更されるであろうことを私は知っています。各ファイルがログのようなもの、そしてコメントや不平の申し立て、又はその他の貢献をしたいと思う人々へのリファレンスを持つほうがよいでしょう。私は高速でフレキシブルなフォーマットに関する申し立てをしましたが、しかしそれはまだGNUの意思決定者によって受け入れられていません。私がこれについてより多くの情報を得たなら、このことについてお話しすることになるでしょう。

@node Translating plural forms
@section 複数形の翻訳

@cindex plural forms, translating
あなたがPOファイルを翻訳しようとしていて、それには以下のようなエントリーが含まれているとしましょう:

@smallexample
#, c-format
msgid "One file removed"
msgid_plural "%d files removed"
msgstr[0] ""
msgstr[1] ""
@end smallexample

@noindent
これはどういう意味なのでしょうか? どうやって記入すればよいのでしょうか?

このようなエントリーは、メッセージにplural formがあることを示しています。plural
formとは、メッセージ中の数字の値が複数形として出力しなければならない値の時に出力すべき文字列です。@code{msgid_plural}行に記述されているのは、Englishにおけるそのようなメッセージの一般的な形式です。@code{msgid}行には、Englishにおけるsingular
formで、数字の値が1のときに出力するテキストが記述されています。plural formについての詳細は、@ref{Plural
forms}で説明しています。

最初に見る必要があるのは、POファイルのヘッダーエントリーの@code{Plural-Forms}という行です。この行にはplural
formを判定するための数字と式が記述されています。まだPOファイルにそのような行がない場合は、追加する必要があります。これは、あなたが翻訳しようとしている言語に依存します。この情報は@code{msginit}コマンド(@ref{Creating}を参照してください)
-- これには既知のplural formulaのデータベースが含まれています -- を使うか、翻訳チームの他のメンバーに尋ねてみてください。

以下のような行について考えてみましょう:

@smallexample
"Plural-Forms: nplurals=3; plural=n%10==1 && n%100!=11 ? 0 : n%10>=2 && n"
"%10<=4 && (n%100<10 || n%100>=20) ? 1 : 2;\n"
@end smallexample

これは論理的には1行になります。POファイルの書式では、各行を80文字までにおさまるように長い行を分割できることを思い出してください。

@code{nplurals}の値は、3つのplural
formがあることを示しています。最初に行わなければならないのは、各形式ごとに@code{msgstr}を含むエントリーを作ることです:

@smallexample
#, c-format
msgid "One file removed"
msgid_plural "%d files removed"
msgstr[0] ""
msgstr[1] ""
msgstr[2] ""
@end smallexample

それから@code{msgid_plural}を翻訳して、各@code{msgstr}行にそれを記述します:

@smallexample
#, c-format
msgid "One file removed"
msgid_plural "%d files removed"
msgstr[0] "%d slika uklonjenih"
msgstr[1] "%d slika uklonjenih"
msgstr[2] "%d slika uklonjenih"
@end smallexample

ではplural
formに適合するように翻訳を改善しましょう。上述の式にしたがって、@code{msgstr[0]}には1で終わるが11では終わらない数字のときの翻訳を、@code{msgstr[1]}には2、3、4で終わるが12、13、14では終わらない数字のときの翻訳、そして@code{msgstr[2]}にはそれ以外のときに使用する翻訳を記述します。これにしたがって改善したものが以下の翻訳です:

@smallexample
#, c-format
msgid "One file removed"
msgid_plural "%d files removed"
msgstr[0] "%d slika je uklonjena"
msgstr[1] "%d datoteke uklonjenih"
msgstr[2] "%d slika uklonjenih"
@end smallexample

Englishのsingular
form(@code{msgid})では、数字用の書式指定が省かれて、数字の1をあらわす``one''という単語に置き換えられていることに気づくでしょう。あなたが翻訳するときも同じようできるでしょうか?

@smallexample
msgstr[0] "jednom datotekom je uklonjen"
@end smallexample

@noindent
これは@code{msgstr[0]}を1のときだけ使うのか、他の数字のときも使うかによります。plural
formulaに当てはめて考えると、@code{msgstr[0]}が@code{n ==
1}のときだけ、数字用の書式指定子を使わない特定の翻訳文を使うことができます。しかしこの例の場合、@code{msgstr[0]}は21、31、41...などのときにも使用するので、書式指定子を省くことはできません。

@node Prioritizing messages
@section メッセージの優先度: 最初に翻訳すべきメッセージを決める方法

翻訳者が週のうちパッケージに避ける時間が限られているにもかかわらず、パッケージにはとても多くのメッセージ(1000超)があるとしましょう。そのようなときは彼女は一番ユーザーの目に触れるメッセージ、または一番頻繁に発生するメッセージを訳したいと望むでしょう。このセクションでは、このような"もっとも緊急"なメッセージをどのように決定するか説明します。これは、すでに部分的に翻訳されたメッセージカタログの中から、"次に緊急"なメッセージを決定するのにも適用できます。

最初のステップとして、彼女は、ユーザーがプログラムを使うのと同様にしてプログラムを使ってみます。彼女がこれを行っているとき、プログラムがまだ翻訳されていないメッセージの翻訳にたいする要求があると、GNU
@code{gettext}ライブラリーはそれをログファイルに記録します。

次のステップで、彼女はPOモードを使って、それらのメッセージを翻訳するのです。

@vindex GETTEXT_LOG_UNTRANSLATED@r{, environment variable}
より詳細に見てみましょう。GNU @code{libintl}(GNU
@code{libc}の対応する関数とは異なる)は、環境変数@code{GETTEXT_LOG_UNTRANSLATED}をサポートします。GNU
@code{libintl}ライブラリーは@code{gettext()}、および関連する関数が翻訳を見つけられなかったとき、そのメッセージをログに記録します。ログファイルがない場合には、必要に応じて作成します。GNU
@code{libc}によるシステムでは、ELFの@samp{LD_PRELOAD}メカニズムで使用できる、共有ライブラリー@samp{preloadable_libintl.so}が提供されます。

GNU @code{libc}のシステムでは、翻訳者は最初のステップとして以下のコマンドを実行します:

@smallexample
$ LD_PRELOAD=/usr/local/lib/preloadable_libintl.so
$ export LD_PRELOAD
$ GETTEXT_LOG_UNTRANSLATED=$HOME/gettextlogused
$ export GETTEXT_LOG_UNTRANSLATED
@end smallexample

@noindent
他のシステムでは以下のコマンドを使います:

@smallexample
$ GETTEXT_LOG_UNTRANSLATED=$HOME/gettextlogused
$ export GETTEXT_LOG_UNTRANSLATED
@end smallexample

それから彼女はプログラムを使ってみます(あなたが翻訳を提供するプログラムを使うのはよいことですし、お勧めの練習方法です。これは必要なコンテキストを与えてくれます)。これが終わったら、彼女は環境変数を削除します:

@smallexample
$ unset LD_PRELOAD
$ unset GETTEXT_LOG_UNTRANSLATED
@end smallexample

次のステップは、重複を取り除くことです:

@smallexample
$ msguniq $HOME/gettextlogused > missing.po
@end smallexample

この結果はPOファイルですが、POファイルエディターで処理するためには、少し前処理が必要です。最初に、このファイルは多くの翻訳ドメインのメッセージを含んだマルチドメインのPOファイルです。次に、翻訳者のコメントとソースファイルへの参照が含まれていません。以下は、影響を受ける翻訳ドメインの一覧を得る方法です:

@smallexample
$ sed -n -e 's,^domain "\(.*\)"$,\1,p' < missing.po | sort | uniq
@end smallexample

それから翻訳者はドメインを1つずつ処理していきます。単純にするために、language、domain、source package
を環境変数に設定しましょう。

@smallexample
$ lang=nl             # your language
$ domain=coreutils    # the name of the domain to be handled
$ package=/usr/src/gnu/coreutils-4.5.4   # the package where it comes from
@end smallexample

彼女は、@file{$lang.po}の最新コピーを、翻訳プロジェクト、またはそのパッケージ(大抵は@file{$package/po/$lang.po})から入手します。もし彼女が、そのパッケージの最初の翻訳者の場合は、新規作成することになります(@ref{Creating}を参照してください)。それから彼女は、以下のコマンドを使って、緊急ではないメッセージにたいして
"obsolete" のマークを付与します（それらの翻訳済み、および未翻訳のメッセージが本当に "obsolete"
としてしまう訳ではありません。これは以下の編集で、POファイルエディターに、それらのメッセージを無視させるためです）。

@smallexample
$ msggrep --domain=$domain missing.po | grep -v '^domain' \
  > $domain-missing.po
$ msgattrib --set-obsolete --ignore-file $domain-missing.po $domain.$lang.po \
  > $domain.$lang-urgent.po
@end smallexample

それから彼女はPOファイルエディターを使って@file{$domain.$lang-urgent.po}を翻訳します(@ref{Editing}を参照してください)。(FIXME:
KBabelとgtranslatorが期待通りobsolete messageを保持してくれるかどうかについては、わたしにはわかりません)
そして彼女は最後に、以下のコマンドで緊急ではないメッセージ(およびすでに翻訳済みのメッセージの初期の"翻訳")を復元します:

@smallexample
$ msgmerge --no-fuzzy-matching $domain.$lang-urgent.po $package/po/$domain.pot \
  > $domain.$lang.po
@end smallexample

@file{$domain.$lang.po}を投稿したら、彼女は次のドメインを処理できます。

@node Maintainers
@chapter メンテナーの視点
@cindex package maintainer's view of @code{gettext}

パッケージのメンテナーには多くの責任があります。そのうちの1つは、たくさんのプラットフォームでパッケージを簡単にインストールできるようにすることで、わたしたちが前に説明したマジック(@ref{Users}を参照してください)を、インストーラーとエンドユーザーにたいして働くようにすることです。

GNU
@code{gettext}をディストリビューションに統合できるようにする方法はたくさんありますが、このチャプターではそれらを総括的にカバーすることはしません。かわりにGNU標準、さらにはGnits標準にしたがった、多くのフリーソフトウェアディストリビューションで利用可能なアプローチの詳細について議論します。なぜならGNU
@code{gettext}は、GNUプロジェクト全体のインターナショナリゼーションを助けるのを目的としているので、多くの有用でフリーなパッケージが対象となるからです。そのためこのチャプターでは、すでに@file{configure.ac}があり、GNU
Autoconfを使うパッケージを対象とします。

それにもかかわらずGNU
@code{gettext}は、GNU標準やその類にしたがっていないフリーパッケージにたいしても有用です。そのようなパッケージのメンテナーは自分の想像力と独創力によりディストリビューションを組織化する必要がありますが、@code{gettext}はすべての状況で動作するでしょう(そしてそのようなパッケージはたくさん存在します)。

@code{gettext}のメソッドは現在安定しているとはいえ、@code{gettext}の各バージョン間でちょっとした調整は必要になるでしょう。そのため、このチャプターの内容は、新たなリリースによる変更にしたがって読み替える必要があります。

@menu
* Flat and Non-Flat::        Flat or Non-Flat Directory Structures
* Prerequisites::            Prerequisite Works
* gettextize Invocation::    Invoking the @code{gettextize} Program
* Adjusting Files::          Files You Must Create or Alter
* autoconf macros::          Autoconf macros for use in @file{configure.ac}
* Version Control Issues::   
* Release Management::       Creating a Distribution Tarball
@end menu

@node Flat and Non-Flat
@section 非フラットなディレクトリー階層

フリーなソフトウェアパッケージの中には、@code{tar}により配布され、解凍すると単層のディレクトリーに展開されるものがあります。このようなパッケージを@dfn{flat}なディストリビューションと呼びます。それとは別に、Texinfoマニュアルやman
pageのためのサブディレクトリー@file{doc/}、Cライブラリーを置き換えたり保管する関数を保持する@file{lib/}、パッケージのソースの入った@file{src/}などの階層をもつ、フリーなソフトウェアパッケージも存在します。このようなディストリビューションのことを、@dfn{non-flat}であると呼びます。

flatなディストリビューションにたいして、わたしたちはあまり多くを語ることはできません。GNU
@code{gettext}を新しいバージョンにすることにより、flatなディレクトリー構造は難しさが増大するという欠点があります。たくさんのPOファイルがある場合、この単層のディレクトリーの内容は汚くなってしまうでしょう。またCソースに含まれる
GNU
@code{gettext}のlibintlのソース、シェルや@code{sed}のスクリプト、そして複雑なMakefileのルールは、flatな構造には適しません。これらの理由により、non-flatを使う方法を推奨します。

GNU
@code{gettext}自身もnon-flatな構造をもち、わたしたちはこの方法に精通していることも、わたしたちがこのチャプターでそれを説明しようとしている理由なのかもしれません。これを機会に、パッケージの構造をnon-flatにするメンテナーもいるかもしれません。

@node Prerequisites
@section 前提となる作業
@cindex converting a package to use @code{gettext}
@cindex migration from earlier versions of @code{gettext}
@cindex upgrading to new versions of @code{gettext}

パッケージにたいしてGNU
@code{gettext}を使用するためには、準備が少し必要です。これらの作業は、要点の説明だけだと肝心な部分がわからなくなってしまうある種の一般性をもっているので、このチャプターを読んで後から見返せるように、ここで大まかに説明しておきましょう。

@itemize @bullet
@item
@code{gettextize}を使う前に、最初に他のパッケージをインストールする必要があります。最新のバージョンのGNU @code{m4}、GNU
Autoconf、GNU
@code{gettext}がインストールされていることを確認してください。もしインストールされていない場合、それらを最初にインストールします。GNU
Autoconfをインストールする前に(たとえ@emph{configured}済みだとしても)、GNU
@code{m4}が完全にインストールされていなければならないことに注意してください。

パッケージ@code{automake}は、メンテナーのタスクを楽にするためにデザイン・実装されています。現在のGNU
@code{gettext}はこれらのツール、および@file{po/}ディレクトリーにある@file{Makefile}を使用するので、@code{automake}を使用するために必要なすべてのゴールを知っているのです。

これら4つのパッケージはメンテナーにとって必要なだけです。パッケージを正常にインストールして翻訳されたメッセージを正しく表示するだけなら、インストールする人やパッケージのエンドユーザーには、GNU
@code{m4}、GNU Autoconf、GNU @code{gettext}、GNU
@code{automake}は必要ありません。しかしパッケージにインターナショナライズされたシェルを含めて配布する場合、これは完全に真実とはいえなくなります:
ユーザーがシェルスクリプトの翻訳されたメッセージを見たいときは、GNU @code{gettext}のインストールが必要になります。

@item
パッケージは@file{configure.ac}か@file{configure.in}をもち、Autoconfを使用する必要があります。もしそうなっていない場合は、どのようにするか学ぶ必要があります。Autoconfのドキュメントはとてもよく書けているので、印刷して読んでみるのもよい考えでしょう。

@item
このマニュアルで前述したようにCソースを変更する必要があります。詳細は@ref{Sources}を参照してください。

@item
@file{po/}ディレクトリーには、翻訳チームから提出された@file{@var{ll}.po}という名前のPOファイルが、すべて保存されている必要があります。パッケージがインターナショナライズされて、それが利用可能になる前に翻訳作業を完了するのは、普通は簡単ではありません!
メンテナーにとって翻訳作業のサイクルを開始するのに簡単なのは、最初はPOファイルを何も用意せず、パッケージに興味をもつ翻訳チームが現れてPOファイルが投稿されるのを待つことです。

@end itemize

POファイルが投稿されたとき、メンテナーとしてどのように振る舞うのが理想的なのか、少し説明をしておきましょう。メンテナーとしてのあなたの役割は、その投稿が翻訳プロジェクト内の対応する翻訳チーム(わからないときは@file{coordinator@@translationproject.org}に転送してください)によるものであることを証明し、POファイルのフォーマットが壊れていてインストールできないくなっていないか確認し、それらのPOファイルを配布物の@file{po/}ディレクトリーに配置することです。

メンテナーとしては、翻訳が十分なのか、または完璧なのかをチェックする責任を負う必要はないので、語学に関する事柄については無視するべきです。翻訳チームは、チーム自身の運営と翻訳プロジェクトでの言語学的な選択について完全な責任を負います。翻訳チームがメンテナーにより運営されるのでは@emph{ない}ことを覚えておいてください。ユーザーからの言語上の指摘や報告などを、適切な翻訳チームに転送したり、ユーザーが翻訳チームに参加する方法を説明するような手助けをすることはできます。

メンテナーが翻訳チームを介さずに、自分でPOファイルに関するバグ報告を受けるのは@emph{決して行うべきではない}ことです。ある問題について翻訳者が彼女のチームと一致した見解をもつのが困難なとき、彼女が直接メンテナーと交渉するようなオプションが存在するべきではありません。どんな問題にせよ、彼らは問題をチーム自身で解決するべきです。メンテナーとしては、もしチームに本当に問題があると思えるときでも、あなた自身がチームの問題を解決しようとはしないでください。

@node gettextize Invocation
@section @code{gettextize}プログラムの呼び出し

@include gettextize.texi

@node Adjusting Files
@section 作成または変更しなければならないファイル
@cindex @code{gettext} files

@code{gettextize}により自動的に追加されたファイルをのぞいて、GNU
@code{gettext}と正常に対話するために修正が必要なファイルがたくさんあります。あなたがMakefileの設計とauto-configuration自動設定のためのGNU標準に忠実にしたがっているなら、調整は容易でしょう。ここではそれぞれについて必要な変更を順に説明します。

以下では変更が必要なファイルと、必要な変更を説明していきます。多くの例はGNU @code{gettext} @value{VERSION}
のディストリビューション自体か、GNU
@code{hello}ディストリビューション(@uref{https://www.gnu.org/software/hello})から引用しました。GNU
@code{gettext}のソースコードとGNU @code{hello}を参照してみれば、これらのパッケージがGNU
@code{gettext}の機能を使うよい例だということが納得できるでしょう。

@menu
* po/POTFILES.in::           @file{POTFILES.in} in @file{po/}
* po/LINGUAS::               @file{LINGUAS} in @file{po/}
* po/Makevars::              @file{Makevars} in @file{po/}
* po/Rules-*::               Extending @file{Makefile} in @file{po/}
* configure.ac::             @file{configure.ac} at top level
* config.guess::             @file{config.guess}, @file{config.sub} at top 
                               level
* mkinstalldirs::            @file{mkinstalldirs} at top level
* aclocal::                  @file{aclocal.m4} at top level
* config.h.in::              @file{config.h.in} at top level
* Makefile::                 @file{Makefile.in} at top level
* src/Makefile::             @file{Makefile.in} in @file{src/}
* lib/gettext.h::            @file{gettext.h} in @file{lib/}
@end menu

@node po/POTFILES.in
@subsection @file{po/}内の@file{POTFILES.in}
@cindex @file{POTFILES.in} file

ディレクトリー@file{po/}には、@file{POTFILES.in}というファイルが必要です。このファイルは、すべてのプログラムソースの中で、翻訳が必要だとマークされた文字列をもつファイルがどれかを告げるもので、以下のような内容です:

@example
@group
# List of source files containing translatable strings.
# Copyright (C) 1995 Free Software Foundation, Inc.

# Common library files
lib/error.c
lib/getopt.c
lib/xmalloc.c

# Package source files
src/gettext.c
src/msgfmt.c
src/xgettext.c
@end group
@end example

@noindent
#マークのコメントと空行は無視されます。それ以外の行は翻訳用にマークされた文字列を含むソースファイルをリストした行(@ref{Mark
Keywords}を参照してください)で、相対パスは@file{POTFILES.in}のあるディレクトリーではなく、ディストリビューション全体のトップレベルからの相対パスです。

@code{flex}や@code{bison}のような、それ自身では翻訳可能な文字列を提供しないようなツールによりCファイルが自動生成されるときは、@file{po/POTFILES.in}には自動生成されたCファイルではなく、本当のソースファイル(@code{flex}のときは@file{.l}で終わるファイル、@code{bison}のときは@file{.y}というファイル)を記述することをお勧めします。

@node po/LINGUAS
@subsection @file{po/}内の@file{LINGUAS}
@cindex @file{LINGUAS} file

ディレクトリー@file{po/}には、@file{LINGUAS}というファイルも必要です。このファイルは利用可能な翻訳がリストされています。これは空白区切りのリストで、#マークのコメントと空行は無視されます。以下は例です:

@example
@group
# Set of available languages.
de fr
@end group
@end example

@noindent
この例はGermanとFrenchのPOファイルが利用可能で、パッケージでは現在それらの言語がサポートされていることを意味しています。インストール時に、インストールされる言語にさらに制限をかけたいときは、ファイル@file{LINGUAS}を変更するのではなく、環境変数@code{LINGUAS}を使用します(@ref{Installers}を参照してください)。

@code{LINGUAS}ファイルには、@samp{en@@quot}と@samp{en@@boldquot}という"言語"を追加することをお勧めします。@code{en@@quot}はEnglishのメッセージカタログ(@code{en})の亜種で、非対称な体裁の@samp{`}と@samp{'}によるASCIIの置き換えではなく、本当のクォーテーションマークを使います。@code{en@@boldquot}は@code{en@@quot}の亜種で、クォーテーション文字を太字のフォントで出力します。これはVT100のエスケープシーケンスをサポートする端末エミュレーター(@code{xterm}やLinuxのconsole。Emacsの@kbd{M-x
shell}モードは該当しません)で使用されます。

これらの追加のメッセージカタログ@samp{en@@quot}および@samp{en@@boldquot}は、翻訳者が作成したのではなく、自動的に作成されたものです。これらのファイルをサポートするためには@file{po/}ディレクトリーに、@file{Rules-quot}、@file{quot.sed}、@file{boldquot.sed}、@file{en@@quot.header}、@file{en@@boldquot.header}、@file{insert-header.sin}というファイルが必要です。これらのファイルは、@code{gettextize}を実行することによりインストールされます。

@node po/Makevars
@subsection @file{po/}内の@file{Makevars}
@cindex @file{Makevars} file

ディレクトリー@file{po/}には、@file{Makevars}というファイルもあります。このファイルには、プロジェクトで固有の変数が含まれています。@file{po/Makevars}が作成されるときに、@file{po/Makefile}が挿入されます。そのため、変数はPOTファイルが作成・更新されたときや、メッセージカタログがインストールされたときに効果を及ぼします。

あなたのパッケージが単一のメッセージドメイン(1つの@file{po/}ディレクトリーしかない)のときは、最初の3つの変数は変更する必要はありません。別々の場所に複数の@file{po/}ディレクトリーをもつパッケージの場合だけ、@file{Makevars}の最初に定義された3つの変数を調整する必要があります。

@code{XGETTEXT_OPTIONS}変数のかわりに、autoconfマクロの@code{AM_XGETTEXT_OPTION}により、@code{xgettext}のオプションを指定することもできます。詳細は@ref{AM_XGETTEXT_OPTION}を参照してください。

@node po/Rules-*
@subsection @file{po/}内の@file{Makefile}の拡張
@cindex @file{Makefile.in.in} extensions

@file{po/}ディレクトリーの、@file{Rules-*}と呼ばれるファイルは、@file{po/Makefile}が作成されたときに追加されたファイルです。これらのファイルは、@file{po/Makefile.in.in}に干渉することなく、特定のPOファイルのMakefileにルールを追加する機会を与えてくれます。

@cindex quotation marks
@vindex LANGUAGE@r{, environment variable}
GNU
gettextには、カタログ@file{en@@quot.po}および@file{en@@boldquot.po}をビルドするルールを含む、@file{Rules-quot}ファイルが含まれます。@file{en@@quot.po}の効果は、環境変数@code{LANGUAGE}に@samp{en@@quot}をセットすると、クォーテーションを示す代替のASCII
grave accentとASCII
apostropheのかわりに、対称性をもつUnicodeの正しいクォーテーションマークが表示されることです。このカタログを有効にするには、単に@code{en@@quot}を@file{po/LINGUAS}に追加します。@file{en@@boldquot.po}の効果は、@code{LANGUAGE}に@samp{en@@boldquot}をセットすると、正しいクォーテーションマークが得られるだけでなく、ターミナルやコンソールで表示されるクォーテーションマークの文字に、太字フォントが使用されることです。これはGUIプログラムではなく、コマンドラインのプログラムにとってだけ便利なカタログです。@file{po/LINGUAS}ファイルに@code{en@@boldquot}を追加するだけで、このカタログを利用できます。

同様にして、@file{sr} locale -- Cyrillic文字で記述されたSerbian -- から、@file{sr@@latin}
locale -- Latinアルファベットで記述されたSerbian --
のためのメッセージカタログを構築するルールを作成することができます。@ref{msgfilter Invocation}を参照してください。

@node configure.ac
@subsection トップレベルの@file{configure.ac}

@file{configure.ac}または@file{configure.in} --
これは@code{autoconf}が@file{configure}スクリプトを生成するときのソースになるファイルです。

@enumerate
@item パッケージとバージョンを宣言します。
@cindex package and version declaration in @file{configure.ac}

これは以下のように宣言します:

@example
PACKAGE=gettext
VERSION=@value{VERSION}
AC_DEFINE_UNQUOTED(PACKAGE, "$PACKAGE")
AC_DEFINE_UNQUOTED(VERSION, "$VERSION")
AC_SUBST(PACKAGE)
AC_SUBST(VERSION)
@end example

@noindent
GNU @code{automake}を使っている場合は、以下のようになるでしょう:

@example
AM_INIT_AUTOMAKE(gettext, @value{VERSION})
@end example

@noindent
もちろん、パッケージ名の@samp{gettext}と、バージョン番号の@samp{@value{VERSION}}は、あなたのパッケージの名前とバージョン番号で置き換えます。これらは配布物のパッケージされた@code{tar}のファイル名(この例では@file{gettext-@value{VERSION}.tar.gz})にそのまま使用されます。

@item インターナショナリゼーションにたいするサポートのチェック。

以下のマクロは、インターナショナリゼーションにたいするサポートを発動するためにメインとなる、@code{m4}のマクロです。この行を@file{configure.ac}に追加します:

@example
AM_GNU_GETTEXT([external])
@end example

@noindent
マクロはconfigure時に多くのチェックと処理を行いますが、呼び出しは故意に単純にしています。

@item 出力ファイルの作成。

AC_OUTPUT命令は@file{configure.ac}ファイルの最後にあり、以下の2つの方法で変更する必要があります:

@example
AC_OUTPUT([@var{existing configuration files} po/Makefile.in],
[@var{existing additional actions}])
@end example

@code{AC_OUTPUT}の最初の引数の変更は、@file{po/}ディレクトリーを置き換えるための変更です。接尾辞@samp{.in}は、@file{po/}だけに使用されることに注意してください。これにより配布される本当のファイルは@file{po/Makefile.in.in}であることがわかります。

@end enumerate

@node config.guess
@subsection トップレベルの@file{config.guess}、@file{config.sub}

配布物に@file{config.guess}および@file{config.sub}という、GNUのファイルを追加する必要があります。これらのファイルが必要なのは、@code{AM_ICONV}マクロに特定のプラットフォームに関する知識が含まれているので、、プラットフォームを識別する必要があるからです。

最新バージョンの@file{config.guess}および@file{config.sub}を、@file{https://savannah.gnu.org/}の@samp{config}プロジェクトから入手できます。以下は入手するためのコマンドです
@smallexample
$ wget -O config.guess 'https://git.savannah.gnu.org/gitweb/?p=config.git;a=blob_plain;f=config.guess;hb=HEAD'
$ wget -O config.sub 'https://git.savannah.gnu.org/gitweb/?p=config.git;a=blob_plain;f=config.sub;hb=HEAD'
@end smallexample
@noindent
バージョンは最新ではありませんが、GNU @code{automake}とGNU @code{libtool}パッケージにも含まれています。

@file{config.guess}および@file{config.sub}は通常、配布物のトップレベルに配置されます。しかし、他の設定ファイル(@file{install-sh}、@file{ltconfig}、@file{ltmain.sh}、@file{missing}など)と同様に、サブディレクトリーに配置することもできます。ファイルを移動すること以外に必要なのは、@file{configure.ac}に以下の行を追加することです。

@example
AC_CONFIG_AUX_DIR([@var{subdir}])
@end example

@node mkinstalldirs
@subsection トップレベルの@file{mkinstalldirs}
@cindex @file{mkinstalldirs} file

初期のバージョンのGNU gettextでは、配布物にGNU
@file{mkinstalldirs}スクリプトを追加する必要がありました。これは今では必要ありません。削除することができます。

@node aclocal
@subsection トップレベルの@file{aclocal.m4}
@cindex @file{aclocal.m4} file

ディストリビューション内に@file{aclocal.m4}ファイルがなければ、GNU
@code{gettext}の@file{m4/}ディレクトリー内のファイル@file{gettext.m4}、@file{host-cpu-c-abi.m4}、@file{intlmacosx.m4}、@file{iconv.m4}、@file{lib-ld.m4}、@file{lib-link.m4}、@file{lib-prefix.m4}、@file{nls.m4}、@file{po.m4}、@file{progtest.m4}を単一ファイルに結合するのが、もっともシンプルな方法です。

すでに@file{aclocal.m4}ファイルがある場合は、前述のマクロファイルを既存の@file{aclocal.m4}にマージする必要があります。以前にリリースされたGNU
@code{gettext}からアップグレードしたようなときは、ほとんどの場合マクロ(@code{AM_GNU_GETTEXT}、...
)を@emph{置き換える}必要があることに注意してください。なぜならそれらのマクロは、GNU
@code{gettext}がリリースされるときは通常、少し変更されるからです。これらの内容は、わたしたちが "奇妙"
なシステムに出会う度に増えていくかもしれません。

GNU @code{automake}の1.9以降を使用するべきです。これを使用する場合は、ファイルGNU
@code{gettext}の@file{m4/}ディレクトリー内のファイル@file{gettext.m4}、@file{host-cpu-c-abi.m4}、@file{intlmacosx.m4}、@file{iconv.m4}、@file{lib-ld.m4}、@file{lib-link.m4}、@file{lib-prefix.m4}、@file{nls.m4}、@file{po.m4}、@file{progtest.m4}を@file{m4/}という名前のサブディレクトリー内にコピーする必要があります。

@example
ACLOCAL_AMFLAGS = -I m4
@end example

@noindent
上記のような行を、トップレベルの@file{Makefile.am}に追加してください。

GNU @code{automake} 1.10以降を使用している場合は、さらに簡単になります。以下の行を追加してください

@example
ACLOCAL_AMFLAGS = --install -I m4
@end example

@noindent
上記のような行を、トップレベルの@file{Makefile.am}に追加して、@samp{aclocal --install -I
m4}を実行します。これは@file{aclocal.m4}を更新する前に、必要なファイルを自動的に@file{m4/}サブディレクトリーに追加します。

これらのマクロはインターナショナリゼーションのサポート機能と関連情報をチェックします。1度うまく安定させられれば、多分これらのマクロを、標準のAutoconfに統合できるでしょう。なぜなら、これらの断片的な@code{m4}コードは、GNU
@code{gettext}を使うプロジェクトでは同一だからです。

@node config.h.in
@subsection トップレベルの@file{config.h.in}
@cindex @file{config.h.in} file

@code{configure}により定義されるCマクロを保持するインクルードファイルのテンプレートを、通常は@file{config.h.in}と呼び、手動または自動で保守されるかもしれません。

プログラム@samp{autoheader}を使って自動的に保守されている場合、なにも行う必要はありません。これは特にGNU
@code{automake}を使っているケースです。

手動で保守する場合は、@file{config.h.in}に以下の行を追加することにより、回避できます:

@example
/* Define to 1 if translation of program messages to the user's
   native language is requested. */
#undef ENABLE_NLS
@end example

@node Makefile
@subsection トップレベルの@file{Makefile.in}

以下は、トップレベルにあるメインの@file{Makefile.in}ファイルにたいして必要な変更です。

@enumerate
@item
ゴール@samp{dist:}が正常に動作(以降で説明します)するように、@file{Makefile.in}の最初の部分に、以下の行を追加します:

@example
PACKAGE = @@PACKAGE@@
VERSION = @@VERSION@@
@end example

@item
どのサブディレクトリーの@file{Makefile.in}を処理する場合でも、サブディレクトリー@samp{po}も処理するようにしてください。@file{Makefiles}内の特別なルールは、インターナショナリゼーションが必要ない場合を処理するためのものです。

Makefilesを使用している場合、それがautomakeにより作成されたものか、手入力されたものかにかかわらず、GNUのコーディング規約にしたがうように注意してください。新しいサブディレクトリーを処理しなければならないために影響を受けるゴールには、@samp{installdirs}、@samp{install}、@samp{uninstall}、@samp{clean}、@samp{distclean}が含まれます。

以下は標準的な処理順の例です。この例ではゴール@samp{dist:}のために使用される@code{SUBDIRS}を、@code{Makefile.in}の中で定義しています。

@example
SUBDIRS = doc lib src po
@end example

@item
デリケートなポイントは、@file{po/Makefile}のゴール@samp{dist:}が、メインの@file{Makefile}によって、後から正しいディレクトリーにセットアップされる点です。以下はゴール@samp{dist:}がどのようなものかという例です:

@example
distdir = $(PACKAGE)-$(VERSION)
dist: Makefile
	rm -fr $(distdir)
	mkdir $(distdir)
	chmod 777 $(distdir)
	for file in $(DISTFILES); do \
	  ln $$file $(distdir) 2>/dev/null || cp -p $$file $(distdir); \
	done
	for subdir in $(SUBDIRS); do \
	  mkdir $(distdir)/$$subdir || exit 1; \
	  chmod 777 $(distdir)/$$subdir; \
	  (cd $$subdir && $(MAKE) $@@) || exit 1; \
	done
	tar chozf $(distdir).tar.gz $(distdir)
	rm -fr $(distdir)
@end example

@end enumerate

GNU
@code{automake}を使っているときは、@file{Makefile.am}から@file{Makefile.in}が自動的に生成されますが、@file{Makefile.am}に必要な修正は、@samp{gettextize}の実行よって修正済みであることに注意してください。

@node src/Makefile
@subsection @file{src/}内の@file{Makefile.in}

メインの@file{Makefile.in}で行ったいくつかの修正は、あなたのパッケージソースの@file{Makefile.in}(ここでは@file{src/}サブディレクトリーにあると仮定します)でも必要です。以下は、@file{src/Makefile.in}内で必要な修正のすべてです:

@enumerate
@item
ゴール@samp{dist:}を考慮して、@file{src/Makefile.in}の先頭の部分に以下の行が必要になります:

@example
PACKAGE = @@PACKAGE@@
VERSION = @@VERSION@@
@end example

@item
まだ定義されていなければ、@code{top_srcdir}を定義する必要があります。これは@code{cpp}のインクルードファイルのための定義で、以下の行を追加するだけです:

@example
top_srcdir = @@top_srcdir@@
@end example

@item
後ですべての@file{Makefile.in}で、一様なのゴール@samp{dist:}とするために、@code{subdir}を@samp{src}と定義したいと思うかもしれません。以下は、このゴール@samp{dist:}のために必要な定義です:

@example
subdir = src
@end example

@item
以下のようにプログラムの@code{main}関数は通常、@code{bindtextdomain}(@ref{Triggering}を参照してください)を呼び出します:

@example
bindtextdomain (@var{PACKAGE}, LOCALEDIR);
textdomain (@var{PACKAGE});
@end example

プログラムにLOCALEDIRを知らせるために、特定のモジュールにたいしては以下の行を@file{Makefile.in}に追加してください:

@example
datadir = @@datadir@@
datarootdir= @@datarootdir@@
localedir = @@localedir@@
DEFS = -DLOCALEDIR=\"$(localedir)\" @@DEFS@@
@end example

@code{@@datadir@@}のデフォルトは@samp{$(prefix)/share}、@code{$(localedir)}のデフォルトは@samp{$(prefix)/share/locale}になることに注意してください。

@item
あなたは最後のリンクで、ライブラリーとして@code{@@LIBINTL@@}または@code{@@LTLIBINTL@@}が使われることを保証する必要があります。@code{@@LIBINTL@@}は@code{libtool}なしで使用され、@code{@@LTLIBINTL@@}は@code{libtool}とともに使用されます。これを達成するには、以下のようにこれらを@code{LIBS}で管理します:

@example
LIBS = @@LIBINTL@@ @@LIBS@@
@end example

GNU
@code{gettext}でインターナショナライズされたパッケージには、ヘルパー関数を含むライブラリーを、ディレクトリー@file{lib/}にビルドするものがたくさんあります(少なくともGNU
@code{gettext}ライブラリー自身が必要とするいくつかの関数が必要です)。しかし@file{lib/}の中の関数のいくつかは、ユーザーに翻訳が必要なメッセージをあたえる関数です。これに注意してサポートのためのライブラリー
(@file{libsupport.a}としましょう)を、上記の例の@code{@@LIBINTL@@}と@code{@@LIBS@@}の前に配置します:

@example
LIBS = ../lib/libsupport.a @@LIBINTL@@ @@LIBS@@
@end example

@item
ゴール@samp{dist:}は、他のものと一致している必要があります。以下はそのための合理的な定義です:

@example
distdir = ../$(PACKAGE)-$(VERSION)/$(subdir)
dist: Makefile $(DISTFILES)
	for file in $(DISTFILES); do \
	  ln $$file $(distdir) 2>/dev/null || cp -p $$file $(distdir) || exit 1; \
	done
@end example

@end enumerate

GNU
@code{automake}を使用している場合、@file{Makefile.in}は@file{Makefile.am}から自動的に生成されるので、最初の3つと最後の変更は必要ないことに注意してください。@file{Makefile.am}に必要な変更は以下になります:

@enumerate
@item
プログラムにLOCALEDIRを知らせるために、特定のモジュールにたいしては以下の行を:

@example
<module>_CPPFLAGS = -DLOCALEDIR=\"$(localedir)\"
@end example

@noindent
またはコンパイル単位については以下のように@file{Makefile.am}に記述します。

@example
AM_CPPFLAGS = -DLOCALEDIR=\"$(localedir)\"
@end example

これはすべてのモジュール、またはコンパイル単位のためのものです。さらにAutoconfのバージョンが2.60より古いものを使用している場合、以下の行を追加して@samp{localedir}を定義します:

@example
localedir = $(datadir)/locale
@end example

@item
最後のリンクが@code{@@LIBINTL@@}または@code{@@LTLIBINTL@@}を使うことを保証するために、以下を@file{Makefile.am}に追加します:

@example
<program>_LDADD = @@LIBINTL@@
@end example

@noindent
特定のプログラムごとには上記のように記述します。

@example
LDADD = @@LIBINTL@@
@end example

これはすべてのプログラムの場合です。プログラムのリンクに@code{libtool}を使うときは、プログラム用に@@LIBINTL@@ではなく、@@LTLIBINTL@@を使う必要があることを忘れないでください。

@end enumerate

@node lib/gettext.h
@subsection @file{lib/}内の@file{gettext.h}
@cindex @file{gettext.h} file
@cindex turning off NLS support
@cindex disabling NLS

GNU
@code{gettext}により提供される、パッケージのインターナショナリゼーションはオプションであり、2つの状況でオフに切り替えることが考えられます:

@itemize @bullet
@item
インストーラーで、@samp{./configure
--disable-nls}が指定されたとき。ブートディスク用のユーティリティーをビルドするときのように、これは機能よりも小さいバイナリーを生成する方が重要な場合に有用かもしれません。これは、3.0より古いバージョンのGCCで、コード品質にたいするCコンパイラーの特定の警告を取得するためにも有用でしょう。

@item
libintl.hヘッダー(および、それに関連付けられたlibintlライブラリー)がまだシステムにインストールされていない場合は、コンパイルエラーよりもインターナショナリゼーションのサポートなしでパッケージをビルドする方が望ましいでしょう。
@end itemize

Cプリプロセッサーのマクロは、これら2つのケースを検知するのに使用できます。通常、@code{libintl.h}が見つかって、明示的に利用不可されていなければ、autoconfが設定ファイルを生成するときに、@code{ENABLE_NLS}マクロが1に定義されます。しかし上記以外の状況では、このマクロは定義されず、それゆえCでは0に評価されます。

@cindex include file @file{libintl.h}
@file{gettext.h}は、@code{ENABLE_NLS}マクロにもとづいて@file{<libintl.h>}を使用する、便利なヘッダーファイルです。@code{ENABLE_NLS}がセットされていると、@file{<libintl.h>}がインクルードされ、セットされていない場合はlibintl.h関数のために代用のno-op(訳注:
no-op = no operation =
何もしない)が定義されます。わたしたちは直接@file{<libintl.h>}を使うのではなく、@code{"gettext.h"}を使うことを推奨します。そうすれば古いシステムへの可搬性が保証され、もし望むならインストーラーでインターナショナリゼーションをオフにできます。

@example
#include "gettext.h"
@end example

@noindent
Cのソースコードは下記の行を、上記のように書き換えます(訳注: 下が修正前で、上が修正後です。通常とは逆の順序で説明しているので間違えないでください)。

@example
#include <libintl.h>
@end example

@code{gettext.h}の場所は通常、補助のインクルードファイルを含んだディレクトリーです。多くのGNUパッケージには、ヘルパー関数を含む@file{lib/}ディレクトリーがあるので、@file{gettext.h}はそこに配置すればよいでしょう。他のパッケージでは、@file{src}ディレクトリーに配置することができます。

@code{gettext.h}をパブリックな場所にインストールしないでください。このファイルを必要とするすべてのパッケージは、パッケージ自身にそのファイルのコピーが含まれているからです。

@node autoconf macros
@section @file{configure.ac}内でのautoconfマクロの使用
@cindex autoconf macros for @code{gettext}

GNU
@code{gettext}は、パッケージの@file{configure.ac}(または@file{configure.in})で使用されるマクロをインストールします。詳細については、@ref{Top,
, Introduction, autoconf, The Autoconf
Manual}を参照してください。その中でも主要なマクロは、もちろん@code{AM_GNU_GETTEXT}です。

@menu
* AM_GNU_GETTEXT::           AM_GNU_GETTEXT in @file{gettext.m4}
* AM_GNU_GETTEXT_VERSION::   AM_GNU_GETTEXT_VERSION in @file{gettext.m4}
* AM_GNU_GETTEXT_NEED::      AM_GNU_GETTEXT_NEED in @file{gettext.m4}
* AM_PO_SUBDIRS::            AM_PO_SUBDIRS in @file{po.m4}
* AM_XGETTEXT_OPTION::       AM_XGETTEXT_OPTION in @file{po.m4}
* AM_ICONV::                 AM_ICONV in @file{iconv.m4}
@end menu

@node AM_GNU_GETTEXT
@subsection @file{gettext.m4}内のAM_GNU_GETTEXT

@amindex AM_GNU_GETTEXT
@code{AM_GNU_GETTEXT}マクロは、Cライブラリーおよび@code{libintl}ライブラリー(どちらも共有または静的なライブラリーをサポートしています)に分割されたGNU
gettextの関数ファミリーをテストします。このマクロは、ビルド用にパッケージの@file{po/}ディレクトリーを準備するのに、@code{AM_PO_SUBDIRS}も呼び出します。

@code{AM_GNU_GETTEXT}は、オプションの引数を3つ指定でき、一般的な書式は以下のようになります

@example
AM_GNU_GETTEXT([@var{intlsymbol}], [@var{needsymbol}])
@end example

@c We don't document @var{intlsymbol} = @samp{use-libtool} here, because
@c it is of no use for packages other than GNU gettext itself.  (Such packages
@c are not allowed to install the shared libintl.  But if they use libtool,
@c then it is in order to install shared libraries that depend on libintl.)
@var{intlsymbol}は常に@samp{external}であること。

@var{needsymbol}に@samp{need-ngettext}が指定されると、@code{ngettext()}をもたない(libcまたはlibintlの)GNU
gettext実装は無視されます。@var{needsymbol}に@samp{need-formatstring-macros}が指定されると、ISO
C 99 @file{<inttypes.h>}書式文字列マクロをサポートしないGNU
gettext実装は無視されます。@var{needsymbol}だけを指定することもできます。他の場所で@code{AM_GNU_GETTEXT_NEED}を指定することでも、これらの指定を満たすことはできます。1つ以上指定したときは、もっとも強い指定が使用されるか、@code{AM_GNU_GETTEXT_NEED}マクロを複数回呼び出します。これらの指定は、@samp{need-formatstring-macros}が@samp{need-ngettext}を含むような階層になっています。

@code{AM_GNU_GETTEXT}マクロは、GNU
gettextが利用可能で、使用できるかどうかを決定するマクロです。利用できる場合は、変数@code{USE_NLS}に@samp{yes}をセットし、これはautoconfが生成する設定ファイル(通常は@file{config.h}というファイル)の@code{ENABLE_NLS}に1を定義し、Makefileで使用される変数@code{LIBINTL}と@code{LTLIBINTL}にリンカーオプションをセットし(@code{LIBINTL}はlibtoolなしのときで、@code{LTLIBINTL}はlibtoolを使用するとき)、必要なときは@code{CPPFLAGS}のオプションに@samp{-I}を追加し、利用できない場合は@code{USE_NLS}に@samp{no}をセットし、@code{LIBINTL}と@code{LTLIBINTL}を空にセットして、@code{CPPFLAGS}を変更しません。

@code{AM_GNU_GETTEXT}が対処する複雑さは、以下のようなものです:

@itemize @bullet
@item
@cindex @code{libintl} library
いくつかのオペレーティングシステムは、Cライブラリー(例: glibc)に@code{gettext}をもちます。GNU
@code{libintl}は、GNU @code{gettext}の一部としてインストールされたのかもしれません。

@item
GNU
@code{libintl}がインストールされていて、検索パス(インクルードファイルの検索パスは@code{CPPFLAGS}、ライブラリーの検索パスは@code{LDFLAGS})にあるが、必要ない場合。

@item
glibcをのぞく、GNUのmoファイルを取り扱えないオペレーティングシステムのネイティブの@code{gettext}は、必要なlocale依存の機能をもたず、カタログのテキストのエンコーディングから、ユーザーのlocaleのエンコーディングにメッセージを変換できません。

@item
GNU
@code{libintl}がインストールされていて、実行時ライブラリーの検索パスにあるが、必要ない場合。@code{LD_LIBRARY_PATH}のような環境変数による設定を無視するために、このマクロは適切な実行時の検索パスオプションを、変数@code{LIBINTL}および@code{LTLIBINTL}に追加します。これはほとんどシステムで動作しますが、SCOのように共有ライブラリーに制限のあるいくつかのオペレーティングシステムではうまく動作しません。

@item
GNU
@code{libintl}は、POSIX/XSIの@code{iconv}に依存します。このマクロはiconvを使うために必要なリンカーオプションをチェックして、変数@code{LIBINTL}および@code{LTLIBINTL}に追加します。
@end itemize

@node AM_GNU_GETTEXT_VERSION
@subsection @file{gettext.m4}内のAM_GNU_GETTEXT_VERSION

@amindex AM_GNU_GETTEXT_VERSION
@code{AM_GNU_GETTEXT_VERSION}マクロは、パッケージで使用するGNU
gettextインフラストラクチャーのバージョン番号を宣言します。

このマクロの使用はオプションで、これを使用するプログラムは@code{autopoint}だけです(@ref{Version Control
Issues}を参照してください)。

@node AM_GNU_GETTEXT_NEED
@subsection @file{gettext.m4}内のAM_GNU_GETTEXT_NEED

@amindex AM_GNU_GETTEXT_NEED
@code{AM_GNU_GETTEXT_NEED}マクロは、GNU gettextの実装に関する制約を宣言するもので、構文は以下のようになります

@example
AM_GNU_GETTEXT_NEED([@var{needsymbol}])
@end example

@var{needsymbol}に@samp{need-ngettext}を指定した場合、@code{ngettext()}関数をもたない、(libcまたはlibintlの)GNU
gettext実装は無視されます。@var{needsymbol}に@samp{need-formatstring-macros}を指定した場合、ISO
C 99 @file{<inttypes.h>}の書式文字列マクロをサポートしないGNU gettext実装は無視されます。

@code{AM_GNU_GETTEXT}の2番目のオプション引数も考慮されます。

@code{AM_GNU_GETTEXT_NEED}呼び出しは、@code{AM_GNU_GETTEXT}呼び出しの前後どちらでもよく、順番は関係ありません。

@node AM_PO_SUBDIRS
@subsection @file{po.m4}内のAM_PO_SUBDIRS

@amindex AM_PO_SUBDIRS
このマクロはC、C++、Objective C以外のプログラム言語(例:
@code{sh}、@code{Python}、@code{Lisp})による、インターナショナライズされたプログラムで使う必要があります。PO
ファイルによるローカリゼーションをサポートするプログラム言語のリストは、@ref{Programming Languages}を参照してください。

@code{AM_PO_SUBDIRS}マクロは、インターナショナリゼーションを使う必要があるかを決定します。使う必要がある場合には@code{USE_NLS}変数に@samp{yes}をセットし、必要ない場合には@samp{no}をセットします。このマクロは、各@file{po/}ディレクトリーのMakefileの変数にたいする適切な値も決定します。

@node AM_XGETTEXT_OPTION
@subsection @file{po.m4}内のAM_XGETTEXT_OPTION

@amindex AM_XGETTEXT_OPTION
@code{AM_XGETTEXT_OPTION}マクロは、パッケージの@file{po/}ディレクトリーでの@code{xgettext}呼び出しで使用する、コマンドラインオプションを登録するマクロです。

たとえば、@samp{error_at_line}という関数を定義しているソースファイルがあり、その関数の5番目の引数には、書式文字列を指定する場合には、以下のように使うことができます
@example
AM_XGETTEXT_OPTION([--flag=error_at_line:5:c-format])
@end example
@noindent
これは、この関数の5番目の引数にたいする@samp{gettext}呼び出しにたいして、これを翻訳可能な@samp{c-format}の文字列だとマークするよう、@code{xgettext}に指示します。

@code{xgettext}に指定できるオプションのリストは、@ref{xgettext Invocation}を参照してください。

このマクロの使用は、@file{po/Makevars}の中の@samp{XGETTEXT_OPTIONS}変数の代用となります。

@node AM_ICONV
@subsection @file{iconv.m4}内のAM_ICONV

@amindex AM_ICONV
@code{AM_ICONV}マクロは、Cライブラリー(または@code{iconv}ライブラリーに分離された)POSIX/XSI
@code{iconv}関数が提供されているかテストするマクロです。もし見つかったときは@code{am_cv_func_iconv}変数に@samp{yes}をセットし、autoconfが生成する設定ファイル(通常は@file{config.h}というファイル)の@code{HAVE_ICONV}に1を定義し、@code{iconv()}の2番目の引数の型が@samp{const
char **}または@samp{char
**}で定義さされているかにより、@code{ICONV_CONST}に@samp{const}または空を定義し、Makefileの中で使用されるリンカーオプションの変数@code{LIBICONV}および@code{LTLIBICONV}をセット(@code{LIBICONV}はlibtoolなしのとき、@code{LTLIBICONV}はlibtoolありのとき)、必要なら@code{CPPFLAGS}のオプションに@samp{-I}を追加します。見つからなかったときは、@code{LIBICONV}および@code{LTLIBICONV}に空をセットして、@code{CPPFLAGS}を変更しません。

@code{AM_ICONV}が対処する複雑さは、以下のようなものです:

@itemize @bullet
@item
@cindex @code{libiconv} library
Cライブラリーに@code{iconv}のあるオペレーティングシステムとしては、たとえばglibcがあり、ライブラリー@code{libiconv}に分割されているシステムには、たとえばOSF/1、FreeBSDがあります。種類の如何にかかわらず、GNU
@code{libiconv}がインストールされたオペレーティングシステムの場合、オペレーティングシステムのネイティブの@code{iconv}のかわりに使用されます。

@item
GNU @code{libiconv}がインストールされていて、検索パス(インクルードファイルの検索パス
@code{CPPFLAGS}、ライブラリーの検索パス@code{LDFLAGS})にあるが、必要ない場合。

@item
GNU
@code{libiconv}は、いくつかのオペレーティングシステムのネイティブの@code{iconv}にたいしてバイナリーの非互換があります(例:
FreeBSD)。適合していない@file{iconv.h}および@file{libiconv.so}の使用は、プログラムのクラッシュを招きます。

@item
GNU
@code{libiconv}がインストールされていて、実行時ライブラリーの検索パスにあるが、必要ない場合。@code{LD_LIBRARY_PATH}のような環境変数による設定を無視するために、このマクロは適切なランタイムのサーチパスオプションを、変数@code{LIBICONV}に追加します。これはほとんどシステムで動作しますが、SCOのように共有ライブラリーに制限のあるいくつかのオペレーティングシステムではうまく動作しません。
@end itemize

@file{gettext.m4}が依存しているので、@file{iconv.m4}はGNU gettextの一部として配布されます。

@node Version Control Issues
@section Integrating with Version Control Systems

多くのプロジェクトでは分散開発におけるソースのバックアップにバージョンコントロールを使用しています。このセクションでは、バージョンコントロールされたファイルにたいして@code{cvs}、@code{gettextize}、@code{autopoint}、@code{autoconf}の使用をどのように管理するかについてのアドバイスを与えます

@menu
* Distributed Development::  Avoiding version mismatch in distributed 
                               development
* Files under Version Control::  Files to put under version control
* Translations under Version Control::  Put PO Files under Version Control
* autopoint Invocation::     Invoking the @code{autopoint} Program
@end menu

@node Distributed Development
@subsection 分散開発におけるバージョンミスマッチを避ける

複数の開発者によるプロジェクト開発では、@code{gettext}の新しいバージョンにアップグレードしたいと望む一人の開発者が、@code{gettextize}を実行して@ref{Adjusting
Files}にリストした変更をほどこした後に、その変更をリポジトリーにコミットするようなことが時折あります。

プロジェクトのすべての開発者が、パッケージのGNU
@code{gettext}に、同じバージョンのものを使用することを強く推奨します。別の言い方をすると、@code{gettextize}を実行したら、開発者はプロジェクト全体と同じ方法で必要な変更をほどこしてリポジトリーにコミットする必要があります。さもないと以下のような損傷が発生します:

@itemize @bullet
@item
開発者の間での、明らかなバージョンの不一致。@file{configure.ac}および@file{configure.in}、@code{Makefile.am}および@code{Makefile.in}内の@code{gettext}に関係する特定の箇所は、@code{gettext}のバージョンに依存しており、異なるバージョンの@code{gettext}による基礎的なファイルの使用により、容易にビルドエラーが発生します。

@item
明らかでないバージョンの不一致。このようなバージョン不一致は、開発者が発見できないようなパッケージの動作不良も招きます。明らかでないバージョンの不一致による最悪のケースは、パッケージのインターナショナリゼーションが動作しないケースです。

@item
リリースのリスク。すべての開発者は、パッケージにたいして一定のテストを暗黙に行います。このテストはリリースの数週間から数日前にかけて重要です。もしも誰かが他の開発者とは異なるバージョンのGNU
@code{gettext}を使ってリリース用のtarファイルを作ったら、その配布物は同じバージョンの@code{gettext}を使ってテストされたものに比べてテストされていないことになり、たとえばそれがプラットフォームに固有の未知のバグにもなり得るのです。
@end itemize

@node Files under Version Control
@subsection Files to put under version control

バージョンコントロールされたリポジトリーのコンテキストで作成されるファイル、たとえば@file{configure.ac}により生成される@file{configure}、@code{@var{parser}.y}から生成される@code{@var{parser}.c}、@code{gettextize}や@code{autopoint}により自動インストールされる@code{po/Makefile.in.in}のようなファイルを取り扱うには、基本的に3つの方法があります。

@enumerate
@item
生成されるすべてのファイルを、常にリポジトリーにコミットする。

@item
生成されるすべてのファイルを、時々(たとえば毎リリースごとに)リポジトリーにコミットする。

@item
生成されるファイルを、リポジトリーにコミットされない。
@end enumerate

これら3つの方法には、それぞれ異なる利点と欠点があります。

@enumerate
@item
1番目の方法の利点は、誰でもソースからその時点で動作するビルドをチェックアウトできる点です。欠点は以下のとおりです:@*
1a メンテナーによる頻繁な"push"操作が必要です。@*
1b リポジトリーサイズの増加が早くなります。

@item
2番目の方法の利点は、誰もがソースをチェックアウトでき、通常は"./configure; make"は動作します。欠点は以下のとおりです:@*
2a リポジトリーからチェックアウトした人のPATHにGNU @code{automake}、GNU @code{autoconf}、GNU
@code{m4}のようなツールがインストールされている必要があり、ときには特定のバージョンが必要になる。@*
2b
リリース版が作成されて生成されるファイルもコミットされた後に他の開発者がローカルのサ行をリポジトリーに書き戻してマージするときに、生成されるファイルで競合が発生する点。この競合は簡単に解決できますが、煩わしいものです。

@item
3番目の方法の利点はメンテナーの作業負荷が軽減されることです。欠点はソースをチェックアウトした人のPATHにGNU @code{automake},
GNU @code{autoconf}, GNU
@code{m4}のようなツールがインストールされている必要があるだけではなく、"./configure;
make"をできるようになる前に、パッケージ固有のpre-build(ビルド前)ステップが必要になることです。
@end enumerate

1番目と2番目の方法では、変更されたファイルや、@code{gettextize}呼び出しにより生成・更新されたファイルは、リポジトリーにコミットする必要があります。

3番目の方法では、@code{gettextize}が"コピー"するすべてのファイルを、レポジトリーから除外できます。そのかわりに@file{configure.ac}(または@file{configure.in})を、以下のような形式で記述します

@example
AM_GNU_GETTEXT_VERSION(@value{ARCHIVE-VERSION})
@end example

@noindent
さらにパッケージのpre-buildスクリプトに@samp{autopoint}呼び出しを追加します。ソースをチェックアウトする人は誰でも、この@samp{autopoint}呼び出しによりリポジトリーから除外された@code{gettext}の基礎的なファイルが適切な場所にコピーされます。

@code{AM_GNU_GETTEXT_VERSION}の引数に使用されているバージョン番号は、パッケージが使いたい@code{gettext}インフラストラクチャーのバージョン番号です。これは@samp{autopoint}プログラムの最小のバージョン番号でもあります。もし@code{AM_GNU_GETTEXT_VERSION(0.11.5)}と記述した場合、開発者は0.11.5以上のバージョンを使用でき、すべての開発者のビルドがバージョン0.11.5のインフラストラクチャーで動作します。メンテナーがパッケージにたいしてバージョン0.12.1を指定してgettextizeを実行したとき、@code{AM_GNU_GETTEXT_VERSION(0.11.5)}は@code{AM_GNU_GETTEXT_VERSION(0.12.1)}に変更され、今後CVSを使う開発者はGNU
@code{gettext} 0.12.1以降をインストールする必要があります。

@node Translations under Version Control
@subsection Put PO Files under Version Control

ソースコードと同様に、翻訳は価値のある資産なので、バージョンコントロール下に置くことには意味があるでしょう。GNU
gettextのインフラストラクチャーは、バージョンコントロールされたリポジトリーのコンテキスト内で翻訳を取り扱うために、2つの方法をサポートします。

@enumerate
@item
POTファイルとPOファイルの両方が、リポジトリーにコミットされる。

@item
POファイルだけが、リポジトリーにコミットされる。

@end enumerate

ビルド時にPOTファイルが存在しない場合、@code{xgettext}でソースファイルをスキャンすることによりPOTファイルが生成され、それから依存的にPOファイルが再生成されます。一方、開発フェーズにおいてPOTが変更されないことを望むメンテナーもいます。そのため、POTが存在して、それがソースコードより古い場合でも、自動的に更新しません。@code{make
$(DOMAIN).pot-update}により手動で更新して、特定の時点でコミットすることができます。

特定のバージョンコントロールシステムにたいする、特別なアドバイスがあります:

@itemize @bullet
@item
たとえばGitのような、最近のバージョンコントロールシステムは、ファイルのタイムスタンプを無視します。この場合、POTファイルが更新されていなくても、意図せずPOファイルが更新されてしまうかもしれません。これを防ぐには、@file{Makevars}内の@samp{PO_DEPENDS_ON_POT}変数@code{no}にセットして、@code{make
update-po}で手動で更新を行うことができます。

@item
@code{#:
lib/error.c:116}のような位置コメントは、これらのコメントが変更されやすく、作業用コピーのビルド時に意図せず変更されるかもしれないため、煩わしいときがあります。これを緩和するために、リポジトリー内のPOファイルから、これらのコメントを省略することができます。

これは@code{msgmerge}コマンドの@code{--no-location}オプションで行うことができます
@footnote{@file{Makevars}の@samp{MSGMERGE_OPTIONS}オプションを通じて行うこともできます。}。この方法の欠点は、位置情報が必要になった場合、翻訳者が再度@code{msgmerge}を実行して位置コメントを復元する必要があることです。

@end itemize

@node autopoint Invocation
@subsection @code{autopoint}プログラムの呼び出し

@include autopoint.texi

@node Release Management
@section 配布用tarballの作成

@cindex release
@cindex distribution tarball
GNU @code{automake}を使うプロジェクトでは、配布用のtarballを作成する通常のコマンドは、@samp{make
dist}または@samp{make distcheck}で、これにより必要に応じて自動的にPOファイルが更新されます。

GNU @code{automake}を使用していない場合、メンテナーはこのような更新をリリースの前に行う必要があります:

@example
$ ./configure
$ (cd po; make update-po)
$ make distclean
@end example

@node Installers
@chapter インストーラーと配布者の視点
@cindex package installer's view of @code{gettext}
@cindex package distributor's view of @code{gettext}
@cindex package build and installation options
@cindex setting up @code{gettext} at build time

デフォルトでは、内部的にGNU
@code{gettext}をフルに使っているパッケージは、翻訳されたメッセージを使えるような方法でインストールされます。@emph{configuration}実行時には、これらのパッケージはホストシステムですでにGNU
@code{gettext}の機能が提供されているかを、自動的に検出する必要があります。もし提供されていない場合、GNU
@code{gettext}ライブラリーが自動的に準備・使用されます。インストーラーは、configure時のこの動作を変更するための特別なオプションを使うことができます。コマンド@samp{./configure
--with-included-gettext}により、そのシステムの@code{gettext}をバイパスしてかわりに同梱された GNU
@code{gettext}を使用します。また@samp{./configure
--disable-nls}では、翻訳されたメッセージを利用しないプログラムを生成します。

@vindex LINGUAS@r{, environment variable}
インターナショナライズされたパッケージには通常、多くの@file{@var{ll}.po}ファイルがあります。翻訳が利用不可になっていなければ、パッケージのインストールによりそれらが利用可能になります。しかしconfigureに先立ち環境変数の@code{LINGUAS}がセットされていると、インストールされる対象が制限されます。@code{LINGUAS}はスペースで区切られた2文字のコードのリストで、利用できる言語を指定します。

@node Programming Languages
@chapter その他のプログラミング言語

@code{gettext}が提供するものの大部分はC(これは暗黙でC++にも同様に適用できます)に焦点をあてていますが、それ以外にも他の多くのプログラム言語やスクリプト言語、その他のテキストデータ、たとえばGUIリソースやパッケージの説明にも@code{gettext}の手法を用いることができます。

@menu
* Language Implementors::    The Language Implementor's View
* Programmers for other Languages::  The Programmer's View
* Translators for other Languages::  The Translator's View
* Maintainers for other Languages::  The Maintainer's View
* List of Programming Languages::  Individual Programming Languages
@end menu

@node Language Implementors
@section 言語実装者の視点
@cindex programming languages
@cindex scripting languages

すべてのプログラム言語およびスクリプト言語は、@code{gettext}をサポートするのに適した文字列の表記をもっています。@code{gettext}をサポートするとは、以下のことを意味します:

@enumerate
@item
翻訳可能な文字列にたいする書式を言語に追加する必要があります。原則としては@code{gettext}の関数呼び出しですが、省略した書式はインターナショナライズされたプログラムの可読性を向上する助けとなります。たとえばCでは@code{_("string")}、GNU
awkでは@code{_"string"}という書式が使用されます。

@item
実行時の@code{gettext}呼び出し(または等価な処理)により、このような翻訳可能な文字列を評価するための用意をする必要があります。

@item
同様に、その言語で@code{ngettext}、@code{dcgettext}、@code{dcngettext}の関数を利用可能にする必要があります。これらの関数が使用されることは少ないかもしれません。しかし@code{ngettext}は正しくpluralを処理するために、そして@code{dcgettext}と@code{dcngettext}は@code{LC_TIME}や@code{LC_MONETARY}などの、@code{LC_MESSAGES}以外のlocale関連の環境変数を処理する等の、特別の目的のために必要です。後者の関数についてはCのヘッダーファイル@code{<locale.h>}の定数@code{LC_*}が通常、環境変数や文字列で参照するため、その言語からも参照できるようにする必要があります。

@item
その言語から@code{textdomain}関数を利用可能にするか、@code{TEXTDOMAIN}のような"魔法"の変数を用意するなどして、プログラマーがメッセージドメインを明示できるようにする必要があります。同様に、@code{bindtextdomain}関数のように、プログラマーがメッセージカタログをどこから検索するかを、明示できるようにする機能を提供する必要があります。

@item
@code{setlocale (LC_ALL,
"")}を、言語が実行されたスタートアップ時に呼び出すか、プログラマーが呼び出して処理できるようにするべきです。localeカテゴリーの@code{LC_MESSAGES}と@code{LC_CTYPE}がどちらもセットされていないときは、gettextはno-opとして振る舞うことを思い出してください。

@item
プログラマーには、プログラムから翻訳可能な文字列をPOファイルに抽出する方法が必要です。GNU
@code{xgettext}は、非常に多くの異なるプログラム言語をサポートするように拡張されています。どうすればサポートされるかについては、GNU
@code{gettext}のメンテナーに連絡してください。文字列の抽出機能が、あなたの言語のパーサーに統合されれば、GNU
@code{xgettext}をあなたの言語の文字列抽出機能のフロントエンドとすることができます。

@item
言語のライブラリーに、書式文字列と書式文字列の引数を位置番号や名前で示せるような機能をもたせる必要があります。これはいくつかの言語やメッセージでは、2つ以上の代替の引数にたいして、翻訳者はそれらの代替の引数を異なった順序で出力する必要があるからです。詳細は、@ref{c-format
Flag}を参照してください。

@item
言語に2つ以上の実装があって、それらのすべてが@code{gettext}を実装している訳ではないにもかかわらず、それらの異なる実装間でプログラムに可搬性をもたせなければならないような場合には、no-i18nエミュレーションを提供する必要があります。これにより、実際に翻訳された文字列がなくても、あなたの実装向けに記述されたプログラムを他の実装で利用することができます。

@item
プログラマーが翻訳文字列にマークを付与するタスクを助けるために、EmacsのPOモードが使用される場合があります(@ref{Marking}を参照してください)。遠慮なくGNU
@code{gettext}のメンテナーに連絡してください。そうすれば彼らが@file{po-mode.el}にあなたの言語にたいするサポートを追加することができます。
@end enumerate

実装から考えると、可搬性と著作権の面において異なる効果をもつ、2つのアプローチが利用できます。

@itemize @bullet
@item
CライブラリーのGNU
@code{gettext}関数にたいしてリンクする方法があります。たとえば、autoconfが@code{gettext()}を@code{ngettext()}をテストしてこの状況を検知します。当面のところ、このテストはGNUシステム、およびSolaris
11システムでは成功するでしょう。また、静的にリンクされたバイナリーの配布を望む場合を除き、厳密な著作権の制限はありません。

@item
GNU
@code{gettext}の機能をエミュレート、もしくは再実装する方法があります。この方法には、完全な可搬性と著作権の制限がないという利点があります。しかしGNU
@code{gettext}の機能(環境変数@code{LANGUAGE}、locale
aliaseのデータベース、自動的な文字コード変換、pluralの処理のような機能)を再実装する必要があるという欠点もあります。
@end itemize

@node Programmers for other Languages
@section プログラマーの視点

プログラマーにとって、一般的な手続きはC言語の場合と同じです。EmacsのPO モードによるマークづけは他の言語もサポートしており、GNU
@code{xgettext}の文字列抽出も、ファイルの拡張子やコマンドラインのオプションで他の言語を識別できます。実行時の言語にしたがって実行されるために、@code{setlocale}を必要としない言語もいくつかあります。

@node Translators for other Languages
@section 翻訳者の視点

翻訳者の作業はC言語の場合と同じです。唯一の違いは書式文字列の翻訳で、彼女は書式文字列にたいする、その言語特有の位置引数を理解する必要があります。

@menu
* c-format::                 C Format Strings
* objc-format::              Objective C Format Strings
* sh-format::                Shell Format Strings
* python-format::            Python Format Strings
* lisp-format::              Lisp Format Strings
* elisp-format::             Emacs Lisp Format Strings
* librep-format::            librep Format Strings
* scheme-format::            Scheme Format Strings
* smalltalk-format::         Smalltalk Format Strings
* java-format::              Java Format Strings
* csharp-format::            C# Format Strings
* awk-format::               awk Format Strings
* object-pascal-format::     Object Pascal Format Strings
* ycp-format::               YCP Format Strings
* tcl-format::               Tcl Format Strings
* perl-format::              Perl Format Strings
* php-format::               PHP Format Strings
* gcc-internal-format::      GCC internal Format Strings
* gfc-internal-format::      GFC internal Format Strings
* qt-format::                Qt Format Strings
* qt-plural-format::         Qt Plural Format Strings
* kde-format::               KDE Format Strings
* kde-kuit-format::          KUIT Format Strings
* boost-format::             Boost Format Strings
* lua-format::               Lua Format Strings
* javascript-format::        JavaScript Format Strings
@end menu

@node c-format
@subsection Cフォーマット文字列

Cの書式文字列はPOSIX(IEEE P1003.1 2001)のセクションXSH 3 fprintf()
@uref{http://www.opengroup.org/onlinepubs/007904975/functions/fprintf.html}で説明されています。また
fprintf()のman
@uref{http://www.linuxvalley.it/encyclopedia/ldp/manpage/man3/printf.3.php},
@uref{http://informatik.fh-wuerzburg.de/student/i510/man/printf.html}も参照してください。

以下のような、引数の位置を再指定する書式文字列があったとします

@example
"Only %2$d bytes free on '%1$s'."
@end example

@noindent
これは以下の文と同じ意味をあらわします

@example
"'%s' has only %d bytes free."
@end example

@noindent
これはPOSIX/XSIの機能であり、ISO C 99には明記されていませんが、翻訳者はこの再配置の機能を信頼することができます:
ネイティブでは@code{printf()}や@code{fprintf()}などがこの機能をサポートしていないプラットフォームも存在しますが、@file{libintl.a}(または@file{libintl.so})が再配置の関数を提供していて、@code{<libintl.h>}がこれらの再配置のための関数を自動的に有効化するからです。

@cindex outdigits
@cindex Arabic digits
Farsi(Persian)そして多分Arabicのための特別な機能として、翻訳者は数値の書式指定子に@samp{I}フラグを挿入できます。この場合、たとえば@code{"%d"}は@code{"%Id"}
に翻訳されます。このフラグを指定すると、GNU
@code{libc}のあるシステムでは、ASCIIでの数字の出力が、localeカテゴリーの@code{LC_CTYPE}で定義された@samp{outdigits}により置き換えられます。他のシステムでは、@code{gettext}関数がフラグを取り除くため、何の影響もありません。

プログラマーはこのフラグを未翻訳の文字列に
挿入するべきでは@emph{ない}ことに注意してください(文字列@var{msgid}の書式指定のフラグに@samp{I}を挿入すると、glibcがないシステムでNLSが無効になっているときに、未定義の動作を招きます)。

@node objc-format
@subsection Objective Cフォーマット文字列

Objective Cの書式文字列は、Cの書式文字列と似ています。Objective
Cの場合は、追加の書式指定子として、実行時に引数を@code{Object *}タイプとして評価するための"%@@"をサポートします。

@node sh-format
@subsection Shellフォーマット文字列

Shellの書式文字列はGNU
gettextと@samp{envsubst}プログラムにより、@code{$@var{variable}}または@code{$@{@var{variable}@}}という形式で参照されるシェル変数がサポートされています。@code{$@{@var{variable}-@var{default}@}}、@code{$@{@var{variable}:-@var{default}@}}、@code{$@{@var{variable}=@var{default}@}}、@code{$@{@var{variable}:=@var{default}@}}、@code{$@{@var{variable}+@var{replacement}@}}、@code{$@{@var{variable}:+@var{replacement}@}}、@code{$@{@var{variable}?@var{ignored}@}}、@code{$@{@var{variable}:?@var{ignored}@}}で参照される、シェルスクリプト内だけで有効な形式はサポートされません。@var{variable}の名前には、半角の英数字かASCII文字のアンダースコアーしか含められません。また数字で開始することはできず、空も指定できません。そのような変数にたいする参照は無視されます。

@node python-format
@subsection Pythonフォーマット文字列

Pythonには2つの書式文字列があります。@samp{python-format}としてラベルづけされたPythonのビルトイン書式オペレーター@code{%}と、@samp{str}オブジェクトの@code{format}に適用できます。

Pythonの@code{%}書式文字列については、@w{Python Library reference} / @w{5. Built-in
Types} / @w{5.6. Sequence Types} / @w{5.6.2. String Formatting
Operations}で説明されています。@uref{https://docs.python.org/2/library/stdtypes.html#string-formatting-operations}を参照してください。

Pythonカッコつき書式文字列(Python brace format strings)は、@w{PEP 3101 -- Advanced
String
Formatting}、@uref{https://www.python.org/dev/peps/pep-3101/}で説明されています。

@node lisp-format
@subsection Lispフォーマット文字列

Lispの書式文字列はCommon Lisp HyperSpecのchapter 22.3 @w{Formatted
Output}、@uref{http://www.ai.mit.edu/projects/iiip/doc/CommonLISP/HyperSpec/Body/sec_22-3.html}で説明されています。

@node elisp-format
@subsection Emacs Lispフォーマット文字列

Emacs Lispの書式文字列はEmacs Lisp referenceのsection @w{Formatting
Strings}、@uref{https://www.gnu.org/manual/elisp-manual-21-2.8/html_chapter/elisp_4.html#SEC75}に記述されています。バージョン21のXEmacsでは、FSF
Emacsがサポートしていない、書式文字列内に番号付けられた引数指定をサポートすることに注意してください。

@node librep-format
@subsection librepフォーマット文字列

librepの書式文字列はlibrep manualのsection@w{Formatted
Output}、@url{http://librep.sourceforge.net/librep-manual.html#Formatted%20Output}、@url{http://www.gwinnup.org/research/docs/librep.html#SEC122}に記述されています。

@node scheme-format
@subsection Schemeフォーマット文字列

Schemeの書式文字列はSLIB manualのsection Format Specification に記述されています。

@node smalltalk-format
@subsection Smalltalkフォーマット文字列

Smalltalkの書式文字列は、GNU Smalltalk documentationのclass @code{CharArray}、methods
@samp{bindWith:}と@samp{bindWithArguments:}で説明されています。@uref{https://www.gnu.org/software/smalltalk/gst-manual/gst_68.html#SEC238}を参照してください。要約すると、指定子は@samp{%}で開始され、@samp{%}か非0の数字(@samp{1}
to @samp{9})が後に続きます。

@node java-format
@subsection Javaフォーマット文字列

Javaの書式文字列はJDK documentationの class
@code{java.text.MessageFormat}、@uref{http://java.sun.com/j2se/1.4/docs/api/java/text/MessageFormat.html}で説明されています。ICU
documentation、@uref{http://oss.software.ibm.com/icu/apiref/classMessageFormat.html}も参照してください。

@node csharp-format
@subsection C#フォーマット文字列

C#の書式文字列は.NET documentationのclass
@code{System.String}と@uref{http://msdn.microsoft.com/library/default.asp?url=/library/en-us/cpguide/html/cpConFormattingOverview.asp}で説明されています。

@node awk-format
@subsection awkフォーマット文字列

awkの書式文字列はgawk documentationのsection
@w{Printf}、@uref{https://www.gnu.org/manual/gawk/html_node/Printf.html#Printf}で説明されています。

@node object-pascal-format
@subsection Object Pascalフォーマット文字列

Object Pascalの書式文字列はdocumentation of the Free Pascal runtime libraryのsection
Format、@uref{https://www.freepascal.org/docs-html/rtl/sysutils/format.html}で説明されています。

@node ycp-format
@subsection YCPフォーマット文字列

YCPの書式文字列はlibycp documentation
@uref{file:/usr/share/doc/packages/libycp/YCP-builtins.html}で説明されています。要約すると、指定子は@samp{%}で開始され、@samp{%}か非0の数字(@samp{1}から@samp{9})が続きます。

@node tcl-format
@subsection Tclフォーマット文字列

Tclの書式文字列は@file{format.n}のman、@uref{http://www.scriptics.com/man/tcl8.3/TclCmd/format.htm}で説明されています。

@node perl-format
@subsection Perlフォーマット文字列

Perlには2種類の書式文字列があります。@samp{perl-format}とラベルつけされたPerlのビルトイン関数@code{printf}と、@samp{perl-brace-format}とラベルつけされた@code{libintl-perl}関数@code{__x}で利用することができます。

Perlの@code{printf}の書式文字列は、@samp{man
perlfunc}の@code{sprintf}のsectionで説明されています。

perl braceの書式文字列はCPANのパッケージlibintl-perlの@file{Locale::TextDomain(3pm)}
manpageで説明されています。要約すると、Perl format
はカッコ(@samp{@{}と@samp{@}})の間に記述されたプレースホルダーを使用します。このプレースホルダーは簡単に識別できる構文でなければなりません。

@node php-format
@subsection PHPフォーマット文字列

PHPの書式文字列は、@file{phpdoc/manual/function.sprintf.html}、または@uref{http://www.php.net/manual/en/function.sprintf.php}で説明されています。

@node gcc-internal-format
@subsection GCC internalフォーマット文字列

これらの書式文字列は、GCCのソース内で使用されるものです。このような書式文字列では、指定子は@samp{%}で開始され、オプションのサイズ指定子@samp{l}、オプションフラグの@samp{+}、他のオプションフラグとして@samp{#}が続きます。終端させるための指定子は、@samp{%}の場合はリテラルのパーセント記号、@samp{c}の場合は文字、@samp{s}は文字列、@samp{i}および@samp{d}は整数、@samp{o},
@samp{u}, @samp{x}は符号なし整数、@samp{.*s}は前に幅指定をともなう文字列、@samp{H}@samp{location_t
*}型のポインター、@samp{D}は一般的な宣言、@samp{F}は関数宣言、@samp{T}は型、@samp{A}は関数の引数、@samp{C}はtree
code、@samp{E}は式、@samp{L}はプログラム言語、@samp{O}はバイナリー演算子、@samp{P}は関数パラメーター、@samp{Q}は
assignment operator、@samp{V}はconst/volatile qualifierを表します。

@node gfc-internal-format
@subsection GFC internalフォーマット文字列

これらの書式文字列はGNU Fortran Compilerのソース内で使用されます。これはGCC
ソースのFortran用フロントエンドです。このような書式文字列では、指定子は@samp{%}で開始され、終端させるための指定子は、@samp{%}はリテラルのパーセント記号、@samp{C}は現在のソース位置、@samp{L}はソースの位置、@samp{c}は文字、@samp{s}は文字列、@samp{i}
and
@samp{d}は整数、@samp{u}は符号なし整数で、@samp{i}、@samp{d}、@samp{u}の場合は前には、サイズ指定子@samp{l}が指定されている場合があります。

@node qt-format
@subsection Qtフォーマット文字列

Qtの書式文字列はdocumentation of the QString class
@uref{file:/usr/lib/qt-4.3.0/doc/html/qstring.html}で説明されています。要約すると、指定子は@samp{%}とその後ろの数字から成り立ちます。1つの書式文字列内に同じ指定子を2回以上使うことはできません。

@node qt-plural-format
@subsection Qtフォーマット文字列

Qtの書式文字列は documentation of the QObject::tr method
@uref{file:/usr/lib/qt-4.3.0/doc/html/qobject.html}で説明されています。要約すると、使用できる指定子は@samp{%n}だけです。

@node kde-format
@subsection KDEフォーマット文字列

KDE 4の書式文字列は次のように定義されています:
指定子は@samp{%}とその後ろの非0の10進数からなります。書式文字列内に@samp{%n}がある場合、それ以外の@samp{%1}、...、@samp{%(n-1)}も存在しなければなりません。

@node kde-kuit-format
@subsection KUIT Format Strings

KUIT(KDE User Interface Text)は、KDE
4の書式文字列と互換性があります。その上、KUITでは、プログラマーがXMLマークアップタグを通じて、セマンティック情報を追加することもできます。たとえば、文字列内の1番目のフォーマット指定がファイル名の場合、プログラマーは@samp{filename}タグを使用して、@samp{<filename>%1</filename>}のようにそれを示すことができます。

KUIT書式文字列は、@uref{https://api.kde.org/frameworks/ki18n/html/prg_guide.html#kuit_markup}で説明されています。

@node boost-format
@subsection Boostフォーマット文字列

Boostの書式文字列は、@uref{https://www.boost.org/libs/format/doc/format.html}のdocumentation
of the boost::format class
で説明されています。要約すると、指定子は@samp{%1$+5d}のようなCの書式文字列と同じ文法、または@samp{%|1$+5d|}や@samp{%|1$+5|}のように垂直バー囲まれたものか、@samp{%1%}のように単にパーセント記号で囲まれたものです。

@node lua-format
@subsection Luaフォーマット文字列

Luaの書式文字列は、Lua reference manualのsection @w{String
Manipulation}で説明されています。@uref{https://www.lua.org/manual/5.1/manual.html#pdf-string.format}を参照してください。

@node javascript-format
@subsection Java Scriptフォーマット文字列

JavaScript仕様には書式文字列が定義されていないとはいえ、多くのJavaScript実装はprintf-likeな関数を提供します。@code{xgettext}は、Gjs、Seed、Node.JSを含む著名なJavaScript実装で使用される、一般的な書式文字列のセットを理解します。そのような書式文字列では、書式指定は@samp{%}で開始され、以下の指定子で終端されます:
@samp{%}はリテラルのパーセント、@samp{c}は文字、@samp{s}は文字列、@samp{b}、@samp{d}、@samp{o}、@samp{x}、@samp{X}は整数、@samp{f}は浮動小数点数、@samp{j}はJSONオブジェクトを表します。


@node Maintainers for other Languages
@section メンテナーの視点

メンテナーにとっては、一般的な手続きでC言語の場合での方法と異なるのは、以下のケースです。

@itemize @bullet
@item
もし使用されているプログラム言語が1つだけの場合には、@file{po/Makevars}(@ref{po/Makevars}を参照してください)の変数@code{XGETTEXT_OPTIONS}は、@code{xgettext}のその言語向け特有のオプションにする必要があります。パッケージが@code{gettext}のサポートを複数のプログラム言語を使用している場合、@file{po/Makefile.in.in}内のPOTファイルの構築ルールを変更する必要があります。この場合は、1つのプログラム言語ごとに、言語に適したオプションで@code{xgettext}呼び出しを行い、@code{msgcat}により結果ファイルを結合する方法をお勧めします。
@end itemize

@node List of Programming Languages
@section 個別のプログラミング言語

@c Here is a list of programming languages, as used for Free Software projects
@c on SourceForge/Freshmeat, as of February 2002.  Those supported by gettext
@c are marked with a star.
@c   C                       3580     *
@c   Perl                    1911     *
@c   C++                     1379     *
@c   Java                    1200     *
@c   PHP                     1051     *
@c   Python                   613     *
@c   Unix Shell               357     *
@c   Tcl                      266     *
@c   SQL                      174
@c   JavaScript               118
@c   Assembly                 108
@c   Scheme                    51
@c   Ruby                      47
@c   Lisp                      45     *
@c   Objective C               39     *
@c   PL/SQL                    29
@c   Fortran                   25
@c   Ada                       24
@c   Delphi                    22
@c   Awk                       19     *
@c   Pascal                    19
@c   ML                        19
@c   Eiffel                    17
@c   Emacs-Lisp                14     *
@c   Zope                      14
@c   ASP                       12
@c   Forth                     12
@c   Cold Fusion               10
@c   Haskell                    9
@c   Visual Basic               9
@c   C#                         6     *
@c   Smalltalk                  6     *
@c   Basic                      5
@c   Erlang                     5
@c   Modula                     5
@c   Object Pascal              5     *
@c   Rexx                       5
@c   Dylan                      4
@c   Prolog                     4
@c   APL                        3
@c   PROGRESS                   2
@c   Euler                      1
@c   Euphoria                   1
@c   Pliant                     1
@c   Simula                     1
@c   XBasic                     1
@c   Logo                       0
@c   Other Scripting Engines   49
@c   Other                    116

@menu
* C::                        C, C++, Objective C
* sh::                       sh - Shell Script
* bash::                     bash - Bourne-Again Shell Script
* Python::                   Python
* Common Lisp::              GNU clisp - Common Lisp
* clisp C::                  GNU clisp C sources
* Emacs Lisp::               Emacs Lisp
* librep::                   librep
* Scheme::                   GNU guile - Scheme
* Smalltalk::                GNU Smalltalk
* Java::                     Java
* C#::                       C#
* gawk::                     GNU awk
* Pascal::                   Pascal - Free Pascal Compiler
* wxWidgets::                wxWidgets library
* YCP::                      YCP - YaST2 scripting language
* Tcl::                      Tcl - Tk's scripting language
* Perl::                     Perl
* PHP::                      PHP Hypertext Preprocessor
* Pike::                     Pike
* GCC-source::               GNU Compiler Collection sources
* Lua::                      Lua
* JavaScript::               JavaScript
* Vala::                     Vala
@end menu

@node C
@subsection C、C++、Objective
@cindex C and C-like languages

@table @asis
@item RPM
gcc、gpp、gobjc、glibc、gettext

@item Ubuntu packages
gcc, g++, gobjc, libc6-dev, libasprintf-dev

@item ファイル拡張子
C: @code{c}、@code{h}@*
C++: @code{C}、@code{c++}、@code{cc}、@code{cxx}、@code{cpp}、@code{hpp}@*
Objective C: @code{m}

@item 文字列構文
@code{"abc"}

@item gettextの略記
@code{_("abc")}

@item gettext/ngettext関数
@code{gettext}、@code{dgettext}、@code{dcgettext}、@code{ngettext}、@code{dngettext}、@code{dcngettext}

@item textdomain
@code{textdomain}関数

@item bindtextdomain
@code{bindtextdomain}関数

@item setlocale
プログラマーは、@code{setlocale (LC_ALL, "")}を呼び出さなければなりません。

@item 必要条件
@code{#include <libintl.h>} @*
@code{#include <locale.h>} @*
@code{#define _(string) gettext (string)}

@item GNU gettextの使用またはエミュレート
使用

@item 抽出プログラム
@code{xgettext -k_}

@item 位置の書式
@code{fprintf "%2$d %1$d"} @*
C++は@code{autosprintf "%2$d %1$d"} (@ref{Top, , Introduction, autosprintf,
GNU autosprintf}を参照してください)

@item 可搬性
autoconf(gettext.m4)、および#if ENABLE_NLS

@item po-modeでのマーキング
yes
@end table

@file{examples}ディレクトリーの以下の例が利用できます:
@code{hello-c}、@code{hello-c-gnome}、@code{hello-c++}、@code{hello-c++-qt}、@code{hello-c++-kde}、@code{hello-c++-gnome}、@code{hello-c++-wxwidgets}、@code{hello-objc}、@code{hello-objc-gnustep}、@code{hello-objc-gnome}

@node sh
@subsection sh - シェルスクリプト
@cindex shell scripts

@table @asis
@item RPM
bash、gettext

@item Ubuntu packages
bash, gettext-base

@item ファイル拡張子
@code{sh}

@item 文字列構文
@code{"abc"}、@code{'abc'}、@code{abc}

@item gettextの略記
@code{"`gettext \"abc\"`"}

@item gettext/ngettext関数
@pindex gettext
@pindex ngettext
プログラム: @code{gettext}、@code{ngettext}@*
シェル関数:
@code{eval_gettext}、@code{eval_ngettext}、@code{eval_pgettext}、@code{eval_npgettext}

@item textdomain
@vindex TEXTDOMAIN@r{, environment variable}
環境変数@code{TEXTDOMAIN}

@item bindtextdomain
@vindex TEXTDOMAINDIR@r{, environment variable}
環境変数@code{TEXTDOMAINDIR}

@item setlocale
自動

@item 必要条件
@code{. gettext.sh}

@item GNU gettextの使用またはエミュレート
使用

@item 抽出プログラム
@code{xgettext}

@item 位置の書式
---

@item 可搬性
完全な可搬性がある

@item po-modeでのマーキング
---
@end table

@file{examples}ディレクトリーの例@code{hello-sh}が利用できます

@menu
* Preparing Shell Scripts::  Preparing Shell Scripts for 
                               Internationalization
* gettext.sh::               Contents of @code{gettext.sh}
* gettext Invocation::       Invoking the @code{gettext} program
* ngettext Invocation::      Invoking the @code{ngettext} program
* envsubst Invocation::      Invoking the @code{envsubst} program
* eval_gettext Invocation::  Invoking the @code{eval_gettext} function
* eval_ngettext Invocation::  Invoking the @code{eval_ngettext} function
* eval_pgettext Invocation::  Invoking the @code{eval_pgettext} function
* eval_npgettext Invocation::  Invoking the @code{eval_npgettext} function
@end menu

@node Preparing Shell Scripts
@subsubsection インターナショナリゼーションのためにシェルスクリプトを準備する
@cindex preparing shell scripts for translation

インターナショナリゼーションにむけたシェルの準備は、概念的には@ref{Sources}で説明したステップと似ています。以下はシェルスクリプトのための具体的なステップです。

@enumerate
@item
スクリプトの冒頭付近に、以下の行を挿入します。

@smallexample
. gettext.sh
@end smallexample

@code{gettext.sh}は、関数@code{eval_gettext}(@ref{eval_gettext
Invocation}を参照)、@code{eval_ngettext}(@ref{eval_ngettext
Invocation}を参照)、@code{eval_pgettext}(@ref{eval_pgettext
Invocation}を参照)、@code{eval_npgettext}(@ref{eval_npgettext
Invocation}を参照)を提供するシェルの関数ライブラリーです。@code{gettext.sh}は、@code{PATH}に記述された検索パスに配置されている必要があります。

@item
環境変数@code{TEXTDOMAIN}および@code{TEXTDOMAINDIR}を、setしてexportします。@code{TEXTDOMAIN}は通常はパッケージ名かプログラム名、@code{TEXTDOMAINDIR}は@code{$prefix/share/locale}に対応する絶対パスです。ここで@code{$prefix}はインストールした場所です。

@smallexample
TEXTDOMAIN=@@PACKAGE@@
export TEXTDOMAIN
TEXTDOMAINDIR=@@LOCALEDIR@@
export TEXTDOMAINDIR
@end smallexample

@item
@ref{Preparing Strings}で説明しているように、翻訳する文字列を準備します。

@item
翻訳可能な文字列を単純にするため、コマンドによる文字列の置き換え((@code{"`...`"}または@code{"$(...)"}))や、デフォルト値が含まれる変数(例：@code{$@{@var{variable}-@var{default}@}})、@code{$0},
@code{$1}, ...のような引数参照、一時的なシェル変数(例:
@code{$?})を含めないようにします。こうすることにより、常に単純なlocalコードを再構築することができます。たとえば、

@smallexample
echo "Usage: $0 [OPTION] FILE..."
@end smallexample

は以下のように書き換えます

@smallexample
program_name=$0
echo "Usage: $program_name [OPTION] FILE..."
@end smallexample

同様に、

@smallexample
echo "Remaining files: `ls | wc -l`"
@end smallexample

は以下のように書き換えます

@smallexample
filecount="`ls | wc -l`"
echo "Remaining files: $filecount"
@end smallexample

@item
個々の翻訳可能な文字列にたいして、出力コマンド@samp{echo}や@samp{$echo}を、@samp{gettext}(文字列にシェル変数の参照が含まれない場合)や@samp{eval_gettext}(シェル変数を参照する場合)に変更して、その後ろに引数を指定しない@samp{echo}コマンドを記述します(これは行末の改行のためです)。pluralを扱う場合は同様に、@samp{echo}コマンドを@samp{ngettext}または@samp{eval_ngettext}の呼び出しに置き換えて、後に引数なしの@samp{echo}コマンドを記述します。

この変更を行う際には、シェル変数への参照の前にある$記号をエスケープするためのバックスラッシュを追加する必要もあります。そうすれば@samp{eval_gettext}関数が変数が置き換える前の、翻訳可能な文字列を受けとることができます。例えば以下のような文字列で考えてみましょう

@smallexample
echo "Remaining files: $filecount"
@end smallexample

は以下のように書き換えます

@smallexample
eval_gettext "Remaining files: \$filecount"; echo
@end smallexample

出力コマンドが@samp{echo}ではないときも、バッククォートにより@samp{echo}を使うことができます。バッククォートの内側では、バックスラッシュを2重に指定しなければ効果がないことに注意しなければなりません(これはバッククォートすることにより、バックスラッシュが1階層分消費されるからです)。例として、@samp{echo}がエラーをシグナルするシェル関数だとすると、

@smallexample
error "file not found: $filename"
@end smallexample

は最初に以下へ変換され

@smallexample
error "`echo \"file not found: \$filename\"`"
@end smallexample

となり、その後以下のようになります

@smallexample
error "`eval_gettext \"file not found: \\\$filename\"`"
@end smallexample
@end enumerate

@node gettext.sh
@subsubsection @code{gettext.sh}の内容

@code{gettext.sh}にはGNU gettextのランタイム パッケージが含まれており、以下が提供されます:

@itemize @bullet
@item $echo
変数@code{echo}には、最初の引数(引数文字列内のバックスラッシュの解釈されません)と、改行を出力するコマンドがセットされます。

@item eval_gettext
@ref{eval_gettext Invocation}を参照してください。

@item eval_ngettext
@ref{eval_ngettext Invocation}を参照してください。

@item eval_pgettext
@ref{eval_pgettext Invocation}を参照してください。

@item eval_npgettext
@ref{eval_npgettext Invocation}を参照してください。
@end itemize

@node gettext Invocation
@subsubsection @code{gettext}プログラムの呼び出し

@include rt-gettext.texi

注意:
@code{xgettext}は@code{gettext}呼び出しで1つだけ引数を指定した形式(オプションを指定せず、環境変数から暗黙に@var{textdomain}を取得する形式)だけをサポートします。

@node ngettext Invocation
@subsubsection @code{ngettext}プログラムの呼び出し

@include rt-ngettext.texi

注意:
@code{xgettext}は@code{ngettext}呼び出しで3つの引数を指定した形式(オプションを指定せず、環境変数から暗黙に@var{textdomain}を取得する形式)だけをサポートします。

@node envsubst Invocation
@subsubsection @code{envsubst}プログラムの呼び出し

@include rt-envsubst.texi

@node eval_gettext Invocation
@subsubsection @code{eval_gettext}プログラムの呼び出し

@cindex @code{eval_gettext} function, usage
@example
eval_gettext @var{msgid}
@end example

@cindex lookup message translation
この関数は、テキストメッセージを母国語に翻訳して、翻訳した結果文字列に含まれる$記号のついた変数にたいして置き換え処理を行ってから出力します。$変数にたいする置き換えは、@var{msgid}に含まれるシェル変数にたいしてだけ行われることに注意してください。

@node eval_ngettext Invocation
@subsubsection @code{eval_ngettext}プログラムの呼び出し

@cindex @code{eval_ngettext} function, usage
@example
eval_ngettext @var{msgid} @var{msgid-plural} @var{count}
@end example

@cindex lookup plural message translation
この関数は、数に依存した文法をもつテキストメッセージを母国語に翻訳して、翻訳した結果文字列に含まれる$記号のついた変数にたいして置き換え処理を行ってから出力します。$変数にたいする置き換えは、@var{msgid}または@var{msgid-plural}に含まれるシェル変数にたいしてだけ行われることに注意してください。

@node eval_pgettext Invocation
@subsubsection Invoking the @code{eval_pgettext} function

@cindex @code{eval_pgettext} function, usage
@example
eval_pgettext @var{msgctxt} @var{msgid}
@end example

@cindex lookup message translation with context
この関数は、与えられたコンテキスト@var{msgctxt}(@ref{Contexts}を参照)内のテキストメッセージを母国語に翻訳して、翻訳した結果文字列に含まれる$記号のついた変数にたいして置き換え処理を行ってから出力します。$変数にたいする置き換えは、@var{msgid}に含まれるシェル変数にたいしてだけ行われることに注意してください。

@node eval_npgettext Invocation
@subsubsection Invoking the @code{eval_npgettext} function

@cindex @code{eval_npgettext} function, usage
@example
eval_npgettext @var{msgctxt} @var{msgid} @var{msgid-plural} @var{count}
@end example

@cindex lookup plural message translation with context
この関数は、与えられたコンテキスト@var{msgctxt}(@ref{Contexts}を参照)内の数に依存した文法をもつテキストメッセージを母国語に翻訳して、翻訳した結果文字列に含まれる$記号のついた変数にたいして置き換え処理を行ってから出力します。$変数にたいする置き換えは、@var{msgid}または@var{msgid-plural}に含まれるシェル変数にたいしてだけ行われることに注意してください。

@node bash
@subsection bash - Bourne-Againシェルスクリプト
@cindex bash

GNU @code{bash}
2.0以降には、変数の中の文字列を翻訳して置き換えるための特別な略記法@code{$"msgid"}があります。しかし、これによりもたらされるセキュリティーホールと可搬性の問題により、この機能の使用には
賛成できません。

@code{$"..."}によるセキュリティーホールとは、その文字列にたいする翻訳を検索した後、@samp{eval}が2重引用符に囲まれた文字列や$
記号、バッククォートされた文字列にたいして行うのと同様なことを@code{bash}が行う点にあります。

@enumerate
@item
エンコーディングがBIG5、BIG5-HKSCS、GBK、GB18030、SHIFT_JIS、JOHABのいずれかを使うlocaleでは、2byte文字の2byte目が@code{0x60}の文字が存在します。たとえば、これらのlocaleでは@code{\xe0\x60}というバイト並びは1つの文字です。@code{bash}の多くのバージョン(bash-2.05以降、およびmbsrtowcs()関数を持たないプラットフォーム向けの新しいバージョン)は、文字境界を認識しないので、特定のChinese文字をバッククォートと認識します。このため翻訳の一部がコマンドリストとして実行されてしまうことが起こり得るのです。この状況は翻訳者が気をつけていても起こり得ます。翻訳者が翻訳をUTF-8エンコーディングで提供したとしても、その翻訳は@code{gettext()}関数によって翻訳者のエンコーディングからユーザーのlocaleのエンコーディングに変換され、その変換によって"危険な"@code{\x60}というバイトが生成される可能性があるからです。

@item
故意にせよ不注意にせよ、翻訳者は翻訳の中にバッククォート@code{"`...`"}や、$カッコ@code{"$(...)"}を使用することもあり得るので、それらに囲まれた文字列はコマンドリストとしてシェルにより実行されてしまいます。
@end enumerate

可搬性の問題とは、@code{bash}をインターナショナリゼーションのサポート付きでビルドしなければならないことです。これはlibcに@code{gettext()}関数がないシステムでは、通常できません。

@node Python
@subsection Python
@cindex Python

@table @asis
@item RPM
python

@item Ubuntu packages
python

@item ファイル拡張子
@code{py}

@item 文字列構文
@code{'abc'}、@code{u'abc'}、@code{r'abc'}、@code{ur'abc'}、@*@code{"abc"}、@code{u"abc"}、@code{r"abc"}、@code{ur"abc"}、@*@code{'''abc'''}、@code{u'''abc'''}、@code{r'''abc'''}、@code{ur'''abc'''}、@*@code{"""abc"""}、@code{u"""abc"""}、@code{r"""abc"""}、@code{ur"""abc"""}

@item gettextの略記
@code{_('abc')}など

@item gettext/ngettext関数
@code{gettext.gettext}、@code{gettext.dgettext}、@code{gettext.ngettext}、@code{gettext.dngettext}、@code{ugettext}、@code{ungettext}

@item textdomain
@code{gettext.textdomain}関数、または@code{gettext.install(@var{domain})}関数

@item bindtextdomain
@code{gettext.bindtextdomain}関数、または@code{gettext.install(@var{domain},@var{localedir})}関数

@item setlocale
gettextエミュレーションでは使用されません

@item 必要条件
@code{import gettext}

@item GNU gettextの使用またはエミュレート
エミュレート

@item 抽出プログラム
@code{xgettext}

@item 位置の書式
@code{'...%(ident)d...' % @{ 'ident': value @}}

@item 可搬性
完全な可搬性がある

@item po-modeでのマーキング
---
@end table

@file{examples}ディレクトリーの例@code{hello-python}を利用できます。

書式文字列についての注意:
Pythonは@code{'...%d...'}のような名前なし引数の書式文字列をサポートと、@code{'...%(ident)d...'}のような名前つき引数の書式文字列をサポートする。以下の2つの理由により、インターナショナライズされたプログラムでは後者の方が好ましい

@itemize @bullet
@item
書式文字列が2つ以上の引数をとるときに、書式文字列に名前付きの引数を使っていれば、翻訳者は引数を異なる順序で使用するような翻訳を提供できます。例えば以下のような書式文字列
@smallexample
"'%(volume)s' has only %(freespace)d bytes free."
@end smallexample
@noindent
から
@smallexample
"Only %(freespace)d bytes free on '%(volume)s'."
@end smallexample
@noindent
に書き換えることができます。さらに識別名により翻訳者にコンテキストを提供できます。

@item
多くの言語のplural formのコンテキストでは、singular
formのための書式文字列で、数値引数は使用されません。Englishでも、@code{"1 hour"}より@code{"one
hour"}と書くのが好まれたりします。このように、書式文字列から特定の引数を除外するのは、名前付き引数の構文でのみ可能なことです(名前なし引数の場合、Python
は -- C とは異なり -- 与えられたすべての引数が書式文字列で使用されているかチェックするからです)。
@end itemize

@node Common Lisp
@subsection GNU clisp - Common Lisp
@cindex Common Lisp
@cindex Lisp
@cindex clisp

@table @asis
@item RPM
clisp 2.28以降

@item Ubuntu packages
clisp

@item ファイル拡張子
@code{lisp}

@item 文字列構文
@code{"abc"}

@item gettextの略記
@code{(_ "abc")}、@code{(ENGLISH "abc")}

@item gettext/ngettext関数
@code{i18n:gettext}、@code{i18n:ngettext}

@item textdomain
@code{i18n:textdomain}

@item bindtextdomain
@code{i18n:textdomaindir}

@item setlocale
自動

@item 必要条件
---

@item GNU gettextの使用またはエミュレート
使用

@item 抽出プログラム
@code{xgettext -k_ -kENGLISH}

@item 位置の書式
@code{format "~1@@*~D ~0@@*~D"}

@item 可搬性
gettextのないプラットフォームでは、翻訳しません

@item po-modeでのマーキング
---
@end table

@file{examples}ディレクトリーの例@code{hello-clisp}が利用できます

@node clisp C
@subsection GNU clisp ソース
@cindex clisp C sources

@table @asis
@item RPM
clisp

@item Ubuntu packages
clisp

@item ファイル拡張子
@code{d}

@item 文字列構文
@code{"abc"}

@item gettextの略記
@code{ENGLISH ? "abc" : ""} @*@code{GETTEXT("abc")} @*@code{GETTEXTL("abc")}

@item gettext/ngettext関数
@code{clgettext}、@code{clgettextl}

@item textdomain
---

@item bindtextdomain
---

@item setlocale
自動

@item 必要条件
@code{#include "lispbibl.c"}

@item GNU gettextの使用またはエミュレート
使用

@item 抽出プログラム
@code{clisp-xgettext}

@item 位置の書式
@code{fprintf "%2$d %1$d"}

@item 可搬性
gettextのないプラットフォームでは、翻訳しません

@item po-modeでのマーキング
---
@end table

@node Emacs Lisp
@subsection Emacs Lisp
@cindex Emacs Lisp

@table @asis
@item RPM
emacs、xemacs

@item Ubuntu packages
emacs, xemacs21

@item ファイル拡張子
@code{el}

@item 文字列構文
@code{"abc"}

@item gettextの略記
@code{(_"abc")}

@item gettext/ngettext関数
@code{gettext}、@code{dgettext}(xemacsのみ)

@item textdomain
スペシャルフォーム@code{domain}(xemacsのみ)

@item bindtextdomain
関数@code{bind-text-domain}(xemacsのみ)

@item setlocale
自動

@item 必要条件
---

@item GNU gettextの使用またはエミュレート
使用

@item 抽出プログラム
@code{xgettext}

@item 位置の書式
@code{format "%2$d %1$d"}

@item 可搬性
XEmacsのみ。ビルド時に@code{I18N3}を定義しない場合は、翻訳しません

@item po-modeでのマーキング
---
@end table

@node librep
@subsection librep
@cindex @code{librep} Lisp

@table @asis
@item RPM
librep 0.15.3以降

@item Ubuntu packages
librep16

@item ファイル拡張子
@code{jl}

@item 文字列構文
@code{"abc"}

@item gettextの略記
@code{(_"abc")}

@item gettext/ngettext関数
@code{gettext}

@item textdomain
@code{textdomain}関数

@item bindtextdomain
@code{bindtextdomain}関数

@item setlocale
---

@item 必要条件
@code{(require 'rep.i18n.gettext)}

@item GNU gettextの使用またはエミュレート
使用

@item 抽出プログラム
@code{xgettext}

@item 位置の書式
@code{format "%2$d %1$d"}

@item 可搬性
gettextのないプラットフォームでは、翻訳しません

@item po-modeでのマーキング
---
@end table

@file{examples}ディレクトリーの例@code{hello-librep}が利用できます

@node Scheme
@subsection GNU guile - Scheme
@cindex Scheme
@cindex guile

@table @asis
@item RPM
guile

@item Ubuntu packages
guile-2.0

@item ファイル拡張子
@code{scm}

@item 文字列構文
@code{"abc"}

@item gettextの略記
@code{(_ "abc")}, @code{_"abc"} (GIMP script-fu extension)

@item gettext/ngettext関数
@code{gettext}、@code{ngettext}

@item textdomain
@code{textdomain}

@item bindtextdomain
@code{bindtextdomain}

@item setlocale
@code{(catch #t (lambda () (setlocale LC_ALL "")) (lambda args #f))}

@item 必要条件
@code{(use-modules (ice-9 format))}

@item GNU gettextの使用またはエミュレート
使用

@item 抽出プログラム
@code{xgettext -k_}

@item 位置の書式
@c @code{format "~1@@*~D ~0@@*~D~2@@*"}, requires @code{(use-modules (ice-9 format))}
@c not yet supported
---

@item 可搬性
gettextのないプラットフォームでは、翻訳しません

@item po-modeでのマーキング
---
@end table

@file{examples}ディレクトリーの例@code{hello-guile}が利用できます

@node Smalltalk
@subsection GNU Smalltalk
@cindex Smalltalk

@table @asis
@item RPM
smalltalk

@item Ubuntu packages
gnu-smalltalk

@item ファイル拡張子
@code{st}

@item 文字列構文
@code{'abc'}

@item gettextの略記
@code{NLS ? 'abc'}

@item gettext/ngettext関数
@code{LcMessagesDomain>>#at:}、@code{LcMessagesDomain>>#at:plural:with:}

@item textdomain
@code{LcMessages>>#domain:localeDirectory:}(オブジェクト@code{LcMessagesDomain}を返します)@*
例: @code{I18N Locale default messages domain: 'gettext' localeDirectory:
/usr/local/share/locale'}

@item bindtextdomain
@code{LcMessages>>#domain:localeDirectory:}、上記参照

@item setlocale
@code{I18N Locale default}をuseする場合は自動

@item 必要条件
@code{PackageLoader fileInPackage: 'I18N'!}

@item GNU gettextの使用またはエミュレート
エミュレート

@item 抽出プログラム
@code{xgettext}

@item 位置の書式
@code{'%1 %2' bindWith: 'Hello' with: 'world'}

@item 可搬性
完全な可搬性がある

@item po-modeでのマーキング
---
@end table

@file{examples}ディレクトリーの例@code{hello-smalltalk}が利用できます

@node Java
@subsection Java
@cindex Java

@table @asis
@item RPM
java、java2

@item Ubuntu packages
default-jdk

@item ファイル拡張子
@code{java}

@item 文字列構文
"abc"

@item gettextの略記
_("abc")

@item gettext/ngettext関数
@code{GettextResource.gettext}、@code{GettextResource.ngettext}、@code{GettextResource.pgettext}、@code{GettextResource.npgettext}

@item textdomain
---@*
かわりに@code{ResourceBundle.getResource}を使用してください

@item bindtextdomain
---@*
かわりにCLASSPATHを使用してください

@item setlocale
自動

@item 必要条件
---

@item GNU gettextの使用またはエミュレート
---@*
Java specific message catalog formatを使用してください

@item 抽出プログラム
@code{xgettext -k_}

@item 位置の書式
@code{MessageFormat.format "@{1,number@} @{0,number@}"}

@item 可搬性
完全な可搬性がある

@item po-modeでのマーキング
---
@end table

文字列をインターナショナライズ可能とマークする前に、文字列結合演算子を使って、@code{MessageFormat}アプリケーションで変換が必要な文字列を結合してください。たとえば@code{"file
"+filename+" not found"}は、@code{MessageFormat.format("file @{0@} not found",
new Object[] @{ filename @})}となります。これを行った後のみ、文字列をマークして抽出することが可能になります。

GNU gettextはJava
本来がもつ、@code{ResourceBundle}という名前のインターナショナリゼーションのメカニズムを使います。@code{ResourceBundle}には、@code{.properties}と@code{.class}という、2つのファイル
フォーマットがあります。@code{.properties}ファイルは、POファイルのように翻訳者が直接編集できるテキスト形式ですが、plural
formをサポートしません。@code{.class}は、@code{.java}のソースコードからコンパイルされた形式で、plural
formをサポートします(適切なAPIを通じてのアクセスが提供されています。以下を参照してください)。

POファイルを@code{.properties}ファイルに変換するためには、@code{msgcat}プログラムの
@code{--properties-output}オプションを使うことができます。逆に@code{.properties}ファイルをPOファイルに変換するには、@code{msgcat}プログラムの@code{--properties-input}オプションを使うことができます。POファイルを扱うすべてのツールは、@code{--properties-input}および/または@code{--properties-output}オプションにより、@code{.properties}も同様に取り扱うことができます。

POファイルをResourceBundle
classに変換するためには、@code{msgfmt}プログラムの、@code{--java}(または@code{--java2})オプションを使うことができます。逆にResourceBundleをPOファイルに変換するためには、@code{msgunfmt}の@code{--java}オプションを使うことができます。

プログラムからResourceBundleにアクセスするために、異なる2つのAPIを使うことができます。これら2つのAPIは、ResourceBundleがGNU
gettextにより生成されたものであるか、それともこれ以外の@code{.class}や@code{.properties}ファイルであるかによらず、すべての種類のResourceBundleを扱えることに注意してください。

@enumerate
@item
@code{java.util.ResourceBundle} API

特徴は、これの@code{getString}関数が、翻訳された文字列を戻すことです。翻訳がない場合には、@code{MissingResourceException}が発生することに注意してください。

これは、標準のAPIに採用されるためには有利な特徴といえます。さらに、このAPIは追加のライブラリーを必要とせず、@code{msgcat}によって生成された@code{.properties}ファイルか、@code{msgfmt}によって生成された@code{.class}ファイルだけが必要です。しかし、このAPIはpluralを処理できず、それはpluralを処理するPOファイルから@code{msgfmt}で生成されたリソースの場合も同様です。

@item
@code{gnu.gettext.GettextResource} API

@uref{javadoc2/index.html,javadoc2 directory}に、Javadoc 1.1 style
formatのReference documentation があります。

このAPIの@code{gettext}関数は、翻訳された文字列を戻します。翻訳がない場合には、@var{msgid}が変更されずに戻されることに注意してください。

このAPIの有利な点は、pluralを処理する@code{ngettext}関数があること、そして特定のcontextにたいする制約をもつ文字列を処理する@code{pgettext}と@code{npgettext}のある点です。

@cindex @code{libintl} for Java
このAPIを使うために必要なのは、GNU
gettextパッケージの一部である@code{libintl.jar}だけで、これはLGPLのもとで配布されています。
@end enumerate

2番目のAPIを使うための例としては、@file{examples}ディレクトリーの、@code{hello-java}、@code{hello-java-awt}、@code{hello-java-swing}、@code{hello-java-qtjambi}が利用できます。

ではAPIの使い方と、@samp{getString}の略記をしてみましょう。以下の3つの用法から選択することができましょう:

@itemize @bullet
@item
(Java
1.5以降の場合)あなたのプロジェクトに@samp{Util}という一意なクラスがあるとき、@code{ResourceBundle}のインスタンスを保持するstaticな変数を定義する場合、以下のような略記を定義します:

@smallexample
private static ResourceBundle myResources =
  ResourceBundle.getBundle("domain-name");
public static String _(String s) @{
  return myResources.getString(s);
@}
@end smallexample

そして、インターナショナライズする文字列を含むすべてのクラスに、以下の宣言を含めます

@smallexample
import static Util._;
@end smallexample

@noindent
これで以下のようにして略記を使うことができます:

@smallexample
System.out.println(_("Operation completed."));
@end smallexample

@item
あなたのプロジェクトに@samp{Util}という一意なクラスがあるとき、@code{ResourceBundle}のインスタンスを保持するstaticな変数を定義する場合、以下のような略記を定義します:

@smallexample
public static ResourceBundle myResources =
  ResourceBundle.getBundle("domain-name");
@end smallexample

そして、インターナショナライズする文字列を含むすべてのクラスに、以下の宣言を含めます

@smallexample
private static ResourceBundle res = Util.myResources;
private static String _(String s) @{ return res.getString(s); @}
@end smallexample

@noindent
これで以下のようにして略記を使うことができます:

@smallexample
System.out.println(_("Operation completed."));
@end smallexample

@item
resource bundleの定義だけを含む、とても短い名前の@samp{S}というクラスを追加して、以下のような略記を定義します:

@smallexample
public class S @{
  public static ResourceBundle myResources =
    ResourceBundle.getBundle("domain-name");
  public static String _(String s) @{
    return myResources.getString(s);
  @}
@}
@end smallexample

@noindent
これで以下のようにして略記を使うことができます:

@smallexample
System.out.println(S._("Operation completed."));
@end smallexample
@end itemize

3つの用法のどれを選ぶかは、あなたのプロジェクトがJava
1.5より前のバージョンにたいする互換性を必要とするかに依存します。もしその必要がある場合には、プロジェクトのすべてのクラスに1文字のクラスを追加するより、すべてのクラスに2行追加するほうがよいでしょう。

@node C#
@subsection C#
@cindex C#

@table @asis
@item RPM
mono

@item Ubuntu packages
mono-mcs

@item ファイル拡張子
@code{cs}

@item 文字列構文
@code{"abc"}, @code{@@"abc"}

@item gettextの略記
_("abc")

@item gettext/ngettext関数
@code{GettextResourceManager.GetString},
@code{GettextResourceManager.GetPluralString}
@code{GettextResourceManager.GetParticularString}
@code{GettextResourceManager.GetParticularPluralString}

@item textdomain
@code{new GettextResourceManager(domain)}

@item bindtextdomain
---@*
実行可能ファイルを含むディレクトリーのサブディレクトリーにコンパイルされたmessage catalogが配置されます

@item setlocale
自動

@item 必要条件
---

@item GNU gettextの使用またはエミュレート
---@*
C# specific message catalog formatを使用してください

@item 抽出プログラム
@code{xgettext -k_}

@item 位置の書式
@code{String.Format "@{1@} @{0@}"}

@item 可搬性
完全な可搬性がある

@item po-modeでのマーキング
---
@end table

文字列をインターナショナライズ可能とマークする前に、文字列結合演算子を使って、@code{String.Format}呼び出しで変換が必要な文字列を結合してください。たとえば@code{"file
"+filename+" not found"}は、@code{String.Format("file @{0@} not found",
filename)}となります。これを行った後のみ、文字列をマークして抽出することが可能になります。

GNU
gettextは、@code{ResourceManager}および@code{ResourceSet}という名前の、C#/.NET本来のインターナショナリゼーション
メカニズムを使います。アプリケーションは@code{ResourceManager}のメソッドを使って、母国語に翻訳された文字列を取得します。メッセージカタログファイルをインメモリーに展開したものが、@code{ResourceSet}のインスタンスです。@code{ResourceManager}は、翻訳を検索する必要が生じると、@code{ResourceSet}のインスタンスをロード・アクセスします。

C#のランタイムが直接ロードできる@code{ResourceSet}には、@code{.resources}ファイル、および@code{.dll}ファイルという、2つの形式があります:

@itemize @bullet
@item
@code{.resources}の形式はバイナリーのファイルで、通常は@code{resgen}または@code{monoresgen}ユーティリティーにより生成され、この形式はplural
formをサポートしません。@code{.resources}は、.NETの@code{.exe}ファイルに埋め込むこともできます。これは、メッセージカタログをロードするためにファイルシステムにアクセスするかどうかに影響を及ぼすだけで、メッセージカタログの内容には影響しません。

@item
一方@code{.dll}の形式は、ソースコードの@code{.cs}からコンパイルされたバイナリーファイルで、plural
formをサポートします(これは以下で記述するように、GNU gettext APIを通じてアクセスすることにより提供されます)。
@end itemize

これら
.NETの@code{.dll}や@code{.exe}ファイルは、特定のプラットフォームに限定されたものではないことに注意してください。これらのファイル形式、およびC#のためのGNU
gettextは、任意のプラットフォームで使用できます。

@code{msgfmt}プログラムに@samp{--csharp-resources}オプションを指定することにより、POファイルを@code{.resources}ファイルに変換できます。また、@code{msgunfmt}プログラムに@samp{--csharp-resources}オプションを指定することにより、@code{.resources}ファイルからPOファイルに逆変換できます。これらの処理は、@code{monoresgen}プログラム(@code{mono}/@code{mcs}パッケージ)でできる場合もあります。これらのプログラムは、@code{.resources}ファイルからPOファイルへの逆変換もできます。しかし、この文書を記述している時点(2004年1月)では、@code{monoresgen}コンバーターにはバグが多く含まれます。

@code{msgfmt}プログラムに@code{--csharp}オプションを指定することにより、POファイルを@code{.dll}ファイルに変換できます。@code{GettextResourceSet}(このクラスも@code{ResourceSet}のサブクラスです)のサブクラスを含んだ、@code{.dll}ファイルを得ることができます。また、@code{msgunfmt}プログラムに@code{--csharp}オプションを指定することにより、サブクラス@code{GettextResourceSet}を含む@code{.dll}ファイルをPOファイルに逆変換できます。

@code{.resources}形式に比べて、@code{.dll}形式には、以下のような利点があります:

@enumerate
@item
@c If this were the only issue with the @code{.resources} format, one could
@c use the @code{ResourceManager.CreateFileBasedResourceManager} function.
自由なローカライズ:
アプリケーションをビルド・配布した後でも、ユーザーは自分の翻訳を自由に追加できます。一方、システムにより提供される@code{ResourceManager}のコンストラクターをプログラマーが使った場合、アプリケーション用の一連の@code{.resources}ファイルは、アプリケーションのビルド時に指定しなければならず、後から拡張はできません。

@item
Plural の処理:
@code{.dll}形式のメッセージカタログは、pluralを処理するための関数@code{GetPluralString}をサポートします。一方、@code{.resources}ファイルは、含まれているデータと、単一の文字列にもとづく検索だけをサポートします。

@item
Context の処理:
@code{.dll}形式のメッセージカタログは、contextにもとづく問い合わせをおこなうための関数@code{GetParticularString}および@code{GetParticularPluralString}をサポートします。一方、@code{.resources}ファイルは、含まれているデータと、単一の文字列にもとづく検索だけをサポートします。

@item
@code{GettextResourceManager}は、@code{.dll}形式の中のメッセージカタログのロードと、メッセージ単位でのロードも提供します。たとえばAustrian(@code{de_AT})のlocaleでは、メッセージがAustrianのメッセージカタログにないときに、German(@code{de})のメッセージカタログが使用されます。つまり、Austrianの翻訳者は、Germanの翻訳とは異なるいくつかのメッセージだけを、Austrianに翻訳する必要があるということです。一方、@code{.resources}ファイルでは、各メッセージカタログは、それ自身に含まれるすべてのメッセージの翻訳を提供しなければなりません。

@item
@code{GettextResourceManager}は、翻訳が見つからないときはEnglishの@var{msgid}を戻すというフォールバック付きで、@code{.dll}形式のメッセージカタログをロードします。一方、@code{.resources}ファイルでは、その@code{.resources}が言語中立な場合、フォールバックを明示的に提供しなければなりません。
@end enumerate

プログラム用のAPIという面では、プログラマーは標準の@code{ResourceManager} APIと、GNU
@code{GettextResourceManager} API
のどちらを使うこともできます。前者の@code{ResourceManager}のサブクラスが、後者の@code{GettextResourceManager}なので、後者の方が拡張されています。

@enumerate
@item
@code{System.Resources.ResourceManager} API

このAPIは、@code{.resources}形式のリソースにたいして動作します。

@code{ResourceManager}を生成するには、以下のようにします
@smallexample
  new ResourceManager(domainname, Assembly.GetExecutingAssembly())
@end smallexample
@noindent

@code{GetString}関数は、文字列にたいする翻訳を戻します。翻訳がない場合はnullが戻されることに注意してください(例:
これはフォールバックのリソースファイルの場合にも適用されます)。

@item
@code{GNU.Gettext.GettextResourceManager} API

このAPIは、@code{.dll}形式のリソースにたいして動作します。

Reference documentationは、@uref{csharpdoc/index.html,csharpdoc
directory}にあります。

@code{ResourceManager}を生成するには、以下のようにします
@smallexample
  new GettextResourceManager(domainname)
@end smallexample

このAPIの@code{GetString}関数は、翻訳された文字列を戻します。翻訳がない場合には、@var{msgid}が変更されずに戻されることに注意してください。

@code{GetPluralString}関数は、Cの@code{ngettext}関数のように、文字列にたいしてplural処理をした翻訳を戻します。

@code{GetParticularString}関数は、Cの@code{pgettext}関数のように、特定のcontextが指定された文字列の翻訳を戻します。翻訳がない場合には、@var{msgid}が変更されずに戻されることに注意してください。

@code{GetParticularPluralString}関数は、Cの@code{npgettext}関数のように、特定のcontextが指定された文字列にたいして、plural処理をした翻訳を戻します。

@cindex @code{libintl} for C#
このAPIを使うために必要なのは、GNU
gettextパッケージの一部である@code{GNU.Gettext.dll}だけで、これはLGPLのもとで配布されています。
@end enumerate

2つのアプローチをミックスすることもできます:
たとえば@code{GNU.Gettext.GettextResourceManager}コンストラクターは使うが、@code{ResourceManager}型と@code{GetString}メソッドだけを使うような場合です。これはPOファイル用のツールに適合させたいが、@code{ResourceManager}を使う既存のソースコードを変更したくなくて、(まだ)@code{GetPluralString}メソッドが必要ないときには適しているでしょう。

2番目のAPIを使うためには、@file{examples}ディレクトリーの@code{hello-csharp}、@code{hello-csharp-forms}の2つの例が利用できます。

ではAPIの使い方と、@samp{GetString}の略記をしてみましょう。以下の3つの用法から選択することができましょう:

@itemize @bullet
@item
あなたのプロジェクトに@samp{Util}という一意なクラスがあるとき、@code{ResourceManager}のインスタンスを保持するstaticな変数を定義する場合は、以下のような略記を定義します:

@smallexample
public static GettextResourceManager MyResourceManager =
  new GettextResourceManager("domain-name");
@end smallexample

そして、インターナショナライズする文字列を含むすべてのクラスに、以下の宣言を含めます

@smallexample
private static GettextResourceManager Res = Util.MyResourceManager;
private static String _(String s) @{ return Res.GetString(s); @}
@end smallexample

@noindent
これで以下のようにして略記を使うことができます:

@smallexample
Console.WriteLine(_("Operation completed."));
@end smallexample

@item
resource managerの定義だけを含む、とても短い名前の@samp{S}というクラスを追加して、以下のような略記を定義します:

@smallexample
public class S @{
  public static GettextResourceManager MyResourceManager =
    new GettextResourceManager("domain-name");
  public static String _(String s) @{
     return MyResourceManager.GetString(s);
  @}
@}
@end smallexample

@noindent
これで以下のようにして略記を使うことができます:

@smallexample
Console.WriteLine(S._("Operation completed."));
@end smallexample
@end itemize

2つの用法のどちらを選ぶかは、すべてのクラスに上記の2行をコピーするのがよいか、それともすべてのクラスに1文字のクラスを追加するのがよいかによります。

@node gawk
@subsection GNU awk
@cindex awk
@cindex gawk

@table @asis
@item RPM
gawk 3.1以降

@item Ubuntu packages
gawk

@item ファイル拡張子
@code{awk}、@code{gawk}、@code{twjr}。ファイル拡張子@code{twjr}は、TexiWeb
Jr(@uref{https://github.com/arnoldrobbins/texiwebjr})で使用されます。

@item 文字列構文
@code{"abc"}

@item gettextの略記
@code{_"abc"}

@item gettext/ngettext関数
@code{dcgettext}、gawk-3.1.0に@code{dcngettext}はありません

@item textdomain
@code{TEXTDOMAIN}変数

@item bindtextdomain
@code{bindtextdomain}関数

@item setlocale
自動、ただしgawk-3.1.0には@code{setlocale (LC_MESSAGES, "")}はありません

@item 必要条件
---

@item GNU gettextの使用またはエミュレート
使用

@item 抽出プログラム
@code{xgettext}

@item 位置の書式
@code{printf "%2$d %1$d"}(GNU awkのみ)

@item 可搬性
gettextのないプラットフォームでは翻訳されません。非GNUのawkでは、@code{dcgettext}、@code{dcngettext}、@code{bindtextdomain}を自分で定義しなければなりません。

@item po-modeでのマーキング
---
@end table

@file{examples}ディレクトリーの、例@code{hello-gawk}が利用できます

@node Pascal
@subsection Pascal - フリーPascalコンパイラー
@cindex Pascal
@cindex Free Pascal
@cindex Object Pascal

@table @asis
@item RPM
fpk

@item Ubuntu packages
fp-compiler、fp-units-fcl

@item ファイル拡張子
@code{pp}、@code{pas}

@item 文字列構文
@code{'abc'}

@item gettextの略記
自動

@item gettext/ngettext関数
---@*
かわりにデータ型@code{ResourceString}を使用してください

@item textdomain
---@*,
かわりに関数@code{TranslateResourceStrings}を使用してください

@item bindtextdomain
---@*,
かわりに関数@code{TranslateResourceStrings}を使用してください

@item setlocale
自動、ただし使うのはLANGだけで、LC_MESSAGESやLC_ALL は使いません

@item 必要条件
@code{@{$mode delphi@}}、または@code{@{$mode objfpc@}}@*
@code{uses gettext;}

@item GNU gettextの使用またはエミュレート
エミュレート(部分的)

@item 抽出プログラム
@code{xgettext}(または@code{rstconv})サポートのある@code{ppc386}

@item 位置の書式
@code{uses sysutils;}@*
@code{format "%1:d %0:d"}

@item 可搬性
?

@item po-modeでのマーキング
---
@end table

Pascalコンパイラーには、@code{ResourceString}データ型にたいする特別なサポートがあります。これは@code{.rst}ファイルを生成します。このファイルは、@code{xgettext}または@code{rstconv}を使用することにより、@code{.pot}ファイルに変換されます。実行時には、@code{gettext}ユニット内の@code{TranslateResourceStrings}関数を使用して、この@code{.pot}ファイルの翻訳に対応する@code{.mo}ファイルをロードできます。

@file{examples}ディレクトリーの、例@code{hello-pascal}が利用できます。

@node wxWidgets
@subsection wxWidgetsライブラリー
@cindex @code{wxWidgets} library

@table @asis
@item RPM
wxGTK、gettext

@item Ubuntu packages
libwxgtk3.0-dev

@item ファイル拡張子
@code{cpp}

@item 文字列構文
@code{"abc"}

@item gettextの略記
@code{_("abc")}

@item gettext/ngettext関数
@code{wxLocale::GetString}、@code{wxGetTranslation}

@item textdomain
@code{wxLocale::AddCatalog}

@item bindtextdomain
@code{wxLocale::AddCatalogLookupPathPrefix}

@item setlocale
@code{wxLocale::Init}、@code{wxSetLocale}

@item 必要条件
@code{#include <wx/intl.h>}

@item GNU gettextの使用またはエミュレート
エミュレート、@code{include/wx/intl.h}と@code{src/common/intl.cpp}を参照してください。

@item 抽出プログラム
@code{xgettext}

@item 位置の書式
wxString::Formatはシステムに@code{wprintf()}と@code{vswprintf()}関数があり、それらがPOSIX準拠の位置指定をサポートする場合のみ、位置指定をサポートします。

@item 可搬性
完全な可搬性がある

@item po-modeでのマーキング
yes
@end table

@node YCP
@subsection YCP - YaST2スクリプト言語
@cindex YCP
@cindex YaST2 scripting language

@table @asis
@item RPM
libycp、libycp-devel、yast2-core、yast2-core-devel

@item Ubuntu packages
---

@item ファイル拡張子
@code{ycp}

@item 文字列構文
@code{"abc"}

@item gettextの略記
@code{_("abc")}

@item gettext/ngettext関数
引数を１つ、または3つの@code{_()}

@item textdomain
@code{textdomain}命令

@item bindtextdomain
---

@item setlocale
---

@item 必要条件
---

@item GNU gettextの使用またはエミュレート
使用

@item 抽出プログラム
@code{xgettext}

@item 位置の書式
@code{sformat "%2 %1"}

@item 可搬性
完全な可搬性がある

@item po-modeでのマーキング
---
@end table

@file{examples}ディレクトリーの、例@code{hello-ycp}が利用できます

@node Tcl
@subsection Tcl - Tkのスクリプト言語
@cindex Tcl
@cindex Tk's scripting language

@table @asis
@item RPM
tcl

@item Ubuntu packages
tcl

@item ファイル拡張子
@code{tcl}

@item 文字列構文
@code{"abc"}

@item gettextの略記
@code{[_ "abc"]}

@item gettext/ngettext関数
@code{::msgcat::mc}

@item textdomain
---

@item bindtextdomain
---@*
かわりに@code{::msgcat::mcload}を使用してください

@item setlocale
自動、LANGは使いますが、LC_MESSAGESとLC_ALL は無視されます

@item 必要条件
@code{package require msgcat} @*
@code{proc _ @{s@} @{return [::msgcat::mc $s]@}}

@item GNU gettextの使用またはエミュレート
---
Tcl specific message catalog formatを使用してください

@item 抽出プログラム
@code{xgettext -k_}

@item 位置の書式
@code{format "%2\$d %1\$d"}

@item 可搬性
完全な可搬性がある

@item po-modeでのマーキング
---
@end table

@file{examples}ディレクトリーの2つの例@code{hello-tcl}と@code{hello-tcl-tk}が利用できます

文字列をインターナショナライズ可能とマークする前に、代用の変数を@code{format}アプリケーションで変換する必要がある文字列にします(例:
@code{"file $filename not found"}は@code{[format "file %s not found"
$filename]})。これを行った後のみ、文字列をマークして抽出できます。上記の例では、マークした後は@code{[format [_ "file
%s not found"] $filename]}(または@code{[msgcat::mc "file %s not found"
$filename]})となります。msgcat::mc
関数は、2つ以上の引数が与えられたときは、暗黙的に@code{format}を呼び出すことに注意してください。

@node Perl
@subsection Perl
@cindex Perl

@table @asis
@item RPM
perl

@item Ubuntu packages
perl、libintl-perl

@item ファイル拡張子
@code{pl}、@code{PL}、@code{pm}、@code{perl}、@code{cgi}

@item 文字列構文
@itemize @bullet

@item @code{"abc"}

@item @code{'abc'}

@item @code{qq (abc)}

@item @code{q (abc)}

@item @code{qr /abc/}

@item @code{qx (/bin/date)}

@item @code{/pattern match/}

@item @code{?pattern match?}

@item @code{s/substitution/operators/}

@item @code{$tied_hash@{"message"@}}

@item @code{$tied_hash_reference->@{"message"@}}

@item その他(この問題は@samp{man perlsyn}コマンドで詳細に論じられています)

@end itemize

@item gettextの略記
@code{__}(2連のアンダースコアー)

@item gettext/ngettext関数
@code{gettext}、@code{dgettext}、@code{dcgettext}、@code{ngettext}、@code{dngettext}、@code{dcngettext}、@code{pgettext}、@code{dpgettext}、@code{dcpgettext}、@code{npgettext}、@code{dnpgettext}、@code{dcnpgettext}

@item textdomain
@code{textdomain}関数

@item bindtextdomain
@code{bindtextdomain}関数

@item bind_textdomain_codeset
@code{bind_textdomain_codeset}関数

@item setlocale
Use @code{setlocale (LC_ALL, "");}

@item 必要条件
@code{use POSIX;} @*
@code{use
Locale::TextDomain;}(libintl-perlパッケージに含まれています。これはCPAN(Comprehensive Perl
Archive Network) https://www.cpan.org/)で入手できます。

@item GNU gettextの使用またはエミュレート
プラットフォームに依存: gettext_ppはエミュレート、gettext_xsはGNU gettextを使っています

@item 抽出プログラム
@code{xgettext -k__ -k\$__ -k%__ -k__x -k__n:1,2 -k__nx:1,2 -k__xn:1,2 -kN__
-kN__n:1,2 -k__p:1c,2 -k__np:1c,2,3 -kN__p:1c,2 -kN__np:1c,2,3}

@item 位置の書式
どちらの種類の位置指定付き書式もサポートしています@*
@code{printf "%2\$d %1\$d", ...}(Perl 5.8.0以降)@*
@code{__expand("[new] replaces [old]", old => $oldvalue, new => $newvalue)}

@item 可搬性
@code{libintl-perl}パッケージはプラットフォームに依存しませんが、Perlの中核となるものの一部です。ターゲットとなるシステムにパッケージがインストールされていない場合、必要な関数のダミーの実装を提供するのは、プログラマーの責任です。

@item po-modeでのマーキング
---

@item ドキュメント
@code{libintl-perl}に含まれています。これはCPAN(https://www.cpan.org/)で利用できます

@end table

@file{examples}ディレクトリーの、例@code{hello-perl}が利用できます

@cindex marking Perl sources

Perl用の@code{xgettext}パーサーのバックエンドと、他のプログラム言語用のパーサーのバックエンドには、重大な違いがあります。これはPerl自体に、他の言語との間に重大な違いがあるからです。Perl用のパーサーのバックエンドは、文字列をマークするための機能を、他のバックエンドより多く提供しますが、これにはPerl固有の制限がいくつかあり、その中でもっとも問題となるのは言語の不完全性によるものでしょう。

@menu
* General Problems::         General Problems Parsing Perl Code
* Default Keywords::         Which Keywords Will xgettext Look For?
* Special Keywords::         How to Extract Hash Keys
* Quote-like Expressions::   What are Strings And Quote-like Expressions?
* Interpolation I::          Invalid String Interpolation
* Interpolation II::         Valid String Interpolation
* Parentheses::              When To Use Parentheses
* Long Lines::               How To Grok with Long Lines
* Perl Pitfalls::            Bugs, Pitfalls, and Things That Do Not Work
@end menu

@node General Problems
@subsubsection Perlコードをパースするときの一般的な問題

PerlだけがPerlをパースできるということを、しばしば耳にしますが、これは真実ではありません。結局Perlを@emph{パース}することはできず、@emph{実行}することができるだけなのです。Perlにはビルトインでさまざまなあいまいさがあり、それを解決できるのは実行時だけなのです。

以下は一般的な例を示した例です:

@example
print gettext "Hello World!";
@end example

これは関数呼び出しの"堅実"な例に見えるかもしれませんが、そうでもありません:

@example
open gettext, ">testfile" or die;
print gettext "Hello world!"
@end example

上記のコンテキストでは、文字列@code{gettext}はファイルハンドルのように見えます。しかし必ずしもそうではありません:

@example
use Locale::Messages qw (:libintl_h);
open gettext ">testfile" or die;
print gettext "Hello world!";
@end example

この例では、Perlのインクルードパスで最初に見つかる@code{Locale::Messages}モジュールがエクスポートする@code{gettext}関数により提供されるファイル名は、多分文法エラーになるでしょう。しかし実際の@code{Locale::Messages}モジュールが以下のようなものだったらどうなるでしょうか?

@example
use vars qw (*gettext);

1;
@end example

このケースでは、文字列@code{gettext}は再びファイルハンドルとして解釈されるので、@file{testfile}というファイルを作成して、そのファイルに``Hello
world!''という文字列を書き込む例になります。より高度なフロー分析による制御も、助けにはなりません:

@example
if (0.5 < rand) @{
   eval "use Sane";
@} else @{
   eval "use InSane";
@}
print gettext "Hello world!";
@end example

わたしたちが期待するような@code{gettext}関数をエクスポートするモジュールが@code{Sane}で、@code{gettext}という@emph{ハンドル}の出力ストリームを書き込み用にオープンするのが@code{InSane}というモジュールの場合、わたしたちには実行時に何が起こるのか知る糸口がなく、完全に予測不能です。本当のところPerlには、実行時にそれ自身のシンボルテーブルにシンボルを追加するために非常に多くの方法があり、実行することなく特定のコードの断片を解釈するのは不可能なのです。

もちろん@code{xgettext}は翻訳可能な文字列を走査するときに、走査するPerlのソースを実行するわけではなく、コードを記述した人が何を意図したのかを推測するために発見的な手法を用います。

他にもスラッシュとクエスチョンマークの曖昧さという問題があります。これらの解釈はコンテキストに依存します:

@example
# A pattern match.
print "OK\n" if /foobar/;

# A division.
print 1 / 2;

# Another pattern match.
print "OK\n" if ?foobar?;

# Conditional.
print $x ? "foo" : "bar";
@end example

スラッシュは除算のための演算子と、パターンマッチをあらわすための両方の用途で使用されます。一方、クエスチョン
マークは3項演算の条件判定と、パターンマッチでも使用されます。他の@code{awk}のようなプログラム言語にも同様な問題はありますが、このようにソースを誤って解釈してしまう問題はPerlのソースの場合が特に顕著なのです。たとえば@code{awk}では、命令文は決して1行を超えないので、パーサーはパースエラーから復帰して、次の行から残りの入力ストリームを正しく処理できます。これと異なりPerlは、コンテキストの意味とは無関係に、入力ストリームに次の区切り文字(スラッシュまたはクエスチョンマーク)が出現することでパターンマッチが終端されます。本来は除算演算子として使用されているスラッシュがパターンマッチと誤って解釈された場合、おそらく残りの入力ファイルは正常にパースされないでしょう。

以下に、あいまいさの解決が不可能なケースを示します:

@example
$x = wantarray ? 1 : 0;
@end example

Perlのビルトイン関数である@code{wantarray}は引数をとらないので、Perlのパーサーはクエスチョンマークが正規表現の開始ではなく、3項演算子だと知ることができます。

@example
sub wantarrays @{@}
$x = wantarrays ? 1 : 0;
@end example

今度は状況が異なります。関数@code{wantarrays}は、可変個の引数をとります(他のプロトタイプがない任意のPerl関数と同様です)。この場合、クエスチョンマークはパターンマッチの区切り文字として解釈されるので、このコードの断片はコンパイルされません。

@example
sub wantarrays() @{@}
$x = wantarrays ? 1 : 0;
@end example

さて今度は関数がプロトタイプされているので、Perlは関数が引数をとらないことを知っているので、クエスチョンマークは再び3項演算子として解釈されます。しかし残念ながら@code{xgettext}はそうではありません。

@code{xgettext}のPerl用パーサーは、関数にプロトタイプがあるのか、そしてそのプロトタイプがどのように見えるのか知ることができないので、経験的に推測することになります。ある関数がPerlのビルトイン関数で、この関数が引数を受け付けない場合は、それに続くクエスチョンマーク(またはスラッシュ)は演算子として扱われ、それ以外の場合は以降に続く正規表現のための区切り文字として扱われます。Perlのビルトイン関数で引数をとらないのは@code{wantarray}、@code{fork}、@code{time}、@code{times}、@code{getlogin}、@code{getppid}、@code{getpwent}、@code{getgrent}、@code{gethostent}、@code{getnetent}、@code{getprotoent}、@code{getservent}、@code{setpwent}、@code{setgrent}、@code{endpwent}、@code{endgrent}、@code{endhostent}、@code{endnetent}、@code{endprotoent}、@code{endservent}です。

もし@code{xgettext}が、あなたのソースから文字列を抽出するのに失敗する場合には、このセクションで説明したようなスラッシュ(またはクエスチョンマーク)を探してみる必要があります。もしかしたら@code{xgettext}のPerlパーサーの、他のバグである可能性もあります(もちろんそのようなバグは報告する必要があるでしょう)。そのうちに、あなたは@code{xgettext}に
"挑戦"するより、マナーにのっとってコードを整形する必要があると思うでしょう。

特に、引数をとらない関数をパーサーが認識できないときは、カッコを使ってください:

@example
$x = somefunc() ? 1 : 0;
$y = (somefunc) ? 1 : 0;
@end example

実際のところはPerlのパーサーも、このような状況にたいする問題をもっていて、警告を発します。

@node Default Keywords
@subsubsection xgettextが探すキーワードはどれ?
@cindex Perl default keywords

@code{xgettext}に@code{--keyword}(または@code{-k})オプションを指定しない場合は、Perlソース中の以下のキーワードを認識します:

@itemize @bullet

@item @code{gettext}

@item @code{dgettext:2}

2番目の引数が抽出されます。

@item @code{dcgettext:2}

2番目の引数が抽出されます。

@item @code{ngettext:1,2}

1番目(singular)と2番目(plural)の引数が抽出されます。

@item @code{dngettext:2,3}

2番目(singular)と3番目(plural)の引数が抽出されます。

@item @code{dcngettext:2,3}

2番目(singular)と3番目(plural)の引数が抽出されます。

@item @code{pgettext:1c,2}

1番目(message context)と2番目の引数が抽出されます。

@item @code{dpgettext:2c,3}

2番目(message context)と3番目の引数が抽出されます。

@item @code{dcpgettext:2c,3}

2番目(message context)と3番目の引数が抽出されます。

@item @code{npgettext:1c,2,3}

1番目(message context)、2番目(singular)、および3番目の引数が抽出されます。

@item @code{dnpgettext:2c,3,4}

2番目(message context)、3番目(singular)、および4番目(plural)の引数が抽出されます。

@item @code{dcnpgettext:2c,3,4}

2番目(message context)、3番目(singular)、および4番目(plural)の引数が抽出されます。

@item @code{gettext_noop}

@item @code{%gettext}

ハッシュ@code{%gettext}の中のハッシュ キーが抽出されます。

@item @code{$gettext}

ハッシュ リファレンス@code{$gettext}の指すハッシュの中のハッシュ キーが抽出されます。

@end itemize

@node Special Keywords
@subsubsection ハッシュキーを抽出する方法
@cindex Perl special keywords for hash-lookups

通常の実行時のメッセージ翻訳は、翻訳が格納されたデータベースから元の文字列を検索して、、翻訳された文字列を戻します。これをPerlで実装する``自然な''方法は、ハッシュのルックアップで、もちろん@code{xgettext}もこのような実装をサポートしています。

@example
print __"Hello world!";
print $__@{"Hello world!"@};
print $__->@{"Hello world!"@};
print $$__@{"Hello world!"@};
@end example

上の4つの行は、すべて同じことを行います。Perlの@code{Locale::TextDomain}モジュールは、関数@code{__()}にtiedされたハッシュ@code{%__}をデフォルトでエクスポートします。また、このモジュールは@code{%__}にたいするリファレンス@code{$__}もエクスポートします。

@code{xgettext}に@code{--keyword}(または@code{-k})オプションを指定したときに、その引数の1文字目がパーセント記号(%)の場合、残りの部分のキーワードはハッシュの名前として解釈されます。引数の1文字目がダラー記号($)の場合、残りの部分のキーワードはハッシュにたいするリファレンスとして解釈されます。

Perlのコードとして許容できるなら(大抵の場合は問題ないはずです)、ハッシュキーを囲むシングルクォーテーション(またはダブルクォーテーション)は省略できることに注意してください:

@example
print $gettext@{Error@};
@end example

ルールを正確にいうと: ハッシュキーが有効なCの識別子(!)の場合(例:
識別子の1文字目がアンダースコアーまたはASCII文字で、その後ろに任意の個数のアンダースコアー、または半角英数が続くような識別子)、その識別子を囲むクォート記号を省略できます。その他のUnicode文字は、@code{use
utf8} pragmaを使っていない限り、認められません。

@node Quote-like Expressions
@subsubsection 何が文字列で、何がクォート風の式なのか?
@cindex Perl quote-like expressions

Perlは文字列の構成方法として、過剰ともいえるほどの異なる方法を提供しています。関数の引数や、ハッシュをルックアップするカッコのなかで使用できるこれらの文字列は、@code{xgettext}でも概ねサポートされています。  

@itemize @bullet
@item @strong{double-quoted strings}
@*
@example
print gettext "Hello World!";
@end example

@item @strong{single-quoted strings}
@*
@example
print gettext 'Hello World!';
@end example

@item @strong{演算子qq}
@*
@example
print gettext qq |Hello World!|;
print gettext qq <E-mail: <guido\@@imperia.net>>;
@end example

@code{qq}演算子は完全にサポートされています。演算子のための区切り文字には、4種類のカッコ(round、angle、square、curly)を入れ子にして使うことも含めて、任意の区切り文字を使用できます。

@item @strong{演算子q}
@*
@example
print gettext q |Hello World!|;
print gettext q <E-mail: <guido@@imperia.net>>;
@end example

@code{q}演算子は完全にサポートされています。演算子のための区切り文字には、4種類のカッコ(round、angle、square、curly)を入れ子にして使うことも含めて、任意の区切り文字を使用できます。

@item @strong{演算子qx}
@*
@example
print gettext qx ;LANGUAGE=C /bin/date;
print gettext qx [/usr/bin/ls | grep '^[A-Z]*'];
@end example

@code{qx}演算子は完全にサポートされています。演算子のための区切り文字には、4種類の括弧(round、angle、square、curly)
を入れ子にして使うことも含めて、任意の区切り文字を使用できます。

この例の場合、演算子内部の文字列にたいして@code{gettext}は使われません。これは@code{qx}演算子の中に指定したコマンドの出力を使って、@code{gettext}を呼び出します。これはインターフェースを統一するために提供されている機能です(パーサーはすべての文字列と引用符類を抽出します)。

@item @strong{ヒアドキュメント}
@*
@example
@group
print gettext <<'EOF';
program not found in $PATH
EOF

print ngettext <<EOF, <<"EOF";
one file deleted
EOF
several files deleted
EOF
@end group
@end example

ヒアドキュメントは認識されます。ヒアドキュメントを終端する区切り文字列がシングルクォーテーションでくくられていた場合、文字列中の変数は展開されません。区切り文字列がダブルクォーテーションでくくられている場合、または区切り文字でくくられていない場合には、文字列中の変数は展開されます。

数字ではじめまる区切り文字列はサポートされていません!

@end itemize

@node Interpolation I
@subsubsection 文字列内挿の無効な使い方
@cindex Perl invalid string interpolation

Perlでは、変数による文字列の補間ができます。これはローカライズされるプログラムに恩恵をもたらしますが、問題を引き起こすこともあります。

以下のような文字列の生成はエラーを発生させます:

@example
print gettext "This is the program $0!\n";
@end example

このような場合Perlは実行時に、関数@code{gettext()}の引数内の、変数@code{$0}を補間するでしょう。これにより、この引数は文字列定数ではなく文字列変数となります(@code{$0}はグローバル変数で、実行されているperlのスクリプト名が保持されています)。補間はPerlが文字列引数を@code{gettext()}に渡す前に行われるので、文字列は実行時にのみ決定可能なスクリプト名に依存することになります。その結果、実行時に翻訳を見つけるのはほとんど不可能になります(メッセージカタログで補間された文字列が偶然見つかってしまった場合を除きます)。

そのため@code{xgettext}プログラムは、抽出された文字列の中に変数を見つけると、致命的なエラーとして解析を打ちきります。これは一般的に、このような補間文字列すべてをコンパイル時に安全に処理することができないからです。あなたが自分が何をしているか完全に知っている場合には、以下のようにしてこの挙動を回避できます:

@example
my $know_what_i_am_doing = "This is program $0!\n";
print gettext $know_what_i_am_doing;
@end example

パーサーは、変数やその他の単語は認識しませんが、文字列と引用符の類だけなら認識するので、上記の文は許されます。しかし、多分あなたは元文字列をメッセージカタログに抽出するための、別の方法を見つける必要があるでしょう。

@code{--extract-all}(または@code{-a})オプションを指定して呼び出すと、変数の補間ができるようになります。理論的な根拠:
一般的にはソースをインターナショナライズ用に準備するために、このオプションを使うでしょう。

補間される文字列・補間されない文字列と、引用符類の表現についての詳細は、@samp{man
perlop}のmanpageを参照してください。以下は、(致命的なエラーとならない)安全な補間です:

@itemize @bullet

@item エスケープシーケンス@code{\t}(tab, HT, TAB)、
@code{\\n}(newline、NL)、@code{\r}(return、CR)、@code{\f}(form
feed、FF)、@code{\b}(backspace、BS)、@code{\a}(alarm、bell、BEL)、@code{\e}
(escape、ESC)

@item @code{\033}のような8進文字
@*400から777の範囲の8進シーケンスは、@code{use utf8}
pragmaが記述されているか否かにかかわらず、UTF-8表現に翻訳されることに注意してください。

@item hex chars, like @code{\x1b}

@item @code{\x@{263a@}}のような16進文字
@*このエスケープは、@code{use utf8} pragmaが記述されているか否かにかかわらず、UTF-8表現に翻訳されることに注意してください。

@item @code{\c[}(CTRL-[)のような制御文字

@item @code{\N@{LATIN CAPITAL LETTER C WITH CEDILLA@}}のような名前つきUnicode文字
@*このエスケープは、@code{use utf8} pragmaが記述されているか否かにかかわらず、UTF-8表現に翻訳されることに注意してください。
@end itemize

以下のエスケープは、部分的には安全だとみなされます:

@itemize @bullet

@item @code{\l} 次の文字を小文字にします

@item @code{\u} 次の文字を大文字にします

@item @code{\L} \E までを小文字にします

@item @code{\U} \Eまでを大文字にします

@item @code{\E} 大文字小文字変換を終端します

@item @code{\Q} \Eまでの非単語文字をクォートします

@end itemize

これらのエスケープは、文字列にASCII文字しか含まれていないときだけ、安全とみなされます。ASCIIで定義された範囲外の翻訳文字はlocale依存であり、実際には実行時しか処理できません。@code{xgettext}は、これらのlocale依存の翻訳を抽出時に処理しません。

修飾子@code{\Q}を除き、たとえこれらの翻訳が有効だとしても、一般的には無用であり、ソースがわかりにくくなるだけです。コンパイル時に翻訳が安全に処理できるなら、あなたも、意図することを同じように記述できるはずです。

@node Interpolation II
@subsubsection 文字列内挿の有効な使い方
@cindex Perl valid string interpolation

Perlは他のプログラム言語のソースや、任意のファイルフォーマットを生成するために使用されることもあります。このような使用方法の例として有名なものには、HTMLコードを出力するWebアプリケーションがあります。

以下のHTMLの例のように、翻訳可能なメッセージを含む言語(またはプログラム言語)を、散在させて記述したい状況に出会うこともあるでしょう:

@example
print gettext <<EOF;
<h1>My Homepage</h1>
<script language="JavaScript"><!--
for (i = 0; i < 100; ++i) @{
    alert ("Thank you so much for visiting my homepage!");
@}
//--></script>
EOF
@end example

parserによりヒアドキュメント全体が抽出されて、埋め込みJavaScriptの断片が含まれたHTMLコードが、抽出結果であるPOファイルに出現します。上記のような構築法の多用には、そのパッケージの翻訳者がもっと難易度の低いパッケージを探すというリスクがあります。このような場合には以下のような代替の表現を考慮する必要があるでしょう:

@example
print <<EOF;
<h1>$gettext@{"My Homepage"@}</h1>
<script language="JavaScript"><!--
for (i = 0; i < 100; ++i) @{
    alert ("$gettext@{'Thank you so much for visiting my homepage!'@}");
@}
//--></script>
EOF
@end example

この例ではコードの翻訳可能な部分だけが抽出されるので、結果となるPOファイルは、不本意ながら可読性の点においては改善されるでしょう。

すべての文字列の中のhashのルックアップ、およびquote風な表現は補間することができます(quote風というな表現は、補完という処理が抱えているテーマでもあります。詳細についてはmanpage
@samp{man perlop}を参照してください)。しかし2重の補間は無効になります:

@example
# TRANSLATORS: Replace "the earth" with the name of your planet.
print gettext qq@{Welcome to $gettext->@{"the earth"@}@};
@end example

最初の位置の@code{qq}によりクォートされた文字列が、@code{xgettext}の引数として認識されて、無効な可変補間かどうかをチェックされますそのため、hash-dereferencingの$記号は、parserによって``invalid
interpolation''エラーとなります。

以下の、正規表現の中のhash lookupの補間は有効です:

@example
if ($var =~ /$gettext@{"the earth"@}/) @{
   print gettext "Match!\n";
@}
s/$gettext@{"U. S. A."@}/$gettext@{"U. S. A."@} $gettext@{"(dial +0)"@}/g;
@end example

@node Parentheses
@subsubsection カッコを使用すべきとき
@cindex Perl parentheses

Perlでは、関数の引数を囲うカッコは、ほとんどの場合は任意です。常に@code{xgettext}は、すべての認識されたキーワード(hashおよびhash
referencesにたいするものは除く)を、適切にプロトタイプされた関数の名前とみなし、(願わくば)Perl自体がカッコを必要とする場所だけにカッコが必要です。それゆえ、以下の例の構築例はすべて使用できます:

@example
@group
print gettext ("Hello World!\n");
print gettext "Hello World!\n";
print dgettext ($package => "Hello World!\n");
print dgettext $package, "Hello World!\n";

# The "fat comma" => turns the left-hand side argument into a
# single-quoted string!
print dgettext smellovision => "Hello World!\n";

# The following assignment only works with prototyped functions.
# Otherwise, the functions will act as "greedy" list operators and
# eat up all following arguments.
my $anonymous_hash = @{
   planet => gettext "earth",
   cakes => ngettext "one cake", "several cakes", $n,
   still => $works,
@};
# The same without fat comma:
my $other_hash = @{
   'planet', gettext "earth",
   'cakes', ngettext "one cake", "several cakes", $n,
   'still', $works,
@};

# Parentheses are only significant for the first argument.
print dngettext 'package', ("one cake", "several cakes", $n), $discarded;
@end group
@end example

@node Long Lines
@subsubsection 長い行を理解するには
@cindex Perl long lines

長いメッセージを必要とすることは、しばしば厄介で読みにくいコーディングスタイルを導き出します。Perlは読みにくいコードを記述するのを防ぐいくつかのオプションをもっており、@code{xgettext}もそれにたいしてベストを尽くします。これをおこなうにはドット演算子(文字列連結演算子)が手軽でしょう:

@example
@group
print gettext ("This is a very long"
               . " message that is still"
               . " readable, because"
               . " it is split into"
               . " multiple lines.\n");
@end group
@end example

Perlは、このような文字列定数の断片を、コンパイル時に1つの長い文字列に結合できるほどにはスマートであり、それは@code{xgettext}も同様です。あなたは処理結果のPOTには1つの長いメッセージしかないことを見出すでしょう。

将来のPerl
6では、ドット(@samp{.})はdereferencing用となり、文字列の結合演算子として、おそらくアンダースコア(@samp{_})が使われることに注意してください。@code{xgettext}では、この新しい文法はまだサポートされていません。

改行を埋め込むのが問題ない(むしろ望んでいる)場合には、クォートされた文字列の内側のどこでも改行を挿入できます:

@example
@group
print gettext ("<em>In HTML output
embedded newlines are generally no
problem, since adjacent whitespace
is always rendered into a single
space character.</em>");
@end group
@end example

ヒアドキュメントの使用を考えるかもしれません:

@example
@group
print gettext <<EOF;
<em>In HTML output
embedded newlines are generally no
problem, since adjacent whitespace
is always rendered into a single
space character.</em>
EOF
@end group
@end example

行は実際に改行されることを忘れないでください(例: これらは改行文字に変換されて、POTファイル中に出現します)。

@node Perl Pitfalls
@subsubsection バグ、落とし穴、動作しない事柄
@cindex Perl pitfalls

ここまでのセクションでは、Perlのソースから翻訳可能な文字列を抽出点において、@code{xgettext}がとてもスマートであることが証明されました。しかし動作すると期待されていたエキゾチックな構成物のうちのいくつかは、多かれ少なかれ動作しません。  

それに関係する制限のうちの1つは、クォートされた文字列内の変数の補間に関する実装で見つけることができます。クォートされた文字列の場合、単純なhash
lookupしか使うことができません:

@example
print <<EOF;
$gettext@{"The dot operator"
          . " does not work"
          . "here!"@}
Likewise, you cannot @@@{[ gettext ("interpolate function calls") ]@}
inside quoted strings or quote-like expressions.
EOF
@end example

これは有効なPerlのコードであり、実行時には実際に@code{gettext}関数を呼び出します。しかし@code{xgettext}のPerl
parserは、文字列の認識に失敗します。これほど明確ではない実相の制限は、正規表現の補間で見つけることができます:

@example
s/<!--START_OF_WEEK-->/gettext ("Sunday")/e;
@end example

修飾子@code{e}は、評価可能なステートメントとして解釈して置き換えを行います。その結果、実行時に@code{gettext()}関数が呼び出されまが、この場合もparserは文字列``Sunday''を抽出することに失敗します。この機能を本当に使いたいならば、シンプルな回避策は一時的な変数を使うことです:

@example
my $sunday = gettext "Sunday";
s/<!--START_OF_WEEK-->/$sunday/;
@end example

hash slicesも手軽ですが、認識されません:

@example
my @@weekdays = @@gettext@{'Sunday', 'Monday', 'Tuesday', 'Wednesday',
                        'Thursday', 'Friday', 'Saturday'@};
# Or even:
@@weekdays = @@gettext@{qw (Sunday Monday Tuesday Wednesday Thursday
                         Friday Saturday) @};
@end example

これはtied hash %gettextの完全に有効な使い方ですが、文字列は認識されないため、抽出もされません。

現在のバージョンにたいするその他の注意点は、識別子の中の非アスキー文字にたいするお粗末なサポートがあげられます。'A'-'Z'、'a'-'z'、'0'-'9'、およびアンダースコアー
'_' の範囲外の文字を識別子に使った場合、あなたは深刻な問題に直面するでしょう。

これらの存在しない機能のうちのいくつかは将来のバージョンで実装されるかもしれませんが、最小限の努力により回避できるものばかりなので、開発の優先度は低くなっています。

たちの悪いのは、普通のテキストの中の一部にすでにbraceが含まれているようなbrace format
stringsの問題です。たとえば、プログラムの使い方を説明する文字列は、プログラムの中で普通に出会うものです:

@example
die "usage: $0 @{OPTIONS@} FILENAME...\n";
@end example

このPerlのbrace format stringsを含んだコードをインターナショナライズしようとすると、問題が起きます:

@example
die __x ("usage: @{program@} @{OPTIONS@} FILENAME...\n", program => $0);
@end example

@samp{@{program@}}はplaceholderです。一方@samp{@{OPTIONS@}}はplaceholderではなく、おそらく翻訳される必要があります。しかし最初のものを認識して、他のものをそのままにしておくように@code{xgettext}のPerl
parserに教える術はありません。

この問題を回避するためには2つの方法が考えられます。プログラムが(@code{printf()}で位置パラメーターを扱える)Perl
5.8.0以降で実行されることがわかっている場合か、翻訳者が引数の順番を変える必要がないことがわかっている場合 --
たとえば文字列に1つしかbraceのplaceholderがない場合や、上記の例のように構文を説明するためのものの場合 --
文字列をno-perl-brace-formatとマークして@code{printf()}を使うことができます:

@example
# xgettext: no-perl-brace-format
die sprintf ("usage: %s @{OPTIONS@} FILENAME...\n", $0);
@end example

もっと可搬性のあるPerlのbrace formatを使いたいときは、placeholdersをリテラルのbracesの中に配置します:

@example
die __x ("usage: @{program@} @{[@}OPTIONS@{]@} FILENAME...\n",
         program => $0, '[' => '@{', ']' => '@}');
@end example

Perlのbrace
を使った書式文字列は、エスケープするための仕組みを知りません。このエスケープするための仕組みがどのようなものであれ、これはプログラマーに困難な時をもたらし、Perlのbrace
を使った書式文字列の翻訳を困難にするか、format命令が実行されるときの実行時の性能を劣化させるでしょう。このような特別なケースでは、@code{printf()}のために幸せな時間のほとんどを費やすことになります。

@node PHP
@subsection PHP ハイパーテキストプリプロセッサー
@cindex PHP

@table @asis
@item RPM
mod_php4、mod_php4-core、phpdoc

@item Ubuntu packages
php

@item ファイル拡張子
@code{php}、@code{php3}、@code{php4}

@item 文字列構文
@code{"abc"}、@code{'abc'}

@item gettextの略記
@code{_("abc")}

@item gettext/ngettext関数
@code{gettext}、@code{dgettext}、@code{dcgettext}@*
PHP 4.2.0からは@code{ngettext}、@code{dngettext}、@code{dcngettext}

@item textdomain
@code{textdomain}関数

@item bindtextdomain
@code{bindtextdomain}関数

@item setlocale
プログラマーは、@code{setlocale (LC_ALL, "")}を呼び出さなければなりません。

@item 必要条件
---

@item GNU gettextの使用またはエミュレート
使用

@item 抽出プログラム
@code{xgettext}

@item 位置の書式
@code{printf "%2\$d %1\$d"}

@item 可搬性
gettextのないプラットフォームでは、上記の関数は利用できません。

@item po-modeでのマーキング
---
@end table

@file{examples}ディレクトリーの、例@code{hello-php}が利用できます

@node Pike
@subsection Pike
@cindex Pike

@table @asis
@item RPM
roxen

@item Ubuntu packages
pike8.0またはpike7.8

@item ファイル拡張子
@code{pike}

@item 文字列構文
@code{"abc"}

@item gettextの略記
---

@item gettext/ngettext関数
@code{gettext}、@code{dgettext}、@code{dcgettext}

@item textdomain
@code{textdomain}関数

@item bindtextdomain
@code{bindtextdomain}関数

@item setlocale
@code{setlocale} function

@item 必要条件
@code{import Locale.Gettext;}

@item GNU gettextの使用またはエミュレート
使用

@item 抽出プログラム
---

@item 位置の書式
---

@item 可搬性
gettextのないプラットフォームでは、上記の関数は利用できません。

@item po-modeでのマーキング
---
@end table

@node GCC-source
@subsection GNU Compiler Collectionソース
@cindex GCC-source

@table @asis
@item RPM
gcc

@item Ubuntu packages
gcc

@item ファイル拡張子
@code{c}、@code{h}

@item 文字列構文
@code{"abc"}

@item gettextの略記
@code{_("abc")}

@item gettext/ngettext関数
@code{gettext}、@code{dgettext}、@code{dcgettext}、@code{ngettext}、@code{dngettext}、@code{dcngettext}

@item textdomain
@code{textdomain}関数

@item bindtextdomain
@code{bindtextdomain}関数

@item setlocale
プログラマーは、@code{setlocale (LC_ALL, "")}を呼び出さなければなりません。

@item 必要条件
@code{#include "intl.h"}

@item GNU gettextの使用またはエミュレート
使用

@item 抽出プログラム
@code{xgettext -k_}

@item 位置の書式
---

@item 可搬性
autoconfマクロを使用します

@item po-modeでのマーキング
yes
@end table

@node Lua
@subsection Lua

@table @asis
@item RPM
lua

@item Ubuntu packages
luaは、lua-gettextを使用します。@*@url{https://gitlab.com/sukhichev/lua-gettext/blob/master/README.us.md}から@code{lua-gettext}パッケージをインストールする必要があります。これのDebianおよびUbuntu用のパッケージが利用できます。いずれか適切なものをダウンロードして、@samp{sudo
dpkg -i lua-gettext_0.0_amd64.deb}でインストールしてください。

@item ファイル拡張子
@code{lua}

@item 文字列構文
@itemize @bullet

@item @code{"abc"}

@item @code{'abc'}

@item @code{[[abc]]}

@item @code{[=[abc]=]}

@item @code{[==[abc]==]}

@item ...

@end itemize

@item gettextの略記
@code{_("abc")}

@item gettext/ngettext関数
@code{gettext.gettext}、@code{gettext.dgettext}、@code{gettext.dcgettext}、@code{gettext.ngettext}、@code{gettext.dngettext}、@code{gettext.dcngettext}

@item textdomain
@code{textdomain}関数

@item bindtextdomain
@code{bindtextdomain}関数

@item setlocale
自動

@item 必要条件
@code{require 'gettext'}、または@code{-l gettext}オプションでluaインタープリターを実行

@item GNU gettextの使用またはエミュレート
使用

@item 抽出プログラム
@code{xgettext}

@item 位置の書式
---

@item 可搬性
gettextのないプラットフォームでは、上記の関数は利用できません。

@item po-modeでのマーキング
---
@end table

@node JavaScript
@subsection Java Script

@table @asis
@item RPM
js

@item Ubuntu packages
gjs

@item ファイル拡張子
@code{js}

@item 文字列構文
@itemize @bullet

@item @code{"abc"}

@item @code{'abc'}

@item @code{`abc`}

@end itemize

@item gettextの略記
@code{_("abc")}

@item gettext/ngettext関数
@code{gettext}、@code{dgettext}、@code{dcgettext}、@code{ngettext}、@code{dngettext}

@item textdomain
@code{textdomain}関数

@item bindtextdomain
@code{bindtextdomain}関数

@item setlocale
自動

@item 必要条件
---

@item GNU gettextの使用またはエミュレート
使用、またはエミュレート

@item 抽出プログラム
@code{xgettext}

@item 位置の書式
---

@item 可搬性
gettextのないプラットフォームでは、上記の関数は利用できません。

@item po-modeでのマーキング
---
@end table

@node Vala
@subsection Vala

@table @asis
@item RPM
vala

@item Ubuntu packages
valac

@item ファイル拡張子
@code{vala}

@item 文字列構文
@itemize @bullet

@item @code{"abc"}

@item @code{"""abc"""}

@end itemize

@item gettextの略記
@code{_("abc")}

@item gettext/ngettext関数
@code{gettext}、@code{dgettext}、@code{dcgettext}、@code{ngettext}、@code{dngettext}、@code{dpgettext}、@code{dpgettext2}

@item textdomain
@code{Intl}ネームすペースで定義された、@code{textdomain}関数

@item bindtextdomain
@code{Intl}ネームスペースで定義された、@code{bind-text-domain}関数

@item setlocale
プログラマーは、@code{Intl.setlocale (LocaleCategory.ALL, \"\")}を呼び出さなければなりません。

@item 必要条件
---

@item GNU gettextの使用またはエミュレート
使用

@item 抽出プログラム
@code{xgettext}

@item 位置の書式
C言語と同様です

@item 可搬性
autoconf(gettext.m4)、および#if ENABLE_NLS

@item po-modeでのマーキング
yes
@end table

@c This is the template for new languages.
@ignore

@ node
@ subsection 

@table @asis
@item RPM

@item Ubuntu packages

@item ファイル拡張子

@item 文字列構文

@item gettextの略記

@item gettext/ngettext関数

@item textdomain

@item bindtextdomain

@item setlocale

@item 必要条件

@item GNU gettextの使用またはエミュレート

@item 抽出プログラム

@item 位置の書式

@item 可搬性

@item po-modeでのマーキング
@end table

@end ignore

@node Data Formats
@chapter Other Data Formats

GNU gettextツールは主にPOおよびPOTファイルを扱いますが、他のデータフォーマットのいくつかを操作することもできます。

@menu
* Internationalizable Data::  Internationalizable Data Formats
* Localized Data::           Localized Data Formats
@end menu

@node Internationalizable Data
@section インターナショナライズ可能なデータ Formats

以下は、GNU gettextを使用してインターナショナライズできる、その他のデータ型のリストです。

@menu
* POT::                      POT - Portable Object Template
* RST::                      Resource String Table
* Glade::                    Glade - GNOME user interface description
* GSettings::                GSettings - GNOME user configuration schema
* AppData::                  AppData - freedesktop.org application 
                               description
* Preparing ITS Rules::      Preparing Rules for XML Internationalization
@end menu

@node POT
@subsection POT - Portable Object Template

@table @asis
@item RPM
gettext

@item Ubuntu packages
gettext

@item ファイル拡張子
@code{pot}、@code{po}

@item 抽出プログラム
@code{xgettext}
@end table

@node RST
@subsection Resource String Table
@cindex RST
@cindex RSJ

RSTとは、バージョン3.0.0より前のFree
Pascalコンパイラーの、リソース文字列テーブルファイルのフォーマットです。RSJは、バージョン3.0.0以降のFree
Pascalコンパイラーにより作成された、新たなリソース文字列テーブルファイルのフォーマットです。

@table @asis
@item RPM
fpk

@item Ubuntu packages
fp-compiler

@item ファイル拡張子
@code{rst}、@code{rsj}

@item 抽出プログラム
@code{xgettext}、@code{rstconv}
@end table

@node Glade
@subsection Glade - GNOME user interface description

@table @asis
@item RPM
glade、libglade、glade2、libglade2、intltool

@item Ubuntu packages
glade、libglade2-dev、intltool

@item ファイル拡張子
@code{glade}、@code{glade2}、@code{ui}

@item 抽出プログラム
@code{xgettext}、@code{libglade-xgettext}、@code{xml-i18n-extract}、@code{intltool-extract}
@end table

@node GSettings
@subsection GSettings - GNOME user configuration schema

@table @asis
@item RPM
glib2

@item Ubuntu packages
libglib2.0-dev

@item ファイル拡張子
@code{gschema.xml}

@item 抽出プログラム
@code{xgettext}、@code{intltool-extract}
@end table

@node AppData
@subsection AppData - freedesktop.org application description

このファイルのフォーマットは、@url{https://www.freedesktop.org/software/appstream/docs/}内で指定されています。

@table @asis
@item RPM
appdata-tools、appstream、libappstream-glib、libappstream-glib-builder

@item Ubuntu packages
appdata-tools、appstream、libappstream-glib-dev

@item ファイル拡張子
@code{appdata.xml}、@code{metainfo.xml}

@item 抽出プログラム
@code{xgettext}、@code{intltool-extract}、@code{itstool}
@end table

@node Preparing ITS Rules
@subsection Preparing Rules for XML Internationalization
@cindex preparing rules for XML translation

XMLファイル内の翻訳可能な文字列のマーキングは、別の"ルール"ファイルを通じて行われ、これはInternationalization Tag
Set標準(ITS,
@uref{https://www.w3.org/TR/its20/})を利用します。現在サポートされているITSデータカテゴリーは、@samp{Translate}、@samp{Localization
Note}、@samp{Elements Within Text}、@samp{Preserve
Space}です。これらに加えて、@code{xgettext}は以下の拡張データカテゴリーも認識します。

@table @samp
@item Context

このデータカテゴリーは抽出されたテキストの@code{msgctxt}に関連付けられます。グローバルルールでは、@code{contextRule}要素は以下を含みます:

@itemize
@item
@code{selector}属性(必須)。これは、このルールが適用されるノードを選択するabsolute selectorを含みます。

@item
@code{msgctxt}値を保持するノードを指す、relative selectorを含む@code{contextPointer}属性(必須)。

@item
@code{msgid}値を保持するボードを指すrelative selectorを含む、@code{textPointer}属性(オプション)。
@end itemize

@item Escape Special Characters

このデータカテゴリーは、特別なXML文字(@code{<}、@code{>}、@code{&}、@code{"})が、entity
referenceでエスケープされるかどうかを示します。グローバルルールでは、@code{escapeRule}要素は以下を含みます:

@itemize
@item
@code{selector}属性(必須)。これは、このルールが適用されるノードを選択するabsolute selectorを含みます。

@item
値@code{yes}または@code{no}をもつ@code{escape}属性(必須)。
@end itemize

@item Extended Preserve Space

このデータカテゴリーは、標準の@samp{Preserve
Space}カテゴリーを、追加の値@samp{trim}および@samp{paragraph}で拡張します。@samp{trim}の値は、コンテントの前または後ろの空白文字を削除することを意味しますが、中間にある空白文字は正規化しません。@samp{paragraph}はコンテンツを正規化しますが、パラグラフ境界は維持します。グローバルルールでは、@code{preserveSpaceRule}要素は、以下を含みます:

@itemize
@item
@code{selector}属性(必須)。これは、このルールが適用されるノードを選択するabsolute selectorを含みます。

@item
値@code{default}、@code{preserve}、@code{trim}、または@code{paragraph}をもつ@code{space}属性(必須)。
@end itemize

@end table

これらすべての拡張データカテゴリーは、グローバルルールだけを表現でき、ルール要素は@code{https://www.gnu.org/s/gettext/ns/its/extensions/1.0}ネームスペースをもつ必要があります。

以下のようなXMLドキュメントファイル@file{messages.xml}が与えられたとします:

@example
<?xml version="1.0"?>
<messages>
  <message>
    <p>A translatable string</p>
  </message>
  <message>
    <p translatable="no">A non-translatable string</p>
  </message>
</messages>
@end example

1番目のテキストコンテント("A translatable string")を抽出して、2番目の("A non-translatable
string")は抽出しない場合は、以下のITSルールが使用されます:

@example
<?xml version="1.0"?>
<its:rules xmlns:its="http://www.w3.org/2005/11/its" version="1.0">
  <its:translateRule selector="/messages" translate="no"/>
  <its:translateRule selector="//message/p" translate="yes"/>

  <!-- If 'p' has an attribute 'translatable' with the value 'no', then
       the content is not translatable.  -->
  <its:translateRule selector="//message/p[@@translatable = 'no']"
    translate="no"/>
</its:rules>
@end example

これとは別に@samp{xgettext}は、XMLファイルにITSルールを関連付ける、"locating
rule"と呼ばれるファイルを必要とします。上記のITSファイルが@file{messages.its}に保存された場合、locating
ruleは以下のようになるでしょう:

@example
<?xml version="1.0"?>
<locatingRules>
  <locatingRule name="Messages" pattern="*.xml">
    <documentRule localName="messages" target="messages.its"/>
  </locatingRule>
  <locatingRule name="Messages" pattern="*.msg" target="messages.its"/>
</locatingRules>
@end example

@code{locatingRule}要素は、@code{pattern}属性をもたなければなりません。この属性は、リテラルのファイル名、またはXMLファイルのワイルドカードパターンを示します@footnote{ファイル名のマッチングは入力ファイル名から接尾辞@code{.in}を取り除いた後に行われることに注意してください。したがって、@code{pattern}属性には、@code{.in}にマッチするパターンを含めてはなりません。たとえば、入力ファイル名が@file{foo.msg.in}の場合、パターンは@code{*.in}ではなく、@code{*.msg}、または単に@code{*}とするべきです。}。@code{locatingRule}要素は、子要素として、XMLファイルの内容にたいするチェックを追加する、@code{documentRule}要素をもつことができます。

1番目のルールはファイル拡張子@file{.xml}をもつ任意のファイルにマッチしますが、root要素が@samp{<messages>}のXMLファイルだけに適用されます。

2番目のルールは、同じITSルールファイルが、拡張子@file{.msg}をもつ任意のファイルにも適用されることを示しています。@code{locatingRule}の@code{name}属性(オプション)により、ルールを名前で選択することができ、これは通常@code{xgettext}の@code{-L}オプションで行われます。

関連付けられたITSルールファイルは、@code{locatingRule}または@code{documentRule}の@code{target}属性により示されます。これが@code{documentRule}要素内で指定された場合には、親要素@code{locatingRule}は@code{target}属性をもつべきではありません。

locatingルールファイルは、ファイル拡張子@file{.loc}をもたなければなりません。ITSルールファイルとlocatingルールファイルは、@file{$prefix/share/gettext/its}ディレクトリーにインストールされていなければなりません。これらのファイルが1度正確にインストールされれば、@code{xgettext}はマッチするXMLファイルから翻訳可能文字列を抽出することができます。

@subsubsection Two Use-cases of Translated Strings in XML

XMLでは、翻訳文字列にたいして2つのユースケースがあります。1つは翻訳文字列が直接プログラムにより評価されるケースで、もう1つは翻訳文字列が元のXMLドキュメントに書き戻されてマージされるケースです。前者のケースでは、抽出文字列内の特別な文字はエスケープされるべきではなく、後者ではエスケープされるべきです。特別な文字のエスケープを制御するために、データカテゴリー@samp{Escape
Special Characters}を使うことができます。

翻訳をマージするために、@code{--xml}オプションを指定して@samp{msgfmt}プログラムを使用することができます。@samp{msgfmt}プログラムを呼び出す方法についての詳細は、@ref{msgfmt
Invocation}を参照してください。@samp{msgfmt}の@code{--xml}オプションは、文字のエスケープを処理しないので、翻訳文字列は、マークアップのための要素のような、任意のXML構造をもつことができます。

@c This is the template for new data formats.
@ignore

@ node
@ subsection 

@table @asis
@item RPM

@item Ubuntu packages

@item ファイル拡張子

@item 抽出プログラム
@end table

@end ignore

@node Localized Data
@section Localized Data Formats

以下は、ローカライズされたデータを含み、GNU gettextツールが操作できるファイルフォーマットのリストです。

@menu
* Editable Message Catalogs::  Editable Message Catalogs
* Compiled Message Catalogs::  Compiled Message Catalogs
* Desktop Entry::            Desktop Entry files
* XML::                      XML files
@end menu

@node Editable Message Catalogs
@subsection Editable Message Catalogs

これらのファイルフォーマットはすべての@code{msg*}ツールと、@code{xgettext}プログラムにより使用することができます。

これらのフォーマット間を変換するだけなら、(適切なオプションによる)@code{msgcat}プログラム、または@code{xgettext}プログラムを使用できます。

@menu
* PO::                       PO - Portable Object
* Java .properties::         Java .properties
* GNUstep .strings::         NeXTstep/GNUstep .strings
@end menu

@node PO
@subsubsection PO - Portable Object

@table @asis
@item ファイル拡張子
@code{po}
@end table

@node Java .properties
@subsubsection Java .properties

@table @asis
@item ファイル拡張子
@code{properties}
@end table

@node GNUstep .strings
@subsubsection NeXTstep/GNUstep .strings

@table @asis
@item ファイル拡張子
@code{strings}
@end table

@node Compiled Message Catalogs
@subsection Compiled Message Catalogs

これらのファイルフォーマットは@code{msgfmt}を通じて作成でき、@code{msgunfmt}でPOフォーマットに逆変換できます。

@menu
* MO::                       MO - Machine Object
* Java ResourceBundle::      Java ResourceBundle
* C# Satellite Assembly::    C# Satellite Assembly
* C# Resource::              C# Resource
* Tcl message catalog::      Tcl message catalog
* Qt message catalog::       Qt message catalog
@end menu

@node MO
@subsubsection MO - Machine Object

@table @asis
@item ファイル拡張子
@code{mo}
@end table

詳細は@ref{MO Files}を参照してください。

@node Java ResourceBundle
@subsubsection Java ResourceBundle

@table @asis
@item ファイル拡張子
@code{class}
@end table

詳細はセクション@ref{Java}、および@code{hello-java}、@code{hello-java-awt}、@code{hello-java-swing}の例を参照してください。

@node C# Satellite Assembly
@subsubsection C# Satellite Assembly

@table @asis
@item ファイル拡張子
@code{dll}
@end table

詳細は@ref{C#}を参照してください。

@node C# Resource
@subsubsection C# Resource

@table @asis
@item ファイル拡張子
@code{resources}
@end table

詳細は@ref{C#}を参照してください。

@node Tcl message catalog
@subsubsection Tcl message catalog

@table @asis
@item ファイル拡張子
@code{msg}
@end table

詳細はセクション@ref{Tcl}、および@code{hello-tcl}、@code{hello-tcl-tk}の例を参照してください。

@node Qt message catalog
@subsubsection Qt message catalog

@table @asis
@item ファイル拡張子
@code{qm}
@end table

詳細は@code{hello-c++-qt}、および@code{hello-c++-kde}の例を参照してください。

@node Desktop Entry
@subsection Desktop Entry files

プログラマーは英語文字列のみの、デスクトップエントリーファイルテンプレートを生成します。これらの文字列は、@code{xgettext}により(通常は@code{po/POTFILES.in}内のテンプレートをリストすることにより)POTファイル内に含まれます。翻訳者は、各言語にたいしてそれぞれ、POファイルを生成します。最後に@code{msgfmt
--desktop}呼び出しが、デスクトップエントリーファイル内のすべての翻訳を収集します。

詳細は、@code{hello-c-gnome3}の例を参照してください。

@node XML
@subsection XML files

また、セクション@ref{Preparing ITS Rules}、および@ref{msgfmt Invocation}のサブセクション``XML
mode operations''を参照してください。

@node Conclusion
@chapter 結びの言葉

そして最後に、Native Language Supportに関してもっと研究したり読みたい人のために、いくつかの指標を示してGNU
@code{gettext}のマニュアルを結びたいと思います。

@menu
* History::                  History of GNU @code{gettext}
* The original ABOUT-NLS::   Historical introduction
* References::               Related Readings
@end menu

@node History
@section GNU @code{gettext}の歴史
@cindex history of GNU @code{gettext}

国際対応の重要性やアルゴリズムは、非公式にではありますがが毎日のように数年に渡ってGNUで論議されてきました。ときにはGNU
@code{libc}に関係して、あるときは@code{Hurd}に関係して、あるいはその他のものに関係してです(誰もはっきり
とは覚えていません)。そしてそれから作業は実際に始まりましたが、これは先だっての議論とは独立したものでした。

全ては、Patrick D'CruzeがGNU
@code{fileutils}バージョン3.9.2の国際対応についてのアイディアそして主導権を得たとき、つまり1994年の7月に始まりました。彼はそれから保守担当者であるJim
Meyeringに、国際対応に関する変更をどのようにして正式リリースに含めるかについて尋ねました。最初のドラフトは@code{#ifdef}の塊で面食らうような代物でしたので、Jimはもっと良い方法を求めていました。PatrickとJimはこの分野においての試みや経験を共有していました。そして、結局のところこの作業はGNUに大きなインパクトを与えると感じたので、Jimは標準がどのようなものであるかを知りたくなり、そして彼はRichard
Stallmanにコンタクトを取りました。Richardはその時点で、@code{glocale}となるコード全体のデザインについて非常に手早くかつ丁寧に記述しました。

Jimは@code{glocale}を実装し、PatrickやRichardから多くのフィードバックを受けました。もちろん、Mitchum
DSouza(@code{catgets}のようなパッケージを記述した)やRoland McGrath,またDavid
MacKenzieやFran@,{c}ois Pinard、Paul
Eggertらからのフィードバックもありました。様々な方向性が入り乱れ、しかもそれら全てに互換性があるというわけではなかったため、2、3のテストリリースの後、@code{glocale}は破棄されました。特にPaul
Eggert --- 彼は常にSolarisを注視していました ---
は、@code{glocale}の@code{catgets}にもとづくAPI上に@code{gettext}APIを使用することを提唱しました。

Jimがある程度距離と時間をおき、そして二人目のパパになった間に、RolandはGNU
@code{libc}を国際対応させたいと望んでおり、Ulrich
Drepperがそのプロジェクトに加わりました。@code{glocale}から作業を始める代わりに、Ulrichは一からコードを書き直しましたが、それは@code{glocale}の作業で明らかになったガイドラインにより一層従う形になっていました。それからUlrichは以前のフォーラムから新しいプロジェクト用に人員を獲得し、@code{glocale}をまず@code{msgutils}と改称しました。それは後に@code{nlsutils}という名前になり、さらに@code{gettext}という名称になりました。これは1995年5月頃にRichardによって公式に受諾されました。

Ulrich Drepperが1995年の四月にGNU
@code{gettext}で書いたことに言及してまとめとしようかと思います。POモードを含んだパッケージの最初の公式リリースは1995年の7月に行われ、そのバージョン番号は0.7でした。その他の人々はUlrichの回りの議論フォーラムで作成された、小さなコードのかけらやテストの結
果といった諸々のものを寄贈しました。彼らの名前はGNU @code{gettext}に付随する@code{THANKS}ファイルに納められました。

この作業が進んでいた間、Fran@,{c}oisは最初に半ダースのGNUパッケージに@code{glocale}を、続いて@code{gettext}を現在のように適用してプリテストの状態にし、進化するツールを微調整するための効果的なユーザ環境を準備しました。
彼はまた、翻訳プロジェクトを組織化し統合する責任をも引き受けました。 Patrick
D'Cruzeは多くのネイティブランゲージのための20の非モデレートなメーリングリスト、そして二つのモデレートされたリスト(一つは全てのチームに直ちに届くもの、もう一つは国際化されたフリーソフトウェアパッケージの全ての自発的な管理者に連絡するためのもの)を作成し管理しました。そしてほぼ一年の間に
多くの国々の人々の間で非公式な情報交換が行われ、翻訳者チームが1995年5月に発足しました。

Fran@,{c}oisはまたGreg
McGaryの協力を受け、1995年の六月にPOモードを書きあげています。これはUlrichのパッケージに寄贈されました。彼はまたGNU
@code{gettext}のTexinfoマニュアルも寄贈しています。

1997年に、Ulrich DrepperはGNU libc
2.0をリリースし、これには関数@code{gettext}、@code{textdomain}、@code{bindtextdomain}が含まれていました。

2000年に、Ulrich Drepperはplural form処理(@code{ngettext}関数)をGNU
libcに追加しました。その後2001年、彼はGNU libc
2.2.xをリリースし、これには完全なインターナショナリゼーションをもつ、最初のフリーなCライブラリーでした。

GNU libcのGeneral Maintainerとしての役割によりUlrichは極めて多忙になったため、2000年にGNU
gettextのメンテナンスをBruno Haibleに譲り渡しました。Brunoもツールにplural form処理を追加し、UTF-8とCJK
localeのサポートの追加、およびPOファイルを取り扱うための新しいツールをいくつか記述しました。

@include nls.texi

@node References
@section 参考文献
@cindex related reading
@cindex bibliography

@strong{注意: }このセクションの文書は時代遅れになっているので、改訂する必要があります。

Eugene H. Dorr(@file{dorre@@well.com})は@cite{Internationalization Reference
List}という国際化対応に関する興味深い文献の保守を行っています。 これは次の場所で入手可能です。
@example
ftp://ftp.ora.com/pub/examples/nutshell/ujip/doc/i18n-books.txt
@end example

Michael Gschwind(@file{mike@@vlsivie.tuwien.ac.at})はProgramming for
Internationalisationというタイトルの「良くある質問」(Frequently Asked Questions
(FAQ))のリストを保守しています。このFAQは異なる言語慣習、キャラクタセットなどを扱うことが可能なプログラムの記述について論じています。そしてこれは、特にUsenet:
@w{ISO
8859-1}及び全てのキャラクタセットエンコーディングに対して適用できます。これは@file{comp.unix.questions}、@file{comp.std.internat}、@file{comp.software.international}、@file{comp.lang.c}、@file{comp.windows.x}、@file{comp.std.c}、@file{comp.answers}、@file{news.answers}から定期的に公布されています。この文書は以下にあります:
@example
ftp://ftp.vlsivie.tuwien.ac.at/pub/8bit/ISO-programming
@end example

Patrick D'Cruze(@file{pdcruze@@li.org})はNLSに関するチュートリアルを書きました。そしてJochen
Hein(@file{Hein@@student.tu-clausthal.de})はそれに関する保守作業を引き継ぎました。この文書は次の場所にあります。
@example
ftp://sunsite.unc.edu/pub/Linux/utils/nls/catalogs/Incoming/...
     ...locale-tutorial-0.8.txt.gz
@end example
@noindent
このサイトは以下のサイトへミラーリングされています。
@example
ftp://ftp.ibp.fr/pub/linux/sunsite/
@end example

同じチュートリアルのフランス語版は以下にあります。
@example
ftp://ftp.ibp.fr/pub/linux/french/docs/
@end example
@noindent
ここには、フランス語に訳されたLinux関係のドキュメントもあります。

@node Language Codes
@appendix Language Codes
@cindex language codes
@cindex ISO 639

@w{ISO
639}は多くの言語に対して2文字のコード、より珍しい言語に対して3文字のコードを規定しています。翻訳プロジェクトが言語に対して使用している省略形には、この標準が採用されています。

@menu
* Usual Language Codes::     Two-letter ISO 639 language codes
* Rare Language Codes::      Three-letter ISO 639 language codes
@end menu

@node Usual Language Codes
@appendixsec Usual Language Codes

一般的に使用される言語にたいしては、@w{ISO 639-1}標準が2文字のコードを定義しています。

@table @samp
@include iso-639.texi
@end table

@node Rare Language Codes
@appendixsec Rare Language Codes

より珍しい言語にたいしては、@w{ISO
639-2}が3文字のコードを定義しています。以下は、その言語を話す人が少なくとも100万人いるおうな、生きている言語だけに絞り込んだリストです。

@table @samp
@include iso-639-2.texi
@end table

@node Country Codes
@appendix Country Codes
@cindex country codes
@cindex ISO 3166

@w{ISO 3166}標準は、多くの国と地域に対して、2文字のコードを定義します。Translation
Project内で使用される国にたいする略記は、この標準が由来です。

@table @samp
@include iso-3166.texi
@end table

@node Licenses
@appendix Licenses
@cindex Licenses

このパッケージのファイルは、特定のファイルやディレクトリーに示されたライセンスにより保護されます。以下はサマリーです:

@itemize @bullet
@item
@code{libintl}および@code{libasprintf}ライブラリーは、GNU Lesser General Public
License(LGPL)で保護されます、このライセンスのコピーは@ref{GNU LGPL}に含まれます。

@item
このパッケージの実行可能ファイルおよび@code{libgettextpo}ライブラリーは、GNU General Public
License(GPL)により保護されます。このライセンスのコピーは@ref{GNU GPL}に含まれます。

@item
This manual is free documentation.  It is dually licensed under the GNU FDL
and the GNU GPL.  This means that you can redistribute this manual under
either of these two licenses, at your choice.  @* This manual is covered by
the GNU FDL.  Permission is granted to copy, distribute and/or modify this
document under the terms of the GNU Free Documentation License (FDL), either
version 1.2 of the License, or (at your option) any later version published
by the Free Software Foundation (FSF); with no Invariant Sections, with no
Front-Cover Text, and with no Back-Cover Texts.  A copy of the license is
included in @ref{GNU FDL}.  @* This manual is covered by the GNU GPL.  You
can redistribute it and/or modify it under the terms of the GNU General
Public License (GPL), either version 2 of the License, or (at your option)
any later version published by the Free Software Foundation (FSF).  A copy
of the license is included in @ref{GNU GPL}.
@end itemize

@menu
* GNU GPL::                  GNU General Public License
* GNU LGPL::                 GNU Lesser General Public License
* GNU FDL::                  GNU Free Documentation License
@end menu

@page
@node GNU GPL
@appendixsec GNU GENERAL PUBLIC LICENSE
@cindex GPL, GNU General Public License
@cindex License, GNU GPL
@include gpl.texi
@page
@node GNU LGPL
@appendixsec GNU LESSER GENERAL PUBLIC LICENSE
@cindex LGPL, GNU Lesser General Public License
@cindex License, GNU LGPL
@include lgpl.texi
@page
@node GNU FDL
@appendixsec GNU Free Documentation License
@cindex FDL, GNU Free Documentation License
@cindex License, GNU FDL
@include fdl.texi

@node Program Index
@unnumbered Program Index

@printindex pg

@node Option Index
@unnumbered Option Index

@printindex op

@node Variable Index
@unnumbered Variable Index

@printindex vr

@node PO Mode Index
@unnumbered PO Mode Index

@printindex em

@node Autoconf Macro Index
@unnumbered Autoconf Macro Index

@printindex am

@node Index
@unnumbered General Index

@printindex cp

@bye

@c Local variables:
@c texinfo-column-for-description: 32
@c End:
